import{createRequire as r}from"module";var t={611:(r,t,a)=>{
/*! node-domexception. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */
if(!globalThis.DOMException){try{const{MessageChannel:r}=a(267),t=(new r).port1,n=new ArrayBuffer;t.postMessage(n,[n,n])}catch(r){r.constructor.name==="DOMException"&&(globalThis.DOMException=r.constructor)}}r.exports=globalThis.DOMException},107:function(r,t){(function(r,a){true?a(t):0})(this,(function(r){"use strict";const t=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?Symbol:r=>`Symbol(${r})`;function noop(){return undefined}function getGlobals(){if(typeof self!=="undefined"){return self}else if(typeof window!=="undefined"){return window}else if(typeof global!=="undefined"){return global}return undefined}const a=getGlobals();function typeIsObject(r){return typeof r==="object"&&r!==null||typeof r==="function"}const n=noop;const o=Promise;const i=Promise.prototype.then;const l=Promise.resolve.bind(o);const s=Promise.reject.bind(o);function newPromise(r){return new o(r)}function promiseResolvedWith(r){return l(r)}function promiseRejectedWith(r){return s(r)}function PerformPromiseThen(r,t,a){return i.call(r,t,a)}function uponPromise(r,t,a){PerformPromiseThen(PerformPromiseThen(r,t,a),undefined,n)}function uponFulfillment(r,t){uponPromise(r,t)}function uponRejection(r,t){uponPromise(r,undefined,t)}function transformPromiseWith(r,t,a){return PerformPromiseThen(r,t,a)}function setPromiseIsHandledToTrue(r){PerformPromiseThen(r,undefined,n)}const u=(()=>{const r=a&&a.queueMicrotask;if(typeof r==="function"){return r}const t=promiseResolvedWith(undefined);return r=>PerformPromiseThen(t,r)})();function reflectCall(r,t,a){if(typeof r!=="function"){throw new TypeError("Argument is not a function")}return Function.prototype.apply.call(r,t,a)}function promiseCall(r,t,a){try{return promiseResolvedWith(reflectCall(r,t,a))}catch(r){return promiseRejectedWith(r)}}const d=16384;class SimpleQueue{constructor(){this._cursor=0;this._size=0;this._front={_elements:[],_next:undefined};this._back=this._front;this._cursor=0;this._size=0}get length(){return this._size}push(r){const t=this._back;let a=t;if(t._elements.length===d-1){a={_elements:[],_next:undefined}}t._elements.push(r);if(a!==t){this._back=a;t._next=a}++this._size}shift(){const r=this._front;let t=r;const a=this._cursor;let n=a+1;const o=r._elements;const i=o[a];if(n===d){t=r._next;n=0}--this._size;this._cursor=n;if(r!==t){this._front=t}o[a]=undefined;return i}forEach(r){let t=this._cursor;let a=this._front;let n=a._elements;while(t!==n.length||a._next!==undefined){if(t===n.length){a=a._next;n=a._elements;t=0;if(n.length===0){break}}r(n[t]);++t}}peek(){const r=this._front;const t=this._cursor;return r._elements[t]}}function ReadableStreamReaderGenericInitialize(r,t){r._ownerReadableStream=t;t._reader=r;if(t._state==="readable"){defaultReaderClosedPromiseInitialize(r)}else if(t._state==="closed"){defaultReaderClosedPromiseInitializeAsResolved(r)}else{defaultReaderClosedPromiseInitializeAsRejected(r,t._storedError)}}function ReadableStreamReaderGenericCancel(r,t){const a=r._ownerReadableStream;return ReadableStreamCancel(a,t)}function ReadableStreamReaderGenericRelease(r){if(r._ownerReadableStream._state==="readable"){defaultReaderClosedPromiseReject(r,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}else{defaultReaderClosedPromiseResetToRejected(r,new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`))}r._ownerReadableStream._reader=undefined;r._ownerReadableStream=undefined}function readerLockException(r){return new TypeError("Cannot "+r+" a stream using a released reader")}function defaultReaderClosedPromiseInitialize(r){r._closedPromise=newPromise(((t,a)=>{r._closedPromise_resolve=t;r._closedPromise_reject=a}))}function defaultReaderClosedPromiseInitializeAsRejected(r,t){defaultReaderClosedPromiseInitialize(r);defaultReaderClosedPromiseReject(r,t)}function defaultReaderClosedPromiseInitializeAsResolved(r){defaultReaderClosedPromiseInitialize(r);defaultReaderClosedPromiseResolve(r)}function defaultReaderClosedPromiseReject(r,t){if(r._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(r._closedPromise);r._closedPromise_reject(t);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined}function defaultReaderClosedPromiseResetToRejected(r,t){defaultReaderClosedPromiseInitializeAsRejected(r,t)}function defaultReaderClosedPromiseResolve(r){if(r._closedPromise_resolve===undefined){return}r._closedPromise_resolve(undefined);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined}const c=t("[[AbortSteps]]");const m=t("[[ErrorSteps]]");const b=t("[[CancelSteps]]");const h=t("[[PullSteps]]");const p=Number.isFinite||function(r){return typeof r==="number"&&isFinite(r)};const S=Math.trunc||function(r){return r<0?Math.ceil(r):Math.floor(r)};function isDictionary(r){return typeof r==="object"||typeof r==="function"}function assertDictionary(r,t){if(r!==undefined&&!isDictionary(r)){throw new TypeError(`${t} is not an object.`)}}function assertFunction(r,t){if(typeof r!=="function"){throw new TypeError(`${t} is not a function.`)}}function isObject(r){return typeof r==="object"&&r!==null||typeof r==="function"}function assertObject(r,t){if(!isObject(r)){throw new TypeError(`${t} is not an object.`)}}function assertRequiredArgument(r,t,a){if(r===undefined){throw new TypeError(`Parameter ${t} is required in '${a}'.`)}}function assertRequiredField(r,t,a){if(r===undefined){throw new TypeError(`${t} is required in '${a}'.`)}}function convertUnrestrictedDouble(r){return Number(r)}function censorNegativeZero(r){return r===0?0:r}function integerPart(r){return censorNegativeZero(S(r))}function convertUnsignedLongLongWithEnforceRange(r,t){const a=0;const n=Number.MAX_SAFE_INTEGER;let o=Number(r);o=censorNegativeZero(o);if(!p(o)){throw new TypeError(`${t} is not a finite number`)}o=integerPart(o);if(o<a||o>n){throw new TypeError(`${t} is outside the accepted range of ${a} to ${n}, inclusive`)}if(!p(o)||o===0){return 0}return o}function assertReadableStream(r,t){if(!IsReadableStream(r)){throw new TypeError(`${t} is not a ReadableStream.`)}}function AcquireReadableStreamDefaultReader(r){return new ReadableStreamDefaultReader(r)}function ReadableStreamAddReadRequest(r,t){r._reader._readRequests.push(t)}function ReadableStreamFulfillReadRequest(r,t,a){const n=r._reader;const o=n._readRequests.shift();if(a){o._closeSteps()}else{o._chunkSteps(t)}}function ReadableStreamGetNumReadRequests(r){return r._reader._readRequests.length}function ReadableStreamHasDefaultReader(r){const t=r._reader;if(t===undefined){return false}if(!IsReadableStreamDefaultReader(t)){return false}return true}class ReadableStreamDefaultReader{constructor(r){assertRequiredArgument(r,1,"ReadableStreamDefaultReader");assertReadableStream(r,"First parameter");if(IsReadableStreamLocked(r)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}ReadableStreamReaderGenericInitialize(this,r);this._readRequests=new SimpleQueue}get closed(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("closed"))}return this._closedPromise}cancel(r=undefined){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,r)}read(){if(!IsReadableStreamDefaultReader(this)){return promiseRejectedWith(defaultReaderBrandCheckException("read"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let r;let t;const a=newPromise(((a,n)=>{r=a;t=n}));const n={_chunkSteps:t=>r({value:t,done:false}),_closeSteps:()=>r({value:undefined,done:true}),_errorSteps:r=>t(r)};ReadableStreamDefaultReaderRead(this,n);return a}releaseLock(){if(!IsReadableStreamDefaultReader(this)){throw defaultReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}if(this._readRequests.length>0){throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled")}ReadableStreamReaderGenericRelease(this)}}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultReader.prototype,t.toStringTag,{value:"ReadableStreamDefaultReader",configurable:true})}function IsReadableStreamDefaultReader(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_readRequests")){return false}return r instanceof ReadableStreamDefaultReader}function ReadableStreamDefaultReaderRead(r,t){const a=r._ownerReadableStream;a._disturbed=true;if(a._state==="closed"){t._closeSteps()}else if(a._state==="errored"){t._errorSteps(a._storedError)}else{a._readableStreamController[h](t)}}function defaultReaderBrandCheckException(r){return new TypeError(`ReadableStreamDefaultReader.prototype.${r} can only be used on a ReadableStreamDefaultReader`)}const y=Object.getPrototypeOf(Object.getPrototypeOf((async function*(){})).prototype);class ReadableStreamAsyncIteratorImpl{constructor(r,t){this._ongoingPromise=undefined;this._isFinished=false;this._reader=r;this._preventCancel=t}next(){const nextSteps=()=>this._nextSteps();this._ongoingPromise=this._ongoingPromise?transformPromiseWith(this._ongoingPromise,nextSteps,nextSteps):nextSteps();return this._ongoingPromise}return(r){const returnSteps=()=>this._returnSteps(r);return this._ongoingPromise?transformPromiseWith(this._ongoingPromise,returnSteps,returnSteps):returnSteps()}_nextSteps(){if(this._isFinished){return Promise.resolve({value:undefined,done:true})}const r=this._reader;if(r._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("iterate"))}let t;let a;const n=newPromise(((r,n)=>{t=r;a=n}));const o={_chunkSteps:r=>{this._ongoingPromise=undefined;u((()=>t({value:r,done:false})))},_closeSteps:()=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(r);t({value:undefined,done:true})},_errorSteps:t=>{this._ongoingPromise=undefined;this._isFinished=true;ReadableStreamReaderGenericRelease(r);a(t)}};ReadableStreamDefaultReaderRead(r,o);return n}_returnSteps(r){if(this._isFinished){return Promise.resolve({value:r,done:true})}this._isFinished=true;const t=this._reader;if(t._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("finish iterating"))}if(!this._preventCancel){const a=ReadableStreamReaderGenericCancel(t,r);ReadableStreamReaderGenericRelease(t);return transformPromiseWith(a,(()=>({value:r,done:true})))}ReadableStreamReaderGenericRelease(t);return promiseResolvedWith({value:r,done:true})}}const R={next(){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"))}return this._asyncIteratorImpl.next()},return(r){if(!IsReadableStreamAsyncIterator(this)){return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"))}return this._asyncIteratorImpl.return(r)}};if(y!==undefined){Object.setPrototypeOf(R,y)}function AcquireReadableStreamAsyncIterator(r,t){const a=AcquireReadableStreamDefaultReader(r);const n=new ReadableStreamAsyncIteratorImpl(a,t);const o=Object.create(R);o._asyncIteratorImpl=n;return o}function IsReadableStreamAsyncIterator(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_asyncIteratorImpl")){return false}try{return r._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl}catch(r){return false}}function streamAsyncIteratorBrandCheckException(r){return new TypeError(`ReadableStreamAsyncIterator.${r} can only be used on a ReadableSteamAsyncIterator`)}const g=Number.isNaN||function(r){return r!==r};function CreateArrayFromList(r){return r.slice()}function CopyDataBlockBytes(r,t,a,n,o){new Uint8Array(r).set(new Uint8Array(a,n,o),t)}function TransferArrayBuffer(r){return r}function IsDetachedBuffer(r){return false}function ArrayBufferSlice(r,t,a){if(r.slice){return r.slice(t,a)}const n=a-t;const o=new ArrayBuffer(n);CopyDataBlockBytes(o,0,r,t,n);return o}function IsNonNegativeNumber(r){if(typeof r!=="number"){return false}if(g(r)){return false}if(r<0){return false}return true}function CloneAsUint8Array(r){const t=ArrayBufferSlice(r.buffer,r.byteOffset,r.byteOffset+r.byteLength);return new Uint8Array(t)}function DequeueValue(r){const t=r._queue.shift();r._queueTotalSize-=t.size;if(r._queueTotalSize<0){r._queueTotalSize=0}return t.value}function EnqueueValueWithSize(r,t,a){if(!IsNonNegativeNumber(a)||a===Infinity){throw new RangeError("Size must be a finite, non-NaN, non-negative number.")}r._queue.push({value:t,size:a});r._queueTotalSize+=a}function PeekQueueValue(r){const t=r._queue.peek();return t.value}function ResetQueue(r){r._queue=new SimpleQueue;r._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("view")}return this._view}respond(r){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respond")}assertRequiredArgument(r,1,"respond");r=convertUnsignedLongLongWithEnforceRange(r,"First parameter");if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(this._view.buffer));ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController,r)}respondWithNewView(r){if(!IsReadableStreamBYOBRequest(this)){throw byobRequestBrandCheckException("respondWithNewView")}assertRequiredArgument(r,1,"respondWithNewView");if(!ArrayBuffer.isView(r)){throw new TypeError("You can only respond with array buffer views")}if(this._associatedReadableByteStreamController===undefined){throw new TypeError("This BYOB request has been invalidated")}if(IsDetachedBuffer(r.buffer));ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController,r)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:true},respondWithNewView:{enumerable:true},view:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBRequest.prototype,t.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:true})}class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("byobRequest")}return ReadableByteStreamControllerGetBYOBRequest(this)}get desiredSize(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("desiredSize")}return ReadableByteStreamControllerGetDesiredSize(this)}close(){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("close")}if(this._closeRequested){throw new TypeError("The stream has already been closed; do not close it again!")}const r=this._controlledReadableByteStream._state;if(r!=="readable"){throw new TypeError(`The stream (in ${r} state) is not in the readable state and cannot be closed`)}ReadableByteStreamControllerClose(this)}enqueue(r){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("enqueue")}assertRequiredArgument(r,1,"enqueue");if(!ArrayBuffer.isView(r)){throw new TypeError("chunk must be an array buffer view")}if(r.byteLength===0){throw new TypeError("chunk must have non-zero byteLength")}if(r.buffer.byteLength===0){throw new TypeError(`chunk's buffer must have non-zero byteLength`)}if(this._closeRequested){throw new TypeError("stream is closed or draining")}const t=this._controlledReadableByteStream._state;if(t!=="readable"){throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`)}ReadableByteStreamControllerEnqueue(this,r)}error(r=undefined){if(!IsReadableByteStreamController(this)){throw byteStreamControllerBrandCheckException("error")}ReadableByteStreamControllerError(this,r)}[b](r){ReadableByteStreamControllerClearPendingPullIntos(this);ResetQueue(this);const t=this._cancelAlgorithm(r);ReadableByteStreamControllerClearAlgorithms(this);return t}[h](r){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0){const t=this._queue.shift();this._queueTotalSize-=t.byteLength;ReadableByteStreamControllerHandleQueueDrain(this);const a=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);r._chunkSteps(a);return}const a=this._autoAllocateChunkSize;if(a!==undefined){let t;try{t=new ArrayBuffer(a)}catch(t){r._errorSteps(t);return}const n={buffer:t,bufferByteLength:a,byteOffset:0,byteLength:a,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(n)}ReadableStreamAddReadRequest(t,r);ReadableByteStreamControllerCallPullIfNeeded(this)}}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},byobRequest:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableByteStreamController.prototype,t.toStringTag,{value:"ReadableByteStreamController",configurable:true})}function IsReadableByteStreamController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledReadableByteStream")){return false}return r instanceof ReadableByteStreamController}function IsReadableStreamBYOBRequest(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_associatedReadableByteStreamController")){return false}return r instanceof ReadableStreamBYOBRequest}function ReadableByteStreamControllerCallPullIfNeeded(r){const t=ReadableByteStreamControllerShouldCallPull(r);if(!t){return}if(r._pulling){r._pullAgain=true;return}r._pulling=true;const a=r._pullAlgorithm();uponPromise(a,(()=>{r._pulling=false;if(r._pullAgain){r._pullAgain=false;ReadableByteStreamControllerCallPullIfNeeded(r)}}),(t=>{ReadableByteStreamControllerError(r,t)}))}function ReadableByteStreamControllerClearPendingPullIntos(r){ReadableByteStreamControllerInvalidateBYOBRequest(r);r._pendingPullIntos=new SimpleQueue}function ReadableByteStreamControllerCommitPullIntoDescriptor(r,t){let a=false;if(r._state==="closed"){a=true}const n=ReadableByteStreamControllerConvertPullIntoDescriptor(t);if(t.readerType==="default"){ReadableStreamFulfillReadRequest(r,n,a)}else{ReadableStreamFulfillReadIntoRequest(r,n,a)}}function ReadableByteStreamControllerConvertPullIntoDescriptor(r){const t=r.bytesFilled;const a=r.elementSize;return new r.viewConstructor(r.buffer,r.byteOffset,t/a)}function ReadableByteStreamControllerEnqueueChunkToQueue(r,t,a,n){r._queue.push({buffer:t,byteOffset:a,byteLength:n});r._queueTotalSize+=n}function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,t){const a=t.elementSize;const n=t.bytesFilled-t.bytesFilled%a;const o=Math.min(r._queueTotalSize,t.byteLength-t.bytesFilled);const i=t.bytesFilled+o;const l=i-i%a;let s=o;let u=false;if(l>n){s=l-t.bytesFilled;u=true}const d=r._queue;while(s>0){const a=d.peek();const n=Math.min(s,a.byteLength);const o=t.byteOffset+t.bytesFilled;CopyDataBlockBytes(t.buffer,o,a.buffer,a.byteOffset,n);if(a.byteLength===n){d.shift()}else{a.byteOffset+=n;a.byteLength-=n}r._queueTotalSize-=n;ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,n,t);s-=n}return u}function ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,t,a){a.bytesFilled+=t}function ReadableByteStreamControllerHandleQueueDrain(r){if(r._queueTotalSize===0&&r._closeRequested){ReadableByteStreamControllerClearAlgorithms(r);ReadableStreamClose(r._controlledReadableByteStream)}else{ReadableByteStreamControllerCallPullIfNeeded(r)}}function ReadableByteStreamControllerInvalidateBYOBRequest(r){if(r._byobRequest===null){return}r._byobRequest._associatedReadableByteStreamController=undefined;r._byobRequest._view=null;r._byobRequest=null}function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r){while(r._pendingPullIntos.length>0){if(r._queueTotalSize===0){return}const t=r._pendingPullIntos.peek();if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,t)){ReadableByteStreamControllerShiftPendingPullInto(r);ReadableByteStreamControllerCommitPullIntoDescriptor(r._controlledReadableByteStream,t)}}}function ReadableByteStreamControllerPullInto(r,t,a){const n=r._controlledReadableByteStream;let o=1;if(t.constructor!==DataView){o=t.constructor.BYTES_PER_ELEMENT}const i=t.constructor;const l=TransferArrayBuffer(t.buffer);const s={buffer:l,bufferByteLength:l.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:o,viewConstructor:i,readerType:"byob"};if(r._pendingPullIntos.length>0){r._pendingPullIntos.push(s);ReadableStreamAddReadIntoRequest(n,a);return}if(n._state==="closed"){const r=new i(s.buffer,s.byteOffset,0);a._closeSteps(r);return}if(r._queueTotalSize>0){if(ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(r,s)){const t=ReadableByteStreamControllerConvertPullIntoDescriptor(s);ReadableByteStreamControllerHandleQueueDrain(r);a._chunkSteps(t);return}if(r._closeRequested){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(r,t);a._errorSteps(t);return}}r._pendingPullIntos.push(s);ReadableStreamAddReadIntoRequest(n,a);ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerRespondInClosedState(r,t){const a=r._controlledReadableByteStream;if(ReadableStreamHasBYOBReader(a)){while(ReadableStreamGetNumReadIntoRequests(a)>0){const t=ReadableByteStreamControllerShiftPendingPullInto(r);ReadableByteStreamControllerCommitPullIntoDescriptor(a,t)}}}function ReadableByteStreamControllerRespondInReadableState(r,t,a){ReadableByteStreamControllerFillHeadPullIntoDescriptor(r,t,a);if(a.bytesFilled<a.elementSize){return}ReadableByteStreamControllerShiftPendingPullInto(r);const n=a.bytesFilled%a.elementSize;if(n>0){const t=a.byteOffset+a.bytesFilled;const o=ArrayBufferSlice(a.buffer,t-n,t);ReadableByteStreamControllerEnqueueChunkToQueue(r,o,0,o.byteLength)}a.bytesFilled-=n;ReadableByteStreamControllerCommitPullIntoDescriptor(r._controlledReadableByteStream,a);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r)}function ReadableByteStreamControllerRespondInternal(r,t){const a=r._pendingPullIntos.peek();ReadableByteStreamControllerInvalidateBYOBRequest(r);const n=r._controlledReadableByteStream._state;if(n==="closed"){ReadableByteStreamControllerRespondInClosedState(r)}else{ReadableByteStreamControllerRespondInReadableState(r,t,a)}ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerShiftPendingPullInto(r){const t=r._pendingPullIntos.shift();return t}function ReadableByteStreamControllerShouldCallPull(r){const t=r._controlledReadableByteStream;if(t._state!=="readable"){return false}if(r._closeRequested){return false}if(!r._started){return false}if(ReadableStreamHasDefaultReader(t)&&ReadableStreamGetNumReadRequests(t)>0){return true}if(ReadableStreamHasBYOBReader(t)&&ReadableStreamGetNumReadIntoRequests(t)>0){return true}const a=ReadableByteStreamControllerGetDesiredSize(r);if(a>0){return true}return false}function ReadableByteStreamControllerClearAlgorithms(r){r._pullAlgorithm=undefined;r._cancelAlgorithm=undefined}function ReadableByteStreamControllerClose(r){const t=r._controlledReadableByteStream;if(r._closeRequested||t._state!=="readable"){return}if(r._queueTotalSize>0){r._closeRequested=true;return}if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(t.bytesFilled>0){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");ReadableByteStreamControllerError(r,t);throw t}}ReadableByteStreamControllerClearAlgorithms(r);ReadableStreamClose(t)}function ReadableByteStreamControllerEnqueue(r,t){const a=r._controlledReadableByteStream;if(r._closeRequested||a._state!=="readable"){return}const n=t.buffer;const o=t.byteOffset;const i=t.byteLength;const l=TransferArrayBuffer(n);if(r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();if(IsDetachedBuffer(t.buffer));t.buffer=TransferArrayBuffer(t.buffer)}ReadableByteStreamControllerInvalidateBYOBRequest(r);if(ReadableStreamHasDefaultReader(a)){if(ReadableStreamGetNumReadRequests(a)===0){ReadableByteStreamControllerEnqueueChunkToQueue(r,l,o,i)}else{if(r._pendingPullIntos.length>0){ReadableByteStreamControllerShiftPendingPullInto(r)}const t=new Uint8Array(l,o,i);ReadableStreamFulfillReadRequest(a,t,false)}}else if(ReadableStreamHasBYOBReader(a)){ReadableByteStreamControllerEnqueueChunkToQueue(r,l,o,i);ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(r)}else{ReadableByteStreamControllerEnqueueChunkToQueue(r,l,o,i)}ReadableByteStreamControllerCallPullIfNeeded(r)}function ReadableByteStreamControllerError(r,t){const a=r._controlledReadableByteStream;if(a._state!=="readable"){return}ReadableByteStreamControllerClearPendingPullIntos(r);ResetQueue(r);ReadableByteStreamControllerClearAlgorithms(r);ReadableStreamError(a,t)}function ReadableByteStreamControllerGetBYOBRequest(r){if(r._byobRequest===null&&r._pendingPullIntos.length>0){const t=r._pendingPullIntos.peek();const a=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled);const n=Object.create(ReadableStreamBYOBRequest.prototype);SetUpReadableStreamBYOBRequest(n,r,a);r._byobRequest=n}return r._byobRequest}function ReadableByteStreamControllerGetDesiredSize(r){const t=r._controlledReadableByteStream._state;if(t==="errored"){return null}if(t==="closed"){return 0}return r._strategyHWM-r._queueTotalSize}function ReadableByteStreamControllerRespond(r,t){const a=r._pendingPullIntos.peek();const n=r._controlledReadableByteStream._state;if(n==="closed"){if(t!==0){throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}}else{if(t===0){throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream")}if(a.bytesFilled+t>a.byteLength){throw new RangeError("bytesWritten out of range")}}a.buffer=TransferArrayBuffer(a.buffer);ReadableByteStreamControllerRespondInternal(r,t)}function ReadableByteStreamControllerRespondWithNewView(r,t){const a=r._pendingPullIntos.peek();const n=r._controlledReadableByteStream._state;if(n==="closed"){if(t.byteLength!==0){throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}}else{if(t.byteLength===0){throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream")}}if(a.byteOffset+a.bytesFilled!==t.byteOffset){throw new RangeError("The region specified by view does not match byobRequest")}if(a.bufferByteLength!==t.buffer.byteLength){throw new RangeError("The buffer of view has different capacity than byobRequest")}if(a.bytesFilled+t.byteLength>a.byteLength){throw new RangeError("The region specified by view is larger than byobRequest")}const o=t.byteLength;a.buffer=TransferArrayBuffer(t.buffer);ReadableByteStreamControllerRespondInternal(r,o)}function SetUpReadableByteStreamController(r,t,a,n,o,i,l){t._controlledReadableByteStream=r;t._pullAgain=false;t._pulling=false;t._byobRequest=null;t._queue=t._queueTotalSize=undefined;ResetQueue(t);t._closeRequested=false;t._started=false;t._strategyHWM=i;t._pullAlgorithm=n;t._cancelAlgorithm=o;t._autoAllocateChunkSize=l;t._pendingPullIntos=new SimpleQueue;r._readableStreamController=t;const s=a();uponPromise(promiseResolvedWith(s),(()=>{t._started=true;ReadableByteStreamControllerCallPullIfNeeded(t)}),(r=>{ReadableByteStreamControllerError(t,r)}))}function SetUpReadableByteStreamControllerFromUnderlyingSource(r,t,a){const n=Object.create(ReadableByteStreamController.prototype);let startAlgorithm=()=>undefined;let pullAlgorithm=()=>promiseResolvedWith(undefined);let cancelAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(n)}if(t.pull!==undefined){pullAlgorithm=()=>t.pull(n)}if(t.cancel!==undefined){cancelAlgorithm=r=>t.cancel(r)}const o=t.autoAllocateChunkSize;if(o===0){throw new TypeError("autoAllocateChunkSize must be greater than 0")}SetUpReadableByteStreamController(r,n,startAlgorithm,pullAlgorithm,cancelAlgorithm,a,o)}function SetUpReadableStreamBYOBRequest(r,t,a){r._associatedReadableByteStreamController=t;r._view=a}function byobRequestBrandCheckException(r){return new TypeError(`ReadableStreamBYOBRequest.prototype.${r} can only be used on a ReadableStreamBYOBRequest`)}function byteStreamControllerBrandCheckException(r){return new TypeError(`ReadableByteStreamController.prototype.${r} can only be used on a ReadableByteStreamController`)}function AcquireReadableStreamBYOBReader(r){return new ReadableStreamBYOBReader(r)}function ReadableStreamAddReadIntoRequest(r,t){r._reader._readIntoRequests.push(t)}function ReadableStreamFulfillReadIntoRequest(r,t,a){const n=r._reader;const o=n._readIntoRequests.shift();if(a){o._closeSteps(t)}else{o._chunkSteps(t)}}function ReadableStreamGetNumReadIntoRequests(r){return r._reader._readIntoRequests.length}function ReadableStreamHasBYOBReader(r){const t=r._reader;if(t===undefined){return false}if(!IsReadableStreamBYOBReader(t)){return false}return true}class ReadableStreamBYOBReader{constructor(r){assertRequiredArgument(r,1,"ReadableStreamBYOBReader");assertReadableStream(r,"First parameter");if(IsReadableStreamLocked(r)){throw new TypeError("This stream has already been locked for exclusive reading by another reader")}if(!IsReadableByteStreamController(r._readableStreamController)){throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte "+"source")}ReadableStreamReaderGenericInitialize(this,r);this._readIntoRequests=new SimpleQueue}get closed(){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("closed"))}return this._closedPromise}cancel(r=undefined){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("cancel"))}if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("cancel"))}return ReadableStreamReaderGenericCancel(this,r)}read(r){if(!IsReadableStreamBYOBReader(this)){return promiseRejectedWith(byobReaderBrandCheckException("read"))}if(!ArrayBuffer.isView(r)){return promiseRejectedWith(new TypeError("view must be an array buffer view"))}if(r.byteLength===0){return promiseRejectedWith(new TypeError("view must have non-zero byteLength"))}if(r.buffer.byteLength===0){return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`))}if(IsDetachedBuffer(r.buffer));if(this._ownerReadableStream===undefined){return promiseRejectedWith(readerLockException("read from"))}let t;let a;const n=newPromise(((r,n)=>{t=r;a=n}));const o={_chunkSteps:r=>t({value:r,done:false}),_closeSteps:r=>t({value:r,done:true}),_errorSteps:r=>a(r)};ReadableStreamBYOBReaderRead(this,r,o);return n}releaseLock(){if(!IsReadableStreamBYOBReader(this)){throw byobReaderBrandCheckException("releaseLock")}if(this._ownerReadableStream===undefined){return}if(this._readIntoRequests.length>0){throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled")}ReadableStreamReaderGenericRelease(this)}}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:true},read:{enumerable:true},releaseLock:{enumerable:true},closed:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamBYOBReader.prototype,t.toStringTag,{value:"ReadableStreamBYOBReader",configurable:true})}function IsReadableStreamBYOBReader(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_readIntoRequests")){return false}return r instanceof ReadableStreamBYOBReader}function ReadableStreamBYOBReaderRead(r,t,a){const n=r._ownerReadableStream;n._disturbed=true;if(n._state==="errored"){a._errorSteps(n._storedError)}else{ReadableByteStreamControllerPullInto(n._readableStreamController,t,a)}}function byobReaderBrandCheckException(r){return new TypeError(`ReadableStreamBYOBReader.prototype.${r} can only be used on a ReadableStreamBYOBReader`)}function ExtractHighWaterMark(r,t){const{highWaterMark:a}=r;if(a===undefined){return t}if(g(a)||a<0){throw new RangeError("Invalid highWaterMark")}return a}function ExtractSizeAlgorithm(r){const{size:t}=r;if(!t){return()=>1}return t}function convertQueuingStrategy(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.highWaterMark;const n=r===null||r===void 0?void 0:r.size;return{highWaterMark:a===undefined?undefined:convertUnrestrictedDouble(a),size:n===undefined?undefined:convertQueuingStrategySize(n,`${t} has member 'size' that`)}}function convertQueuingStrategySize(r,t){assertFunction(r,t);return t=>convertUnrestrictedDouble(r(t))}function convertUnderlyingSink(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.abort;const n=r===null||r===void 0?void 0:r.close;const o=r===null||r===void 0?void 0:r.start;const i=r===null||r===void 0?void 0:r.type;const l=r===null||r===void 0?void 0:r.write;return{abort:a===undefined?undefined:convertUnderlyingSinkAbortCallback(a,r,`${t} has member 'abort' that`),close:n===undefined?undefined:convertUnderlyingSinkCloseCallback(n,r,`${t} has member 'close' that`),start:o===undefined?undefined:convertUnderlyingSinkStartCallback(o,r,`${t} has member 'start' that`),write:l===undefined?undefined:convertUnderlyingSinkWriteCallback(l,r,`${t} has member 'write' that`),type:i}}function convertUnderlyingSinkAbortCallback(r,t,a){assertFunction(r,a);return a=>promiseCall(r,t,[a])}function convertUnderlyingSinkCloseCallback(r,t,a){assertFunction(r,a);return()=>promiseCall(r,t,[])}function convertUnderlyingSinkStartCallback(r,t,a){assertFunction(r,a);return a=>reflectCall(r,t,[a])}function convertUnderlyingSinkWriteCallback(r,t,a){assertFunction(r,a);return(a,n)=>promiseCall(r,t,[a,n])}function assertWritableStream(r,t){if(!IsWritableStream(r)){throw new TypeError(`${t} is not a WritableStream.`)}}function isAbortSignal(r){if(typeof r!=="object"||r===null){return false}try{return typeof r.aborted==="boolean"}catch(r){return false}}const _=typeof AbortController==="function";function createAbortController(){if(_){return new AbortController}return undefined}class WritableStream{constructor(r={},t={}){if(r===undefined){r=null}else{assertObject(r,"First parameter")}const a=convertQueuingStrategy(t,"Second parameter");const n=convertUnderlyingSink(r,"First parameter");InitializeWritableStream(this);const o=n.type;if(o!==undefined){throw new RangeError("Invalid type is specified")}const i=ExtractSizeAlgorithm(a);const l=ExtractHighWaterMark(a,1);SetUpWritableStreamDefaultControllerFromUnderlyingSink(this,n,l,i)}get locked(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("locked")}return IsWritableStreamLocked(this)}abort(r=undefined){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("abort"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"))}return WritableStreamAbort(this,r)}close(){if(!IsWritableStream(this)){return promiseRejectedWith(streamBrandCheckException$2("close"))}if(IsWritableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"))}if(WritableStreamCloseQueuedOrInFlight(this)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamClose(this)}getWriter(){if(!IsWritableStream(this)){throw streamBrandCheckException$2("getWriter")}return AcquireWritableStreamDefaultWriter(this)}}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:true},close:{enumerable:true},getWriter:{enumerable:true},locked:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStream.prototype,t.toStringTag,{value:"WritableStream",configurable:true})}function AcquireWritableStreamDefaultWriter(r){return new WritableStreamDefaultWriter(r)}function CreateWritableStream(r,t,a,n,o=1,i=(()=>1)){const l=Object.create(WritableStream.prototype);InitializeWritableStream(l);const s=Object.create(WritableStreamDefaultController.prototype);SetUpWritableStreamDefaultController(l,s,r,t,a,n,o,i);return l}function InitializeWritableStream(r){r._state="writable";r._storedError=undefined;r._writer=undefined;r._writableStreamController=undefined;r._writeRequests=new SimpleQueue;r._inFlightWriteRequest=undefined;r._closeRequest=undefined;r._inFlightCloseRequest=undefined;r._pendingAbortRequest=undefined;r._backpressure=false}function IsWritableStream(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_writableStreamController")){return false}return r instanceof WritableStream}function IsWritableStreamLocked(r){if(r._writer===undefined){return false}return true}function WritableStreamAbort(r,t){var a;if(r._state==="closed"||r._state==="errored"){return promiseResolvedWith(undefined)}r._writableStreamController._abortReason=t;(a=r._writableStreamController._abortController)===null||a===void 0?void 0:a.abort();const n=r._state;if(n==="closed"||n==="errored"){return promiseResolvedWith(undefined)}if(r._pendingAbortRequest!==undefined){return r._pendingAbortRequest._promise}let o=false;if(n==="erroring"){o=true;t=undefined}const i=newPromise(((a,n)=>{r._pendingAbortRequest={_promise:undefined,_resolve:a,_reject:n,_reason:t,_wasAlreadyErroring:o}}));r._pendingAbortRequest._promise=i;if(!o){WritableStreamStartErroring(r,t)}return i}function WritableStreamClose(r){const t=r._state;if(t==="closed"||t==="errored"){return promiseRejectedWith(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`))}const a=newPromise(((t,a)=>{const n={_resolve:t,_reject:a};r._closeRequest=n}));const n=r._writer;if(n!==undefined&&r._backpressure&&t==="writable"){defaultWriterReadyPromiseResolve(n)}WritableStreamDefaultControllerClose(r._writableStreamController);return a}function WritableStreamAddWriteRequest(r){const t=newPromise(((t,a)=>{const n={_resolve:t,_reject:a};r._writeRequests.push(n)}));return t}function WritableStreamDealWithRejection(r,t){const a=r._state;if(a==="writable"){WritableStreamStartErroring(r,t);return}WritableStreamFinishErroring(r)}function WritableStreamStartErroring(r,t){const a=r._writableStreamController;r._state="erroring";r._storedError=t;const n=r._writer;if(n!==undefined){WritableStreamDefaultWriterEnsureReadyPromiseRejected(n,t)}if(!WritableStreamHasOperationMarkedInFlight(r)&&a._started){WritableStreamFinishErroring(r)}}function WritableStreamFinishErroring(r){r._state="errored";r._writableStreamController[m]();const t=r._storedError;r._writeRequests.forEach((r=>{r._reject(t)}));r._writeRequests=new SimpleQueue;if(r._pendingAbortRequest===undefined){WritableStreamRejectCloseAndClosedPromiseIfNeeded(r);return}const a=r._pendingAbortRequest;r._pendingAbortRequest=undefined;if(a._wasAlreadyErroring){a._reject(t);WritableStreamRejectCloseAndClosedPromiseIfNeeded(r);return}const n=r._writableStreamController[c](a._reason);uponPromise(n,(()=>{a._resolve();WritableStreamRejectCloseAndClosedPromiseIfNeeded(r)}),(t=>{a._reject(t);WritableStreamRejectCloseAndClosedPromiseIfNeeded(r)}))}function WritableStreamFinishInFlightWrite(r){r._inFlightWriteRequest._resolve(undefined);r._inFlightWriteRequest=undefined}function WritableStreamFinishInFlightWriteWithError(r,t){r._inFlightWriteRequest._reject(t);r._inFlightWriteRequest=undefined;WritableStreamDealWithRejection(r,t)}function WritableStreamFinishInFlightClose(r){r._inFlightCloseRequest._resolve(undefined);r._inFlightCloseRequest=undefined;const t=r._state;if(t==="erroring"){r._storedError=undefined;if(r._pendingAbortRequest!==undefined){r._pendingAbortRequest._resolve();r._pendingAbortRequest=undefined}}r._state="closed";const a=r._writer;if(a!==undefined){defaultWriterClosedPromiseResolve(a)}}function WritableStreamFinishInFlightCloseWithError(r,t){r._inFlightCloseRequest._reject(t);r._inFlightCloseRequest=undefined;if(r._pendingAbortRequest!==undefined){r._pendingAbortRequest._reject(t);r._pendingAbortRequest=undefined}WritableStreamDealWithRejection(r,t)}function WritableStreamCloseQueuedOrInFlight(r){if(r._closeRequest===undefined&&r._inFlightCloseRequest===undefined){return false}return true}function WritableStreamHasOperationMarkedInFlight(r){if(r._inFlightWriteRequest===undefined&&r._inFlightCloseRequest===undefined){return false}return true}function WritableStreamMarkCloseRequestInFlight(r){r._inFlightCloseRequest=r._closeRequest;r._closeRequest=undefined}function WritableStreamMarkFirstWriteRequestInFlight(r){r._inFlightWriteRequest=r._writeRequests.shift()}function WritableStreamRejectCloseAndClosedPromiseIfNeeded(r){if(r._closeRequest!==undefined){r._closeRequest._reject(r._storedError);r._closeRequest=undefined}const t=r._writer;if(t!==undefined){defaultWriterClosedPromiseReject(t,r._storedError)}}function WritableStreamUpdateBackpressure(r,t){const a=r._writer;if(a!==undefined&&t!==r._backpressure){if(t){defaultWriterReadyPromiseReset(a)}else{defaultWriterReadyPromiseResolve(a)}}r._backpressure=t}class WritableStreamDefaultWriter{constructor(r){assertRequiredArgument(r,1,"WritableStreamDefaultWriter");assertWritableStream(r,"First parameter");if(IsWritableStreamLocked(r)){throw new TypeError("This stream has already been locked for exclusive writing by another writer")}this._ownerWritableStream=r;r._writer=this;const t=r._state;if(t==="writable"){if(!WritableStreamCloseQueuedOrInFlight(r)&&r._backpressure){defaultWriterReadyPromiseInitialize(this)}else{defaultWriterReadyPromiseInitializeAsResolved(this)}defaultWriterClosedPromiseInitialize(this)}else if(t==="erroring"){defaultWriterReadyPromiseInitializeAsRejected(this,r._storedError);defaultWriterClosedPromiseInitialize(this)}else if(t==="closed"){defaultWriterReadyPromiseInitializeAsResolved(this);defaultWriterClosedPromiseInitializeAsResolved(this)}else{const t=r._storedError;defaultWriterReadyPromiseInitializeAsRejected(this,t);defaultWriterClosedPromiseInitializeAsRejected(this,t)}}get closed(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("closed"))}return this._closedPromise}get desiredSize(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("desiredSize")}if(this._ownerWritableStream===undefined){throw defaultWriterLockException("desiredSize")}return WritableStreamDefaultWriterGetDesiredSize(this)}get ready(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("ready"))}return this._readyPromise}abort(r=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("abort"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("abort"))}return WritableStreamDefaultWriterAbort(this,r)}close(){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("close"))}const r=this._ownerWritableStream;if(r===undefined){return promiseRejectedWith(defaultWriterLockException("close"))}if(WritableStreamCloseQueuedOrInFlight(r)){return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"))}return WritableStreamDefaultWriterClose(this)}releaseLock(){if(!IsWritableStreamDefaultWriter(this)){throw defaultWriterBrandCheckException("releaseLock")}const r=this._ownerWritableStream;if(r===undefined){return}WritableStreamDefaultWriterRelease(this)}write(r=undefined){if(!IsWritableStreamDefaultWriter(this)){return promiseRejectedWith(defaultWriterBrandCheckException("write"))}if(this._ownerWritableStream===undefined){return promiseRejectedWith(defaultWriterLockException("write to"))}return WritableStreamDefaultWriterWrite(this,r)}}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:true},close:{enumerable:true},releaseLock:{enumerable:true},write:{enumerable:true},closed:{enumerable:true},desiredSize:{enumerable:true},ready:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultWriter.prototype,t.toStringTag,{value:"WritableStreamDefaultWriter",configurable:true})}function IsWritableStreamDefaultWriter(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_ownerWritableStream")){return false}return r instanceof WritableStreamDefaultWriter}function WritableStreamDefaultWriterAbort(r,t){const a=r._ownerWritableStream;return WritableStreamAbort(a,t)}function WritableStreamDefaultWriterClose(r){const t=r._ownerWritableStream;return WritableStreamClose(t)}function WritableStreamDefaultWriterCloseWithErrorPropagation(r){const t=r._ownerWritableStream;const a=t._state;if(WritableStreamCloseQueuedOrInFlight(t)||a==="closed"){return promiseResolvedWith(undefined)}if(a==="errored"){return promiseRejectedWith(t._storedError)}return WritableStreamDefaultWriterClose(r)}function WritableStreamDefaultWriterEnsureClosedPromiseRejected(r,t){if(r._closedPromiseState==="pending"){defaultWriterClosedPromiseReject(r,t)}else{defaultWriterClosedPromiseResetToRejected(r,t)}}function WritableStreamDefaultWriterEnsureReadyPromiseRejected(r,t){if(r._readyPromiseState==="pending"){defaultWriterReadyPromiseReject(r,t)}else{defaultWriterReadyPromiseResetToRejected(r,t)}}function WritableStreamDefaultWriterGetDesiredSize(r){const t=r._ownerWritableStream;const a=t._state;if(a==="errored"||a==="erroring"){return null}if(a==="closed"){return 0}return WritableStreamDefaultControllerGetDesiredSize(t._writableStreamController)}function WritableStreamDefaultWriterRelease(r){const t=r._ownerWritableStream;const a=new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);WritableStreamDefaultWriterEnsureReadyPromiseRejected(r,a);WritableStreamDefaultWriterEnsureClosedPromiseRejected(r,a);t._writer=undefined;r._ownerWritableStream=undefined}function WritableStreamDefaultWriterWrite(r,t){const a=r._ownerWritableStream;const n=a._writableStreamController;const o=WritableStreamDefaultControllerGetChunkSize(n,t);if(a!==r._ownerWritableStream){return promiseRejectedWith(defaultWriterLockException("write to"))}const i=a._state;if(i==="errored"){return promiseRejectedWith(a._storedError)}if(WritableStreamCloseQueuedOrInFlight(a)||i==="closed"){return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"))}if(i==="erroring"){return promiseRejectedWith(a._storedError)}const l=WritableStreamAddWriteRequest(a);WritableStreamDefaultControllerWrite(n,t,o);return l}const C={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("abortReason")}return this._abortReason}get signal(){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("signal")}if(this._abortController===undefined){throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported")}return this._abortController.signal}error(r=undefined){if(!IsWritableStreamDefaultController(this)){throw defaultControllerBrandCheckException$2("error")}const t=this._controlledWritableStream._state;if(t!=="writable"){return}WritableStreamDefaultControllerError(this,r)}[c](r){const t=this._abortAlgorithm(r);WritableStreamDefaultControllerClearAlgorithms(this);return t}[m](){ResetQueue(this)}}Object.defineProperties(WritableStreamDefaultController.prototype,{abortReason:{enumerable:true},signal:{enumerable:true},error:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(WritableStreamDefaultController.prototype,t.toStringTag,{value:"WritableStreamDefaultController",configurable:true})}function IsWritableStreamDefaultController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledWritableStream")){return false}return r instanceof WritableStreamDefaultController}function SetUpWritableStreamDefaultController(r,t,a,n,o,i,l,s){t._controlledWritableStream=r;r._writableStreamController=t;t._queue=undefined;t._queueTotalSize=undefined;ResetQueue(t);t._abortReason=undefined;t._abortController=createAbortController();t._started=false;t._strategySizeAlgorithm=s;t._strategyHWM=l;t._writeAlgorithm=n;t._closeAlgorithm=o;t._abortAlgorithm=i;const u=WritableStreamDefaultControllerGetBackpressure(t);WritableStreamUpdateBackpressure(r,u);const d=a();const c=promiseResolvedWith(d);uponPromise(c,(()=>{t._started=true;WritableStreamDefaultControllerAdvanceQueueIfNeeded(t)}),(a=>{t._started=true;WritableStreamDealWithRejection(r,a)}))}function SetUpWritableStreamDefaultControllerFromUnderlyingSink(r,t,a,n){const o=Object.create(WritableStreamDefaultController.prototype);let startAlgorithm=()=>undefined;let writeAlgorithm=()=>promiseResolvedWith(undefined);let closeAlgorithm=()=>promiseResolvedWith(undefined);let abortAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(o)}if(t.write!==undefined){writeAlgorithm=r=>t.write(r,o)}if(t.close!==undefined){closeAlgorithm=()=>t.close()}if(t.abort!==undefined){abortAlgorithm=r=>t.abort(r)}SetUpWritableStreamDefaultController(r,o,startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,a,n)}function WritableStreamDefaultControllerClearAlgorithms(r){r._writeAlgorithm=undefined;r._closeAlgorithm=undefined;r._abortAlgorithm=undefined;r._strategySizeAlgorithm=undefined}function WritableStreamDefaultControllerClose(r){EnqueueValueWithSize(r,C,0);WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}function WritableStreamDefaultControllerGetChunkSize(r,t){try{return r._strategySizeAlgorithm(t)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(r,t);return 1}}function WritableStreamDefaultControllerGetDesiredSize(r){return r._strategyHWM-r._queueTotalSize}function WritableStreamDefaultControllerWrite(r,t,a){try{EnqueueValueWithSize(r,t,a)}catch(t){WritableStreamDefaultControllerErrorIfNeeded(r,t);return}const n=r._controlledWritableStream;if(!WritableStreamCloseQueuedOrInFlight(n)&&n._state==="writable"){const t=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(n,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}function WritableStreamDefaultControllerAdvanceQueueIfNeeded(r){const t=r._controlledWritableStream;if(!r._started){return}if(t._inFlightWriteRequest!==undefined){return}const a=t._state;if(a==="erroring"){WritableStreamFinishErroring(t);return}if(r._queue.length===0){return}const n=PeekQueueValue(r);if(n===C){WritableStreamDefaultControllerProcessClose(r)}else{WritableStreamDefaultControllerProcessWrite(r,n)}}function WritableStreamDefaultControllerErrorIfNeeded(r,t){if(r._controlledWritableStream._state==="writable"){WritableStreamDefaultControllerError(r,t)}}function WritableStreamDefaultControllerProcessClose(r){const t=r._controlledWritableStream;WritableStreamMarkCloseRequestInFlight(t);DequeueValue(r);const a=r._closeAlgorithm();WritableStreamDefaultControllerClearAlgorithms(r);uponPromise(a,(()=>{WritableStreamFinishInFlightClose(t)}),(r=>{WritableStreamFinishInFlightCloseWithError(t,r)}))}function WritableStreamDefaultControllerProcessWrite(r,t){const a=r._controlledWritableStream;WritableStreamMarkFirstWriteRequestInFlight(a);const n=r._writeAlgorithm(t);uponPromise(n,(()=>{WritableStreamFinishInFlightWrite(a);const t=a._state;DequeueValue(r);if(!WritableStreamCloseQueuedOrInFlight(a)&&t==="writable"){const t=WritableStreamDefaultControllerGetBackpressure(r);WritableStreamUpdateBackpressure(a,t)}WritableStreamDefaultControllerAdvanceQueueIfNeeded(r)}),(t=>{if(a._state==="writable"){WritableStreamDefaultControllerClearAlgorithms(r)}WritableStreamFinishInFlightWriteWithError(a,t)}))}function WritableStreamDefaultControllerGetBackpressure(r){const t=WritableStreamDefaultControllerGetDesiredSize(r);return t<=0}function WritableStreamDefaultControllerError(r,t){const a=r._controlledWritableStream;WritableStreamDefaultControllerClearAlgorithms(r);WritableStreamStartErroring(a,t)}function streamBrandCheckException$2(r){return new TypeError(`WritableStream.prototype.${r} can only be used on a WritableStream`)}function defaultControllerBrandCheckException$2(r){return new TypeError(`WritableStreamDefaultController.prototype.${r} can only be used on a WritableStreamDefaultController`)}function defaultWriterBrandCheckException(r){return new TypeError(`WritableStreamDefaultWriter.prototype.${r} can only be used on a WritableStreamDefaultWriter`)}function defaultWriterLockException(r){return new TypeError("Cannot "+r+" a stream using a released writer")}function defaultWriterClosedPromiseInitialize(r){r._closedPromise=newPromise(((t,a)=>{r._closedPromise_resolve=t;r._closedPromise_reject=a;r._closedPromiseState="pending"}))}function defaultWriterClosedPromiseInitializeAsRejected(r,t){defaultWriterClosedPromiseInitialize(r);defaultWriterClosedPromiseReject(r,t)}function defaultWriterClosedPromiseInitializeAsResolved(r){defaultWriterClosedPromiseInitialize(r);defaultWriterClosedPromiseResolve(r)}function defaultWriterClosedPromiseReject(r,t){if(r._closedPromise_reject===undefined){return}setPromiseIsHandledToTrue(r._closedPromise);r._closedPromise_reject(t);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined;r._closedPromiseState="rejected"}function defaultWriterClosedPromiseResetToRejected(r,t){defaultWriterClosedPromiseInitializeAsRejected(r,t)}function defaultWriterClosedPromiseResolve(r){if(r._closedPromise_resolve===undefined){return}r._closedPromise_resolve(undefined);r._closedPromise_resolve=undefined;r._closedPromise_reject=undefined;r._closedPromiseState="resolved"}function defaultWriterReadyPromiseInitialize(r){r._readyPromise=newPromise(((t,a)=>{r._readyPromise_resolve=t;r._readyPromise_reject=a}));r._readyPromiseState="pending"}function defaultWriterReadyPromiseInitializeAsRejected(r,t){defaultWriterReadyPromiseInitialize(r);defaultWriterReadyPromiseReject(r,t)}function defaultWriterReadyPromiseInitializeAsResolved(r){defaultWriterReadyPromiseInitialize(r);defaultWriterReadyPromiseResolve(r)}function defaultWriterReadyPromiseReject(r,t){if(r._readyPromise_reject===undefined){return}setPromiseIsHandledToTrue(r._readyPromise);r._readyPromise_reject(t);r._readyPromise_resolve=undefined;r._readyPromise_reject=undefined;r._readyPromiseState="rejected"}function defaultWriterReadyPromiseReset(r){defaultWriterReadyPromiseInitialize(r)}function defaultWriterReadyPromiseResetToRejected(r,t){defaultWriterReadyPromiseInitializeAsRejected(r,t)}function defaultWriterReadyPromiseResolve(r){if(r._readyPromise_resolve===undefined){return}r._readyPromise_resolve(undefined);r._readyPromise_resolve=undefined;r._readyPromise_reject=undefined;r._readyPromiseState="fulfilled"}const w=typeof DOMException!=="undefined"?DOMException:undefined;function isDOMExceptionConstructor(r){if(!(typeof r==="function"||typeof r==="object")){return false}try{new r;return true}catch(r){return false}}function createDOMExceptionPolyfill(){const r=function DOMException(r,t){this.message=r||"";this.name=t||"Error";if(Error.captureStackTrace){Error.captureStackTrace(this,this.constructor)}};r.prototype=Object.create(Error.prototype);Object.defineProperty(r.prototype,"constructor",{value:r,writable:true,configurable:true});return r}const W=isDOMExceptionConstructor(w)?w:createDOMExceptionPolyfill();function ReadableStreamPipeTo(r,t,a,n,o,i){const l=AcquireReadableStreamDefaultReader(r);const s=AcquireWritableStreamDefaultWriter(t);r._disturbed=true;let u=false;let d=promiseResolvedWith(undefined);return newPromise(((c,m)=>{let b;if(i!==undefined){b=()=>{const a=new W("Aborted","AbortError");const i=[];if(!n){i.push((()=>{if(t._state==="writable"){return WritableStreamAbort(t,a)}return promiseResolvedWith(undefined)}))}if(!o){i.push((()=>{if(r._state==="readable"){return ReadableStreamCancel(r,a)}return promiseResolvedWith(undefined)}))}shutdownWithAction((()=>Promise.all(i.map((r=>r())))),true,a)};if(i.aborted){b();return}i.addEventListener("abort",b)}function pipeLoop(){return newPromise(((r,t)=>{function next(a){if(a){r()}else{PerformPromiseThen(pipeStep(),next,t)}}next(false)}))}function pipeStep(){if(u){return promiseResolvedWith(true)}return PerformPromiseThen(s._readyPromise,(()=>newPromise(((r,t)=>{ReadableStreamDefaultReaderRead(l,{_chunkSteps:t=>{d=PerformPromiseThen(WritableStreamDefaultWriterWrite(s,t),undefined,noop);r(false)},_closeSteps:()=>r(true),_errorSteps:t})}))))}isOrBecomesErrored(r,l._closedPromise,(r=>{if(!n){shutdownWithAction((()=>WritableStreamAbort(t,r)),true,r)}else{shutdown(true,r)}}));isOrBecomesErrored(t,s._closedPromise,(t=>{if(!o){shutdownWithAction((()=>ReadableStreamCancel(r,t)),true,t)}else{shutdown(true,t)}}));isOrBecomesClosed(r,l._closedPromise,(()=>{if(!a){shutdownWithAction((()=>WritableStreamDefaultWriterCloseWithErrorPropagation(s)))}else{shutdown()}}));if(WritableStreamCloseQueuedOrInFlight(t)||t._state==="closed"){const t=new TypeError("the destination writable stream closed before all data could be piped to it");if(!o){shutdownWithAction((()=>ReadableStreamCancel(r,t)),true,t)}else{shutdown(true,t)}}setPromiseIsHandledToTrue(pipeLoop());function waitForWritesToFinish(){const r=d;return PerformPromiseThen(d,(()=>r!==d?waitForWritesToFinish():undefined))}function isOrBecomesErrored(r,t,a){if(r._state==="errored"){a(r._storedError)}else{uponRejection(t,a)}}function isOrBecomesClosed(r,t,a){if(r._state==="closed"){a()}else{uponFulfillment(t,a)}}function shutdownWithAction(r,a,n){if(u){return}u=true;if(t._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(t)){uponFulfillment(waitForWritesToFinish(),doTheRest)}else{doTheRest()}function doTheRest(){uponPromise(r(),(()=>finalize(a,n)),(r=>finalize(true,r)))}}function shutdown(r,a){if(u){return}u=true;if(t._state==="writable"&&!WritableStreamCloseQueuedOrInFlight(t)){uponFulfillment(waitForWritesToFinish(),(()=>finalize(r,a)))}else{finalize(r,a)}}function finalize(r,t){WritableStreamDefaultWriterRelease(s);ReadableStreamReaderGenericRelease(l);if(i!==undefined){i.removeEventListener("abort",b)}if(r){m(t)}else{c(undefined)}}}))}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("desiredSize")}return ReadableStreamDefaultControllerGetDesiredSize(this)}close(){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("close")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits close")}ReadableStreamDefaultControllerClose(this)}enqueue(r=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("enqueue")}if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)){throw new TypeError("The stream is not in a state that permits enqueue")}return ReadableStreamDefaultControllerEnqueue(this,r)}error(r=undefined){if(!IsReadableStreamDefaultController(this)){throw defaultControllerBrandCheckException$1("error")}ReadableStreamDefaultControllerError(this,r)}[b](r){ResetQueue(this);const t=this._cancelAlgorithm(r);ReadableStreamDefaultControllerClearAlgorithms(this);return t}[h](r){const t=this._controlledReadableStream;if(this._queue.length>0){const a=DequeueValue(this);if(this._closeRequested&&this._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(this);ReadableStreamClose(t)}else{ReadableStreamDefaultControllerCallPullIfNeeded(this)}r._chunkSteps(a)}else{ReadableStreamAddReadRequest(t,r);ReadableStreamDefaultControllerCallPullIfNeeded(this)}}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:true},enqueue:{enumerable:true},error:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStreamDefaultController.prototype,t.toStringTag,{value:"ReadableStreamDefaultController",configurable:true})}function IsReadableStreamDefaultController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledReadableStream")){return false}return r instanceof ReadableStreamDefaultController}function ReadableStreamDefaultControllerCallPullIfNeeded(r){const t=ReadableStreamDefaultControllerShouldCallPull(r);if(!t){return}if(r._pulling){r._pullAgain=true;return}r._pulling=true;const a=r._pullAlgorithm();uponPromise(a,(()=>{r._pulling=false;if(r._pullAgain){r._pullAgain=false;ReadableStreamDefaultControllerCallPullIfNeeded(r)}}),(t=>{ReadableStreamDefaultControllerError(r,t)}))}function ReadableStreamDefaultControllerShouldCallPull(r){const t=r._controlledReadableStream;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)){return false}if(!r._started){return false}if(IsReadableStreamLocked(t)&&ReadableStreamGetNumReadRequests(t)>0){return true}const a=ReadableStreamDefaultControllerGetDesiredSize(r);if(a>0){return true}return false}function ReadableStreamDefaultControllerClearAlgorithms(r){r._pullAlgorithm=undefined;r._cancelAlgorithm=undefined;r._strategySizeAlgorithm=undefined}function ReadableStreamDefaultControllerClose(r){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)){return}const t=r._controlledReadableStream;r._closeRequested=true;if(r._queue.length===0){ReadableStreamDefaultControllerClearAlgorithms(r);ReadableStreamClose(t)}}function ReadableStreamDefaultControllerEnqueue(r,t){if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(r)){return}const a=r._controlledReadableStream;if(IsReadableStreamLocked(a)&&ReadableStreamGetNumReadRequests(a)>0){ReadableStreamFulfillReadRequest(a,t,false)}else{let a;try{a=r._strategySizeAlgorithm(t)}catch(t){ReadableStreamDefaultControllerError(r,t);throw t}try{EnqueueValueWithSize(r,t,a)}catch(t){ReadableStreamDefaultControllerError(r,t);throw t}}ReadableStreamDefaultControllerCallPullIfNeeded(r)}function ReadableStreamDefaultControllerError(r,t){const a=r._controlledReadableStream;if(a._state!=="readable"){return}ResetQueue(r);ReadableStreamDefaultControllerClearAlgorithms(r);ReadableStreamError(a,t)}function ReadableStreamDefaultControllerGetDesiredSize(r){const t=r._controlledReadableStream._state;if(t==="errored"){return null}if(t==="closed"){return 0}return r._strategyHWM-r._queueTotalSize}function ReadableStreamDefaultControllerHasBackpressure(r){if(ReadableStreamDefaultControllerShouldCallPull(r)){return false}return true}function ReadableStreamDefaultControllerCanCloseOrEnqueue(r){const t=r._controlledReadableStream._state;if(!r._closeRequested&&t==="readable"){return true}return false}function SetUpReadableStreamDefaultController(r,t,a,n,o,i,l){t._controlledReadableStream=r;t._queue=undefined;t._queueTotalSize=undefined;ResetQueue(t);t._started=false;t._closeRequested=false;t._pullAgain=false;t._pulling=false;t._strategySizeAlgorithm=l;t._strategyHWM=i;t._pullAlgorithm=n;t._cancelAlgorithm=o;r._readableStreamController=t;const s=a();uponPromise(promiseResolvedWith(s),(()=>{t._started=true;ReadableStreamDefaultControllerCallPullIfNeeded(t)}),(r=>{ReadableStreamDefaultControllerError(t,r)}))}function SetUpReadableStreamDefaultControllerFromUnderlyingSource(r,t,a,n){const o=Object.create(ReadableStreamDefaultController.prototype);let startAlgorithm=()=>undefined;let pullAlgorithm=()=>promiseResolvedWith(undefined);let cancelAlgorithm=()=>promiseResolvedWith(undefined);if(t.start!==undefined){startAlgorithm=()=>t.start(o)}if(t.pull!==undefined){pullAlgorithm=()=>t.pull(o)}if(t.cancel!==undefined){cancelAlgorithm=r=>t.cancel(r)}SetUpReadableStreamDefaultController(r,o,startAlgorithm,pullAlgorithm,cancelAlgorithm,a,n)}function defaultControllerBrandCheckException$1(r){return new TypeError(`ReadableStreamDefaultController.prototype.${r} can only be used on a ReadableStreamDefaultController`)}function ReadableStreamTee(r,t){if(IsReadableByteStreamController(r._readableStreamController)){return ReadableByteStreamTee(r)}return ReadableStreamDefaultTee(r)}function ReadableStreamDefaultTee(r,t){const a=AcquireReadableStreamDefaultReader(r);let n=false;let o=false;let i=false;let l=false;let s;let d;let c;let m;let b;const h=newPromise((r=>{b=r}));function pullAlgorithm(){if(n){o=true;return promiseResolvedWith(undefined)}n=true;const r={_chunkSteps:r=>{u((()=>{o=false;const t=r;const a=r;if(!i){ReadableStreamDefaultControllerEnqueue(c._readableStreamController,t)}if(!l){ReadableStreamDefaultControllerEnqueue(m._readableStreamController,a)}n=false;if(o){pullAlgorithm()}}))},_closeSteps:()=>{n=false;if(!i){ReadableStreamDefaultControllerClose(c._readableStreamController)}if(!l){ReadableStreamDefaultControllerClose(m._readableStreamController)}if(!i||!l){b(undefined)}},_errorSteps:()=>{n=false}};ReadableStreamDefaultReaderRead(a,r);return promiseResolvedWith(undefined)}function cancel1Algorithm(t){i=true;s=t;if(l){const t=CreateArrayFromList([s,d]);const a=ReadableStreamCancel(r,t);b(a)}return h}function cancel2Algorithm(t){l=true;d=t;if(i){const t=CreateArrayFromList([s,d]);const a=ReadableStreamCancel(r,t);b(a)}return h}function startAlgorithm(){}c=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel1Algorithm);m=CreateReadableStream(startAlgorithm,pullAlgorithm,cancel2Algorithm);uponRejection(a._closedPromise,(r=>{ReadableStreamDefaultControllerError(c._readableStreamController,r);ReadableStreamDefaultControllerError(m._readableStreamController,r);if(!i||!l){b(undefined)}}));return[c,m]}function ReadableByteStreamTee(r){let t=AcquireReadableStreamDefaultReader(r);let a=false;let n=false;let o=false;let i=false;let l=false;let s;let d;let c;let m;let b;const h=newPromise((r=>{b=r}));function forwardReaderError(r){uponRejection(r._closedPromise,(a=>{if(r!==t){return}ReadableByteStreamControllerError(c._readableStreamController,a);ReadableByteStreamControllerError(m._readableStreamController,a);if(!i||!l){b(undefined)}}))}function pullWithDefaultReader(){if(IsReadableStreamBYOBReader(t)){ReadableStreamReaderGenericRelease(t);t=AcquireReadableStreamDefaultReader(r);forwardReaderError(t)}const s={_chunkSteps:t=>{u((()=>{n=false;o=false;const s=t;let u=t;if(!i&&!l){try{u=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(c._readableStreamController,t);ReadableByteStreamControllerError(m._readableStreamController,t);b(ReadableStreamCancel(r,t));return}}if(!i){ReadableByteStreamControllerEnqueue(c._readableStreamController,s)}if(!l){ReadableByteStreamControllerEnqueue(m._readableStreamController,u)}a=false;if(n){pull1Algorithm()}else if(o){pull2Algorithm()}}))},_closeSteps:()=>{a=false;if(!i){ReadableByteStreamControllerClose(c._readableStreamController)}if(!l){ReadableByteStreamControllerClose(m._readableStreamController)}if(c._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(c._readableStreamController,0)}if(m._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(m._readableStreamController,0)}if(!i||!l){b(undefined)}},_errorSteps:()=>{a=false}};ReadableStreamDefaultReaderRead(t,s)}function pullWithBYOBReader(s,d){if(IsReadableStreamDefaultReader(t)){ReadableStreamReaderGenericRelease(t);t=AcquireReadableStreamBYOBReader(r);forwardReaderError(t)}const h=d?m:c;const p=d?c:m;const S={_chunkSteps:t=>{u((()=>{n=false;o=false;const s=d?l:i;const u=d?i:l;if(!u){let a;try{a=CloneAsUint8Array(t)}catch(t){ReadableByteStreamControllerError(h._readableStreamController,t);ReadableByteStreamControllerError(p._readableStreamController,t);b(ReadableStreamCancel(r,t));return}if(!s){ReadableByteStreamControllerRespondWithNewView(h._readableStreamController,t)}ReadableByteStreamControllerEnqueue(p._readableStreamController,a)}else if(!s){ReadableByteStreamControllerRespondWithNewView(h._readableStreamController,t)}a=false;if(n){pull1Algorithm()}else if(o){pull2Algorithm()}}))},_closeSteps:r=>{a=false;const t=d?l:i;const n=d?i:l;if(!t){ReadableByteStreamControllerClose(h._readableStreamController)}if(!n){ReadableByteStreamControllerClose(p._readableStreamController)}if(r!==undefined){if(!t){ReadableByteStreamControllerRespondWithNewView(h._readableStreamController,r)}if(!n&&p._readableStreamController._pendingPullIntos.length>0){ReadableByteStreamControllerRespond(p._readableStreamController,0)}}if(!t||!n){b(undefined)}},_errorSteps:()=>{a=false}};ReadableStreamBYOBReaderRead(t,s,S)}function pull1Algorithm(){if(a){n=true;return promiseResolvedWith(undefined)}a=true;const r=ReadableByteStreamControllerGetBYOBRequest(c._readableStreamController);if(r===null){pullWithDefaultReader()}else{pullWithBYOBReader(r._view,false)}return promiseResolvedWith(undefined)}function pull2Algorithm(){if(a){o=true;return promiseResolvedWith(undefined)}a=true;const r=ReadableByteStreamControllerGetBYOBRequest(m._readableStreamController);if(r===null){pullWithDefaultReader()}else{pullWithBYOBReader(r._view,true)}return promiseResolvedWith(undefined)}function cancel1Algorithm(t){i=true;s=t;if(l){const t=CreateArrayFromList([s,d]);const a=ReadableStreamCancel(r,t);b(a)}return h}function cancel2Algorithm(t){l=true;d=t;if(i){const t=CreateArrayFromList([s,d]);const a=ReadableStreamCancel(r,t);b(a)}return h}function startAlgorithm(){return}c=CreateReadableByteStream(startAlgorithm,pull1Algorithm,cancel1Algorithm);m=CreateReadableByteStream(startAlgorithm,pull2Algorithm,cancel2Algorithm);forwardReaderError(t);return[c,m]}function convertUnderlyingDefaultOrByteSource(r,t){assertDictionary(r,t);const a=r;const n=a===null||a===void 0?void 0:a.autoAllocateChunkSize;const o=a===null||a===void 0?void 0:a.cancel;const i=a===null||a===void 0?void 0:a.pull;const l=a===null||a===void 0?void 0:a.start;const s=a===null||a===void 0?void 0:a.type;return{autoAllocateChunkSize:n===undefined?undefined:convertUnsignedLongLongWithEnforceRange(n,`${t} has member 'autoAllocateChunkSize' that`),cancel:o===undefined?undefined:convertUnderlyingSourceCancelCallback(o,a,`${t} has member 'cancel' that`),pull:i===undefined?undefined:convertUnderlyingSourcePullCallback(i,a,`${t} has member 'pull' that`),start:l===undefined?undefined:convertUnderlyingSourceStartCallback(l,a,`${t} has member 'start' that`),type:s===undefined?undefined:convertReadableStreamType(s,`${t} has member 'type' that`)}}function convertUnderlyingSourceCancelCallback(r,t,a){assertFunction(r,a);return a=>promiseCall(r,t,[a])}function convertUnderlyingSourcePullCallback(r,t,a){assertFunction(r,a);return a=>promiseCall(r,t,[a])}function convertUnderlyingSourceStartCallback(r,t,a){assertFunction(r,a);return a=>reflectCall(r,t,[a])}function convertReadableStreamType(r,t){r=`${r}`;if(r!=="bytes"){throw new TypeError(`${t} '${r}' is not a valid enumeration value for ReadableStreamType`)}return r}function convertReaderOptions(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.mode;return{mode:a===undefined?undefined:convertReadableStreamReaderMode(a,`${t} has member 'mode' that`)}}function convertReadableStreamReaderMode(r,t){r=`${r}`;if(r!=="byob"){throw new TypeError(`${t} '${r}' is not a valid enumeration value for ReadableStreamReaderMode`)}return r}function convertIteratorOptions(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.preventCancel;return{preventCancel:Boolean(a)}}function convertPipeOptions(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.preventAbort;const n=r===null||r===void 0?void 0:r.preventCancel;const o=r===null||r===void 0?void 0:r.preventClose;const i=r===null||r===void 0?void 0:r.signal;if(i!==undefined){assertAbortSignal(i,`${t} has member 'signal' that`)}return{preventAbort:Boolean(a),preventCancel:Boolean(n),preventClose:Boolean(o),signal:i}}function assertAbortSignal(r,t){if(!isAbortSignal(r)){throw new TypeError(`${t} is not an AbortSignal.`)}}function convertReadableWritablePair(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.readable;assertRequiredField(a,"readable","ReadableWritablePair");assertReadableStream(a,`${t} has member 'readable' that`);const n=r===null||r===void 0?void 0:r.writable;assertRequiredField(n,"writable","ReadableWritablePair");assertWritableStream(n,`${t} has member 'writable' that`);return{readable:a,writable:n}}class ReadableStream{constructor(r={},t={}){if(r===undefined){r=null}else{assertObject(r,"First parameter")}const a=convertQueuingStrategy(t,"Second parameter");const n=convertUnderlyingDefaultOrByteSource(r,"First parameter");InitializeReadableStream(this);if(n.type==="bytes"){if(a.size!==undefined){throw new RangeError("The strategy for a byte stream cannot have a size function")}const r=ExtractHighWaterMark(a,0);SetUpReadableByteStreamControllerFromUnderlyingSource(this,n,r)}else{const r=ExtractSizeAlgorithm(a);const t=ExtractHighWaterMark(a,1);SetUpReadableStreamDefaultControllerFromUnderlyingSource(this,n,t,r)}}get locked(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("locked")}return IsReadableStreamLocked(this)}cancel(r=undefined){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("cancel"))}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"))}return ReadableStreamCancel(this,r)}getReader(r=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("getReader")}const t=convertReaderOptions(r,"First parameter");if(t.mode===undefined){return AcquireReadableStreamDefaultReader(this)}return AcquireReadableStreamBYOBReader(this)}pipeThrough(r,t={}){if(!IsReadableStream(this)){throw streamBrandCheckException$1("pipeThrough")}assertRequiredArgument(r,1,"pipeThrough");const a=convertReadableWritablePair(r,"First parameter");const n=convertPipeOptions(t,"Second parameter");if(IsReadableStreamLocked(this)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream")}if(IsWritableStreamLocked(a.writable)){throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream")}const o=ReadableStreamPipeTo(this,a.writable,n.preventClose,n.preventAbort,n.preventCancel,n.signal);setPromiseIsHandledToTrue(o);return a.readable}pipeTo(r,t={}){if(!IsReadableStream(this)){return promiseRejectedWith(streamBrandCheckException$1("pipeTo"))}if(r===undefined){return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`)}if(!IsWritableStream(r)){return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`))}let a;try{a=convertPipeOptions(t,"Second parameter")}catch(r){return promiseRejectedWith(r)}if(IsReadableStreamLocked(this)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"))}if(IsWritableStreamLocked(r)){return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"))}return ReadableStreamPipeTo(this,r,a.preventClose,a.preventAbort,a.preventCancel,a.signal)}tee(){if(!IsReadableStream(this)){throw streamBrandCheckException$1("tee")}const r=ReadableStreamTee(this);return CreateArrayFromList(r)}values(r=undefined){if(!IsReadableStream(this)){throw streamBrandCheckException$1("values")}const t=convertIteratorOptions(r,"First parameter");return AcquireReadableStreamAsyncIterator(this,t.preventCancel)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:true},getReader:{enumerable:true},pipeThrough:{enumerable:true},pipeTo:{enumerable:true},tee:{enumerable:true},values:{enumerable:true},locked:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ReadableStream.prototype,t.toStringTag,{value:"ReadableStream",configurable:true})}if(typeof t.asyncIterator==="symbol"){Object.defineProperty(ReadableStream.prototype,t.asyncIterator,{value:ReadableStream.prototype.values,writable:true,configurable:true})}function CreateReadableStream(r,t,a,n=1,o=(()=>1)){const i=Object.create(ReadableStream.prototype);InitializeReadableStream(i);const l=Object.create(ReadableStreamDefaultController.prototype);SetUpReadableStreamDefaultController(i,l,r,t,a,n,o);return i}function CreateReadableByteStream(r,t,a){const n=Object.create(ReadableStream.prototype);InitializeReadableStream(n);const o=Object.create(ReadableByteStreamController.prototype);SetUpReadableByteStreamController(n,o,r,t,a,0,undefined);return n}function InitializeReadableStream(r){r._state="readable";r._reader=undefined;r._storedError=undefined;r._disturbed=false}function IsReadableStream(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_readableStreamController")){return false}return r instanceof ReadableStream}function IsReadableStreamLocked(r){if(r._reader===undefined){return false}return true}function ReadableStreamCancel(r,t){r._disturbed=true;if(r._state==="closed"){return promiseResolvedWith(undefined)}if(r._state==="errored"){return promiseRejectedWith(r._storedError)}ReadableStreamClose(r);const a=r._reader;if(a!==undefined&&IsReadableStreamBYOBReader(a)){a._readIntoRequests.forEach((r=>{r._closeSteps(undefined)}));a._readIntoRequests=new SimpleQueue}const n=r._readableStreamController[b](t);return transformPromiseWith(n,noop)}function ReadableStreamClose(r){r._state="closed";const t=r._reader;if(t===undefined){return}defaultReaderClosedPromiseResolve(t);if(IsReadableStreamDefaultReader(t)){t._readRequests.forEach((r=>{r._closeSteps()}));t._readRequests=new SimpleQueue}}function ReadableStreamError(r,t){r._state="errored";r._storedError=t;const a=r._reader;if(a===undefined){return}defaultReaderClosedPromiseReject(a,t);if(IsReadableStreamDefaultReader(a)){a._readRequests.forEach((r=>{r._errorSteps(t)}));a._readRequests=new SimpleQueue}else{a._readIntoRequests.forEach((r=>{r._errorSteps(t)}));a._readIntoRequests=new SimpleQueue}}function streamBrandCheckException$1(r){return new TypeError(`ReadableStream.prototype.${r} can only be used on a ReadableStream`)}function convertQueuingStrategyInit(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.highWaterMark;assertRequiredField(a,"highWaterMark","QueuingStrategyInit");return{highWaterMark:convertUnrestrictedDouble(a)}}const byteLengthSizeFunction=r=>r.byteLength;try{Object.defineProperty(byteLengthSizeFunction,"name",{value:"size",configurable:true})}catch(r){}class ByteLengthQueuingStrategy{constructor(r){assertRequiredArgument(r,1,"ByteLengthQueuingStrategy");r=convertQueuingStrategyInit(r,"First parameter");this._byteLengthQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("highWaterMark")}return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!IsByteLengthQueuingStrategy(this)){throw byteLengthBrandCheckException("size")}return byteLengthSizeFunction}}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(ByteLengthQueuingStrategy.prototype,t.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:true})}function byteLengthBrandCheckException(r){return new TypeError(`ByteLengthQueuingStrategy.prototype.${r} can only be used on a ByteLengthQueuingStrategy`)}function IsByteLengthQueuingStrategy(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_byteLengthQueuingStrategyHighWaterMark")){return false}return r instanceof ByteLengthQueuingStrategy}const countSizeFunction=()=>1;try{Object.defineProperty(countSizeFunction,"name",{value:"size",configurable:true})}catch(r){}class CountQueuingStrategy{constructor(r){assertRequiredArgument(r,1,"CountQueuingStrategy");r=convertQueuingStrategyInit(r,"First parameter");this._countQueuingStrategyHighWaterMark=r.highWaterMark}get highWaterMark(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("highWaterMark")}return this._countQueuingStrategyHighWaterMark}get size(){if(!IsCountQueuingStrategy(this)){throw countBrandCheckException("size")}return countSizeFunction}}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:true},size:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(CountQueuingStrategy.prototype,t.toStringTag,{value:"CountQueuingStrategy",configurable:true})}function countBrandCheckException(r){return new TypeError(`CountQueuingStrategy.prototype.${r} can only be used on a CountQueuingStrategy`)}function IsCountQueuingStrategy(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_countQueuingStrategyHighWaterMark")){return false}return r instanceof CountQueuingStrategy}function convertTransformer(r,t){assertDictionary(r,t);const a=r===null||r===void 0?void 0:r.flush;const n=r===null||r===void 0?void 0:r.readableType;const o=r===null||r===void 0?void 0:r.start;const i=r===null||r===void 0?void 0:r.transform;const l=r===null||r===void 0?void 0:r.writableType;return{flush:a===undefined?undefined:convertTransformerFlushCallback(a,r,`${t} has member 'flush' that`),readableType:n,start:o===undefined?undefined:convertTransformerStartCallback(o,r,`${t} has member 'start' that`),transform:i===undefined?undefined:convertTransformerTransformCallback(i,r,`${t} has member 'transform' that`),writableType:l}}function convertTransformerFlushCallback(r,t,a){assertFunction(r,a);return a=>promiseCall(r,t,[a])}function convertTransformerStartCallback(r,t,a){assertFunction(r,a);return a=>reflectCall(r,t,[a])}function convertTransformerTransformCallback(r,t,a){assertFunction(r,a);return(a,n)=>promiseCall(r,t,[a,n])}class TransformStream{constructor(r={},t={},a={}){if(r===undefined){r=null}const n=convertQueuingStrategy(t,"Second parameter");const o=convertQueuingStrategy(a,"Third parameter");const i=convertTransformer(r,"First parameter");if(i.readableType!==undefined){throw new RangeError("Invalid readableType specified")}if(i.writableType!==undefined){throw new RangeError("Invalid writableType specified")}const l=ExtractHighWaterMark(o,0);const s=ExtractSizeAlgorithm(o);const u=ExtractHighWaterMark(n,1);const d=ExtractSizeAlgorithm(n);let c;const m=newPromise((r=>{c=r}));InitializeTransformStream(this,m,u,d,l,s);SetUpTransformStreamDefaultControllerFromTransformer(this,i);if(i.start!==undefined){c(i.start(this._transformStreamController))}else{c(undefined)}}get readable(){if(!IsTransformStream(this)){throw streamBrandCheckException("readable")}return this._readable}get writable(){if(!IsTransformStream(this)){throw streamBrandCheckException("writable")}return this._writable}}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:true},writable:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(TransformStream.prototype,t.toStringTag,{value:"TransformStream",configurable:true})}function InitializeTransformStream(r,t,a,n,o,i){function startAlgorithm(){return t}function writeAlgorithm(t){return TransformStreamDefaultSinkWriteAlgorithm(r,t)}function abortAlgorithm(t){return TransformStreamDefaultSinkAbortAlgorithm(r,t)}function closeAlgorithm(){return TransformStreamDefaultSinkCloseAlgorithm(r)}r._writable=CreateWritableStream(startAlgorithm,writeAlgorithm,closeAlgorithm,abortAlgorithm,a,n);function pullAlgorithm(){return TransformStreamDefaultSourcePullAlgorithm(r)}function cancelAlgorithm(t){TransformStreamErrorWritableAndUnblockWrite(r,t);return promiseResolvedWith(undefined)}r._readable=CreateReadableStream(startAlgorithm,pullAlgorithm,cancelAlgorithm,o,i);r._backpressure=undefined;r._backpressureChangePromise=undefined;r._backpressureChangePromise_resolve=undefined;TransformStreamSetBackpressure(r,true);r._transformStreamController=undefined}function IsTransformStream(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_transformStreamController")){return false}return r instanceof TransformStream}function TransformStreamError(r,t){ReadableStreamDefaultControllerError(r._readable._readableStreamController,t);TransformStreamErrorWritableAndUnblockWrite(r,t)}function TransformStreamErrorWritableAndUnblockWrite(r,t){TransformStreamDefaultControllerClearAlgorithms(r._transformStreamController);WritableStreamDefaultControllerErrorIfNeeded(r._writable._writableStreamController,t);if(r._backpressure){TransformStreamSetBackpressure(r,false)}}function TransformStreamSetBackpressure(r,t){if(r._backpressureChangePromise!==undefined){r._backpressureChangePromise_resolve()}r._backpressureChangePromise=newPromise((t=>{r._backpressureChangePromise_resolve=t}));r._backpressure=t}class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("desiredSize")}const r=this._controlledTransformStream._readable._readableStreamController;return ReadableStreamDefaultControllerGetDesiredSize(r)}enqueue(r=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("enqueue")}TransformStreamDefaultControllerEnqueue(this,r)}error(r=undefined){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("error")}TransformStreamDefaultControllerError(this,r)}terminate(){if(!IsTransformStreamDefaultController(this)){throw defaultControllerBrandCheckException("terminate")}TransformStreamDefaultControllerTerminate(this)}}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:true},error:{enumerable:true},terminate:{enumerable:true},desiredSize:{enumerable:true}});if(typeof t.toStringTag==="symbol"){Object.defineProperty(TransformStreamDefaultController.prototype,t.toStringTag,{value:"TransformStreamDefaultController",configurable:true})}function IsTransformStreamDefaultController(r){if(!typeIsObject(r)){return false}if(!Object.prototype.hasOwnProperty.call(r,"_controlledTransformStream")){return false}return r instanceof TransformStreamDefaultController}function SetUpTransformStreamDefaultController(r,t,a,n){t._controlledTransformStream=r;r._transformStreamController=t;t._transformAlgorithm=a;t._flushAlgorithm=n}function SetUpTransformStreamDefaultControllerFromTransformer(r,t){const a=Object.create(TransformStreamDefaultController.prototype);let transformAlgorithm=r=>{try{TransformStreamDefaultControllerEnqueue(a,r);return promiseResolvedWith(undefined)}catch(r){return promiseRejectedWith(r)}};let flushAlgorithm=()=>promiseResolvedWith(undefined);if(t.transform!==undefined){transformAlgorithm=r=>t.transform(r,a)}if(t.flush!==undefined){flushAlgorithm=()=>t.flush(a)}SetUpTransformStreamDefaultController(r,a,transformAlgorithm,flushAlgorithm)}function TransformStreamDefaultControllerClearAlgorithms(r){r._transformAlgorithm=undefined;r._flushAlgorithm=undefined}function TransformStreamDefaultControllerEnqueue(r,t){const a=r._controlledTransformStream;const n=a._readable._readableStreamController;if(!ReadableStreamDefaultControllerCanCloseOrEnqueue(n)){throw new TypeError("Readable side is not in a state that permits enqueue")}try{ReadableStreamDefaultControllerEnqueue(n,t)}catch(r){TransformStreamErrorWritableAndUnblockWrite(a,r);throw a._readable._storedError}const o=ReadableStreamDefaultControllerHasBackpressure(n);if(o!==a._backpressure){TransformStreamSetBackpressure(a,true)}}function TransformStreamDefaultControllerError(r,t){TransformStreamError(r._controlledTransformStream,t)}function TransformStreamDefaultControllerPerformTransform(r,t){const a=r._transformAlgorithm(t);return transformPromiseWith(a,undefined,(t=>{TransformStreamError(r._controlledTransformStream,t);throw t}))}function TransformStreamDefaultControllerTerminate(r){const t=r._controlledTransformStream;const a=t._readable._readableStreamController;ReadableStreamDefaultControllerClose(a);const n=new TypeError("TransformStream terminated");TransformStreamErrorWritableAndUnblockWrite(t,n)}function TransformStreamDefaultSinkWriteAlgorithm(r,t){const a=r._transformStreamController;if(r._backpressure){const n=r._backpressureChangePromise;return transformPromiseWith(n,(()=>{const n=r._writable;const o=n._state;if(o==="erroring"){throw n._storedError}return TransformStreamDefaultControllerPerformTransform(a,t)}))}return TransformStreamDefaultControllerPerformTransform(a,t)}function TransformStreamDefaultSinkAbortAlgorithm(r,t){TransformStreamError(r,t);return promiseResolvedWith(undefined)}function TransformStreamDefaultSinkCloseAlgorithm(r){const t=r._readable;const a=r._transformStreamController;const n=a._flushAlgorithm();TransformStreamDefaultControllerClearAlgorithms(a);return transformPromiseWith(n,(()=>{if(t._state==="errored"){throw t._storedError}ReadableStreamDefaultControllerClose(t._readableStreamController)}),(a=>{TransformStreamError(r,a);throw t._storedError}))}function TransformStreamDefaultSourcePullAlgorithm(r){TransformStreamSetBackpressure(r,false);return r._backpressureChangePromise}function defaultControllerBrandCheckException(r){return new TypeError(`TransformStreamDefaultController.prototype.${r} can only be used on a TransformStreamDefaultController`)}function streamBrandCheckException(r){return new TypeError(`TransformStream.prototype.${r} can only be used on a TransformStream`)}r.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy;r.CountQueuingStrategy=CountQueuingStrategy;r.ReadableByteStreamController=ReadableByteStreamController;r.ReadableStream=ReadableStream;r.ReadableStreamBYOBReader=ReadableStreamBYOBReader;r.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest;r.ReadableStreamDefaultController=ReadableStreamDefaultController;r.ReadableStreamDefaultReader=ReadableStreamDefaultReader;r.TransformStream=TransformStream;r.TransformStreamDefaultController=TransformStreamDefaultController;r.WritableStream=WritableStream;r.WritableStreamDefaultController=WritableStreamDefaultController;r.WritableStreamDefaultWriter=WritableStreamDefaultWriter;Object.defineProperty(r,"__esModule",{value:true})}))},300:t=>{t.exports=r(import.meta.url)("buffer")},742:t=>{t.exports=r(import.meta.url)("node:process")},477:t=>{t.exports=r(import.meta.url)("node:stream/web")},267:t=>{t.exports=r(import.meta.url)("worker_threads")},853:(r,t,a)=>{const n=65536;if(!globalThis.ReadableStream){try{const r=a(742);const{emitWarning:t}=r;try{r.emitWarning=()=>{};Object.assign(globalThis,a(477));r.emitWarning=t}catch(a){r.emitWarning=t;throw a}}catch(r){Object.assign(globalThis,a(107))}}try{const{Blob:r}=a(300);if(r&&!r.prototype.stream){r.prototype.stream=function name(r){let t=0;const a=this;return new ReadableStream({type:"bytes",async pull(r){const o=a.slice(t,Math.min(a.size,t+n));const i=await o.arrayBuffer();t+=i.byteLength;r.enqueue(new Uint8Array(i));if(t===a.size){r.close()}}})}}}catch(r){}},513:(r,t,a)=>{a.d(t,{Z:()=>l});var n=a(280);const o=class File extends n.Z{#e=0;#r="";constructor(r,t,a={}){if(arguments.length<2){throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)}super(r,a);if(a===null)a={};const n=a.lastModified===undefined?Date.now():Number(a.lastModified);if(!Number.isNaN(n)){this.#e=n}this.#r=String(t)}get name(){return this.#r}get lastModified(){return this.#e}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](r){return!!r&&r instanceof n.Z&&/^(File)$/.test(r[Symbol.toStringTag])}};const i=o;const l=i},128:(t,a,n)=>{n.d(a,{t6:()=>u.Z,$B:()=>s.Z,xB:()=>blobFrom,SX:()=>blobFromSync,e2:()=>fileFrom,RA:()=>fileFromSync});const o=r(import.meta.url)("node:fs");const i=r(import.meta.url)("node:path");var l=n(611);var s=n(513);var u=n(280);const{stat:d}=o.promises;const blobFromSync=(r,t)=>fromBlob((0,o.statSync)(r),r,t);const blobFrom=(r,t)=>d(r).then((a=>fromBlob(a,r,t)));const fileFrom=(r,t)=>d(r).then((a=>fromFile(a,r,t)));const fileFromSync=(r,t)=>fromFile((0,o.statSync)(r),r,t);const fromBlob=(r,t,a="")=>new u.Z([new BlobDataItem({path:t,size:r.size,lastModified:r.mtimeMs,start:0})],{type:a});const fromFile=(r,t,a="")=>new s.Z([new BlobDataItem({path:t,size:r.size,lastModified:r.mtimeMs,start:0})],(0,i.basename)(t),{type:a,lastModified:r.mtimeMs});class BlobDataItem{#t;#a;constructor(r){this.#t=r.path;this.#a=r.start;this.size=r.size;this.lastModified=r.lastModified}slice(r,t){return new BlobDataItem({path:this.#t,lastModified:this.lastModified,size:t-r,start:this.#a+r})}async*stream(){const{mtimeMs:r}=await d(this.#t);if(r>this.lastModified){throw new l("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError")}yield*(0,o.createReadStream)(this.#t,{start:this.#a,end:this.#a+this.size-1})}get[Symbol.toStringTag](){return"Blob"}}const c=null&&blobFromSync},280:(r,t,a)=>{a.d(t,{Z:()=>s});var n=a(853);
/*! fetch-blob. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */const o=65536;async function*toIterator(r,t=true){for(const a of r){if("stream"in a){yield*a.stream()}else if(ArrayBuffer.isView(a)){if(t){let r=a.byteOffset;const t=a.byteOffset+a.byteLength;while(r!==t){const n=Math.min(t-r,o);const i=a.buffer.slice(r,r+n);r+=i.byteLength;yield new Uint8Array(i)}}else{yield a}}else{let r=0,t=a;while(r!==t.size){const a=t.slice(r,Math.min(t.size,r+o));const n=await a.arrayBuffer();r+=n.byteLength;yield new Uint8Array(n)}}}}const i=class Blob{#n=[];#o="";#i=0;#l="transparent";constructor(r=[],t={}){if(typeof r!=="object"||r===null){throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.")}if(typeof r[Symbol.iterator]!=="function"){throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.")}if(typeof t!=="object"&&typeof t!=="function"){throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.")}if(t===null)t={};const a=new TextEncoder;for(const t of r){let r;if(ArrayBuffer.isView(t)){r=new Uint8Array(t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength))}else if(t instanceof ArrayBuffer){r=new Uint8Array(t.slice(0))}else if(t instanceof Blob){r=t}else{r=a.encode(`${t}`)}this.#i+=ArrayBuffer.isView(r)?r.byteLength:r.size;this.#n.push(r)}this.#l=`${t.endings===undefined?"transparent":t.endings}`;const n=t.type===undefined?"":String(t.type);this.#o=/^[\x20-\x7E]*$/.test(n)?n:""}get size(){return this.#i}get type(){return this.#o}async text(){const r=new TextDecoder;let t="";for await(const a of toIterator(this.#n,false)){t+=r.decode(a,{stream:true})}t+=r.decode();return t}async arrayBuffer(){const r=new Uint8Array(this.size);let t=0;for await(const a of toIterator(this.#n,false)){r.set(a,t);t+=a.length}return r.buffer}stream(){const r=toIterator(this.#n,true);return new globalThis.ReadableStream({type:"bytes",async pull(t){const a=await r.next();a.done?t.close():t.enqueue(a.value)},async cancel(){await r.return()}})}slice(r=0,t=this.size,a=""){const{size:n}=this;let o=r<0?Math.max(n+r,0):Math.min(r,n);let i=t<0?Math.max(n+t,0):Math.min(t,n);const l=Math.max(i-o,0);const s=this.#n;const u=[];let d=0;for(const r of s){if(d>=l){break}const t=ArrayBuffer.isView(r)?r.byteLength:r.size;if(o&&t<=o){o-=t;i-=t}else{let a;if(ArrayBuffer.isView(r)){a=r.subarray(o,Math.min(t,i));d+=a.byteLength}else{a=r.slice(o,Math.min(t,i));d+=a.size}i-=t;u.push(a);o=0}}const c=new Blob([],{type:String(a).toLowerCase()});c.#i=l;c.#n=u;return c}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](r){return r&&typeof r==="object"&&typeof r.constructor==="function"&&(typeof r.stream==="function"||typeof r.arrayBuffer==="function")&&/^(Blob|File)$/.test(r[Symbol.toStringTag])}};Object.defineProperties(i.prototype,{size:{enumerable:true},type:{enumerable:true},slice:{enumerable:true}});const l=i;const s=l},934:(r,t,a)=>{a.d(t,{Ct:()=>m,au:()=>formDataToBlob});var n=a(280);var o=a(513);
/*! formdata-polyfill. MIT License. Jimmy WÃ¤rting <https://jimmy.warting.se/opensource> */var{toStringTag:i,iterator:l,hasInstance:s}=Symbol,u=Math.random,d="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),f=(r,t,a)=>(r+="",/^(Blob|File)$/.test(t&&t[i])?[(a=a!==void 0?a+"":t[i]=="File"?t.name:"blob",r),t.name!==a||t[i]=="blob"?new o.Z([t],a,t):t]:[r,t+""]),e=(r,t)=>(t?r:r.replace(/\r?\n|\r/g,"\r\n")).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),x=(r,t,a)=>{if(t.length<a){throw new TypeError(`Failed to execute '${r}' on 'FormData': ${a} arguments required, but only ${t.length} present.`)}};const c=null&&F;const m=class FormData{#s=[];constructor(...r){if(r.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}get[i](){return"FormData"}[l](){return this.entries()}static[s](r){return r&&typeof r==="object"&&r[i]==="FormData"&&!d.some((t=>typeof r[t]!="function"))}append(...r){x("append",arguments,2);this.#s.push(f(...r))}delete(r){x("delete",arguments,1);r+="";this.#s=this.#s.filter((([t])=>t!==r))}get(r){x("get",arguments,1);r+="";for(var t=this.#s,a=t.length,n=0;n<a;n++)if(t[n][0]===r)return t[n][1];return null}getAll(r,t){x("getAll",arguments,1);t=[];r+="";this.#s.forEach((a=>a[0]===r&&t.push(a[1])));return t}has(r){x("has",arguments,1);r+="";return this.#s.some((t=>t[0]===r))}forEach(r,t){x("forEach",arguments,1);for(var[a,n]of this)r.call(t,n,a,this)}set(...r){x("set",arguments,2);var t=[],a=!0;r=f(...r);this.#s.forEach((n=>{n[0]===r[0]?a&&(a=!t.push(r)):t.push(n)}));a&&t.push(r);this.#s=t}*entries(){yield*this.#s}*keys(){for(var[r]of this)yield r}*values(){for(var[,r]of this)yield r}};function formDataToBlob(r,t=n.Z){var a=`${u()}${u()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),o=[],i=`--${a}\r\nContent-Disposition: form-data; name="`;r.forEach(((r,t)=>typeof r=="string"?o.push(i+e(t)+`"\r\n\r\n${r.replace(/\r(?!\n)|(?<!\r)\n/g,"\r\n")}\r\n`):o.push(i+e(t)+`"; filename="${e(r.name,1)}"\r\nContent-Type: ${r.type||"application/octet-stream"}\r\n\r\n`,r,"\r\n")));o.push(`--${a}--`);return new t(o,{type:"multipart/form-data; boundary="+a})}}};var a={};function __nccwpck_require__(r){var n=a[r];if(n!==undefined){return n.exports}var o=a[r]={exports:{}};var i=true;try{t[r].call(o.exports,o,o.exports,__nccwpck_require__);i=false}finally{if(i)delete a[r]}return o.exports}__nccwpck_require__.m=t;(()=>{__nccwpck_require__.d=(r,t)=>{for(var a in t){if(__nccwpck_require__.o(t,a)&&!__nccwpck_require__.o(r,a)){Object.defineProperty(r,a,{enumerable:true,get:t[a]})}}}})();(()=>{__nccwpck_require__.f={};__nccwpck_require__.e=r=>Promise.all(Object.keys(__nccwpck_require__.f).reduce(((t,a)=>{__nccwpck_require__.f[a](r,t);return t}),[]))})();(()=>{__nccwpck_require__.u=r=>""+r+".index.js"})();(()=>{__nccwpck_require__.o=(r,t)=>Object.prototype.hasOwnProperty.call(r,t)})();(()=>{__nccwpck_require__.r=r=>{if(typeof Symbol!=="undefined"&&Symbol.toStringTag){Object.defineProperty(r,Symbol.toStringTag,{value:"Module"})}Object.defineProperty(r,"__esModule",{value:true})}})();if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=new URL(".",import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/)?1:0,-1)+"/";(()=>{var r={179:0};var installChunk=t=>{var{ids:a,modules:n,runtime:o}=t;var i,l,s=0;for(i in n){if(__nccwpck_require__.o(n,i)){__nccwpck_require__.m[i]=n[i]}}if(o)o(__nccwpck_require__);for(;s<a.length;s++){l=a[s];if(__nccwpck_require__.o(r,l)&&r[l]){r[l][0]()}r[a[s]]=0}};__nccwpck_require__.f.j=(t,a)=>{var n=__nccwpck_require__.o(r,t)?r[t]:undefined;if(n!==0){if(n){a.push(n[1])}else{if(true){var o=import("./"+__nccwpck_require__.u(t)).then(installChunk,(a=>{if(r[t]!==0)r[t]=undefined;throw a}));var o=Promise.race([o,new Promise((a=>n=r[t]=[a]))]);a.push(n[1]=o)}else r[t]=0}}}})();var n={};(()=>{__nccwpck_require__.d(n,{_L:()=>AbortError,t6:()=>T.t6,kp:()=>FetchError,$B:()=>T.$B,Ct:()=>c.Ct,PM:()=>Headers,cf:()=>Request,HM:()=>Response,xB:()=>T.xB,SX:()=>T.SX,ZP:()=>fetch,e2:()=>T.e2,RA:()=>T.RA,x8:()=>isRedirect});const t=r(import.meta.url)("node:http");const a=r(import.meta.url)("node:https");const o=r(import.meta.url)("node:zlib");const i=r(import.meta.url)("node:stream");const l=r(import.meta.url)("node:buffer");function dataUriToBuffer(r){if(!/^data:/i.test(r)){throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")')}r=r.replace(/\r?\n/g,"");const t=r.indexOf(",");if(t===-1||t<=4){throw new TypeError("malformed data: URI")}const a=r.substring(5,t).split(";");let n="";let o=false;const i=a[0]||"text/plain";let l=i;for(let r=1;r<a.length;r++){if(a[r]==="base64"){o=true}else{l+=`;${a[r]}`;if(a[r].indexOf("charset=")===0){n=a[r].substring(8)}}}if(!a[0]&&!n.length){l+=";charset=US-ASCII";n="US-ASCII"}const s=o?"base64":"ascii";const u=unescape(r.substring(t+1));const d=Buffer.from(u,s);d.type=i;d.typeFull=l;d.charset=n;return d}const s=dataUriToBuffer;const u=r(import.meta.url)("node:util");var d=__nccwpck_require__(280);var c=__nccwpck_require__(934);class FetchBaseError extends Error{constructor(r,t){super(r);Error.captureStackTrace(this,this.constructor);this.type=t}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}}class FetchError extends FetchBaseError{constructor(r,t,a){super(r,t);if(a){this.code=this.errno=a.code;this.erroredSysCall=a.syscall}}}const m=Symbol.toStringTag;const isURLSearchParameters=r=>typeof r==="object"&&typeof r.append==="function"&&typeof r.delete==="function"&&typeof r.get==="function"&&typeof r.getAll==="function"&&typeof r.has==="function"&&typeof r.set==="function"&&typeof r.sort==="function"&&r[m]==="URLSearchParams";const isBlob=r=>r&&typeof r==="object"&&typeof r.arrayBuffer==="function"&&typeof r.type==="string"&&typeof r.stream==="function"&&typeof r.constructor==="function"&&/^(Blob|File)$/.test(r[m]);const isAbortSignal=r=>typeof r==="object"&&(r[m]==="AbortSignal"||r[m]==="EventTarget");const isDomainOrSubdomain=(r,t)=>{const a=new URL(t).hostname;const n=new URL(r).hostname;return a===n||a.endsWith(`.${n}`)};const isSameProtocol=(r,t)=>{const a=new URL(t).protocol;const n=new URL(r).protocol;return a===n};const b=(0,u.promisify)(i.pipeline);const h=Symbol("Body internals");class Body{constructor(r,{size:t=0}={}){let a=null;if(r===null){r=null}else if(isURLSearchParameters(r)){r=l.Buffer.from(r.toString())}else if(isBlob(r)){}else if(l.Buffer.isBuffer(r)){}else if(u.types.isAnyArrayBuffer(r)){r=l.Buffer.from(r)}else if(ArrayBuffer.isView(r)){r=l.Buffer.from(r.buffer,r.byteOffset,r.byteLength)}else if(r instanceof i){}else if(r instanceof c.Ct){r=(0,c.au)(r);a=r.type.split("=")[1]}else{r=l.Buffer.from(String(r))}let n=r;if(l.Buffer.isBuffer(r)){n=i.Readable.from(r)}else if(isBlob(r)){n=i.Readable.from(r.stream())}this[h]={body:r,stream:n,boundary:a,disturbed:false,error:null};this.size=t;if(r instanceof i){r.on("error",(r=>{const t=r instanceof FetchBaseError?r:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${r.message}`,"system",r);this[h].error=t}))}}get body(){return this[h].stream}get bodyUsed(){return this[h].disturbed}async arrayBuffer(){const{buffer:r,byteOffset:t,byteLength:a}=await consumeBody(this);return r.slice(t,t+a)}async formData(){const r=this.headers.get("content-type");if(r.startsWith("application/x-www-form-urlencoded")){const r=new c.Ct;const t=new URLSearchParams(await this.text());for(const[a,n]of t){r.append(a,n)}return r}const{toFormData:t}=await __nccwpck_require__.e(273).then(__nccwpck_require__.bind(__nccwpck_require__,273));return t(this.body,r)}async blob(){const r=this.headers&&this.headers.get("content-type")||this[h].body&&this[h].body.type||"";const t=await this.arrayBuffer();return new d.Z([t],{type:r})}async json(){const r=await this.text();return JSON.parse(r)}async text(){const r=await consumeBody(this);return(new TextDecoder).decode(r)}buffer(){return consumeBody(this)}}Body.prototype.buffer=(0,u.deprecate)(Body.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer");Object.defineProperties(Body.prototype,{body:{enumerable:true},bodyUsed:{enumerable:true},arrayBuffer:{enumerable:true},blob:{enumerable:true},json:{enumerable:true},text:{enumerable:true},data:{get:(0,u.deprecate)((()=>{}),"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});async function consumeBody(r){if(r[h].disturbed){throw new TypeError(`body used already for: ${r.url}`)}r[h].disturbed=true;if(r[h].error){throw r[h].error}const{body:t}=r;if(t===null){return l.Buffer.alloc(0)}if(!(t instanceof i)){return l.Buffer.alloc(0)}const a=[];let n=0;try{for await(const o of t){if(r.size>0&&n+o.length>r.size){const a=new FetchError(`content size at ${r.url} over limit: ${r.size}`,"max-size");t.destroy(a);throw a}n+=o.length;a.push(o)}}catch(t){const a=t instanceof FetchBaseError?t:new FetchError(`Invalid response body while trying to fetch ${r.url}: ${t.message}`,"system",t);throw a}if(t.readableEnded===true||t._readableState.ended===true){try{if(a.every((r=>typeof r==="string"))){return l.Buffer.from(a.join(""))}return l.Buffer.concat(a,n)}catch(t){throw new FetchError(`Could not create Buffer from response body for ${r.url}: ${t.message}`,"system",t)}}else{throw new FetchError(`Premature close of server response while trying to fetch ${r.url}`)}}const clone=(r,t)=>{let a;let n;let{body:o}=r[h];if(r.bodyUsed){throw new Error("cannot clone body after it is used")}if(o instanceof i&&typeof o.getBoundary!=="function"){a=new i.PassThrough({highWaterMark:t});n=new i.PassThrough({highWaterMark:t});o.pipe(a);o.pipe(n);r[h].stream=a;o=n}return o};const p=(0,u.deprecate)((r=>r.getBoundary()),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167");const extractContentType=(r,t)=>{if(r===null){return null}if(typeof r==="string"){return"text/plain;charset=UTF-8"}if(isURLSearchParameters(r)){return"application/x-www-form-urlencoded;charset=UTF-8"}if(isBlob(r)){return r.type||null}if(l.Buffer.isBuffer(r)||u.types.isAnyArrayBuffer(r)||ArrayBuffer.isView(r)){return null}if(r instanceof c.Ct){return`multipart/form-data; boundary=${t[h].boundary}`}if(r&&typeof r.getBoundary==="function"){return`multipart/form-data;boundary=${p(r)}`}if(r instanceof i){return null}return"text/plain;charset=UTF-8"};const getTotalBytes=r=>{const{body:t}=r[h];if(t===null){return 0}if(isBlob(t)){return t.size}if(l.Buffer.isBuffer(t)){return t.length}if(t&&typeof t.getLengthSync==="function"){return t.hasKnownLength&&t.hasKnownLength()?t.getLengthSync():null}return null};const writeToStream=async(r,{body:t})=>{if(t===null){r.end()}else{await b(t,r)}};const S=typeof t.validateHeaderName==="function"?t.validateHeaderName:r=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(r)){const t=new TypeError(`Header name must be a valid HTTP token [${r}]`);Object.defineProperty(t,"code",{value:"ERR_INVALID_HTTP_TOKEN"});throw t}};const y=typeof t.validateHeaderValue==="function"?t.validateHeaderValue:(r,t)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(t)){const t=new TypeError(`Invalid character in header content ["${r}"]`);Object.defineProperty(t,"code",{value:"ERR_INVALID_CHAR"});throw t}};class Headers extends URLSearchParams{constructor(r){let t=[];if(r instanceof Headers){const a=r.raw();for(const[r,n]of Object.entries(a)){t.push(...n.map((t=>[r,t])))}}else if(r==null){}else if(typeof r==="object"&&!u.types.isBoxedPrimitive(r)){const a=r[Symbol.iterator];if(a==null){t.push(...Object.entries(r))}else{if(typeof a!=="function"){throw new TypeError("Header pairs must be iterable")}t=[...r].map((r=>{if(typeof r!=="object"||u.types.isBoxedPrimitive(r)){throw new TypeError("Each header pair must be an iterable object")}return[...r]})).map((r=>{if(r.length!==2){throw new TypeError("Each header pair must be a name/value tuple")}return[...r]}))}}else{throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)")}t=t.length>0?t.map((([r,t])=>{S(r);y(r,String(t));return[String(r).toLowerCase(),String(t)]})):undefined;super(t);return new Proxy(this,{get(r,t,a){switch(t){case"append":case"set":return(a,n)=>{S(a);y(a,String(n));return URLSearchParams.prototype[t].call(r,String(a).toLowerCase(),String(n))};case"delete":case"has":case"getAll":return a=>{S(a);return URLSearchParams.prototype[t].call(r,String(a).toLowerCase())};case"keys":return()=>{r.sort();return new Set(URLSearchParams.prototype.keys.call(r)).keys()};default:return Reflect.get(r,t,a)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(r){const t=this.getAll(r);if(t.length===0){return null}let a=t.join(", ");if(/^content-encoding$/i.test(r)){a=a.toLowerCase()}return a}forEach(r,t=undefined){for(const a of this.keys()){Reflect.apply(r,t,[this.get(a),a,this])}}*values(){for(const r of this.keys()){yield this.get(r)}}*entries(){for(const r of this.keys()){yield[r,this.get(r)]}}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce(((r,t)=>{r[t]=this.getAll(t);return r}),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce(((r,t)=>{const a=this.getAll(t);if(t==="host"){r[t]=a[0]}else{r[t]=a.length>1?a:a[0]}return r}),{})}}Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce(((r,t)=>{r[t]={enumerable:true};return r}),{}));function fromRawHeaders(r=[]){return new Headers(r.reduce(((r,t,a,n)=>{if(a%2===0){r.push(n.slice(a,a+2))}return r}),[]).filter((([r,t])=>{try{S(r);y(r,String(t));return true}catch{return false}})))}const R=new Set([301,302,303,307,308]);const isRedirect=r=>R.has(r);const g=Symbol("Response internals");class Response extends Body{constructor(r=null,t={}){super(r,t);const a=t.status!=null?t.status:200;const n=new Headers(t.headers);if(r!==null&&!n.has("Content-Type")){const t=extractContentType(r,this);if(t){n.append("Content-Type",t)}}this[g]={type:"default",url:t.url,status:a,statusText:t.statusText||"",headers:n,counter:t.counter,highWaterMark:t.highWaterMark}}get type(){return this[g].type}get url(){return this[g].url||""}get status(){return this[g].status}get ok(){return this[g].status>=200&&this[g].status<300}get redirected(){return this[g].counter>0}get statusText(){return this[g].statusText}get headers(){return this[g].headers}get highWaterMark(){return this[g].highWaterMark}clone(){return new Response(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(r,t=302){if(!isRedirect(t)){throw new RangeError('Failed to execute "redirect" on "response": Invalid status code')}return new Response(null,{headers:{location:new URL(r).toString()},status:t})}static error(){const r=new Response(null,{status:0,statusText:""});r[g].type="error";return r}static json(r=undefined,t={}){const a=JSON.stringify(r);if(a===undefined){throw new TypeError("data is not JSON serializable")}const n=new Headers(t&&t.headers);if(!n.has("content-type")){n.set("content-type","application/json")}return new Response(a,{...t,headers:n})}get[Symbol.toStringTag](){return"Response"}}Object.defineProperties(Response.prototype,{type:{enumerable:true},url:{enumerable:true},status:{enumerable:true},ok:{enumerable:true},redirected:{enumerable:true},statusText:{enumerable:true},headers:{enumerable:true},clone:{enumerable:true}});const _=r(import.meta.url)("node:url");const getSearch=r=>{if(r.search){return r.search}const t=r.href.length-1;const a=r.hash||(r.href[t]==="#"?"#":"");return r.href[t-a.length]==="?"?"?":""};const C=r(import.meta.url)("node:net");function stripURLForUseAsAReferrer(r,t=false){if(r==null){return"no-referrer"}r=new URL(r);if(/^(about|blob|data):$/.test(r.protocol)){return"no-referrer"}r.username="";r.password="";r.hash="";if(t){r.pathname="";r.search=""}return r}const w=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]);const W="strict-origin-when-cross-origin";function validateReferrerPolicy(r){if(!w.has(r)){throw new TypeError(`Invalid referrerPolicy: ${r}`)}return r}function isOriginPotentiallyTrustworthy(r){if(/^(http|ws)s:$/.test(r.protocol)){return true}const t=r.host.replace(/(^\[)|(]$)/g,"");const a=(0,C.isIP)(t);if(a===4&&/^127\./.test(t)){return true}if(a===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(t)){return true}if(r.host==="localhost"||r.host.endsWith(".localhost")){return false}if(r.protocol==="file:"){return true}return false}function isUrlPotentiallyTrustworthy(r){if(/^about:(blank|srcdoc)$/.test(r)){return true}if(r.protocol==="data:"){return true}if(/^(blob|filesystem):$/.test(r.protocol)){return true}return isOriginPotentiallyTrustworthy(r)}function determineRequestsReferrer(r,{referrerURLCallback:t,referrerOriginCallback:a}={}){if(r.referrer==="no-referrer"||r.referrerPolicy===""){return null}const n=r.referrerPolicy;if(r.referrer==="about:client"){return"no-referrer"}const o=r.referrer;let i=stripURLForUseAsAReferrer(o);let l=stripURLForUseAsAReferrer(o,true);if(i.toString().length>4096){i=l}if(t){i=t(i)}if(a){l=a(l)}const s=new URL(r.url);switch(n){case"no-referrer":return"no-referrer";case"origin":return l;case"unsafe-url":return i;case"strict-origin":if(isUrlPotentiallyTrustworthy(i)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return l.toString();case"strict-origin-when-cross-origin":if(i.origin===s.origin){return i}if(isUrlPotentiallyTrustworthy(i)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return l;case"same-origin":if(i.origin===s.origin){return i}return"no-referrer";case"origin-when-cross-origin":if(i.origin===s.origin){return i}return l;case"no-referrer-when-downgrade":if(isUrlPotentiallyTrustworthy(i)&&!isUrlPotentiallyTrustworthy(s)){return"no-referrer"}return i;default:throw new TypeError(`Invalid referrerPolicy: ${n}`)}}function parseReferrerPolicyFromHeader(r){const t=(r.get("referrer-policy")||"").split(/[,\s]+/);let a="";for(const r of t){if(r&&w.has(r)){a=r}}return a}const B=Symbol("Request internals");const isRequest=r=>typeof r==="object"&&typeof r[B]==="object";const P=(0,u.deprecate)((()=>{}),".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)");class Request extends Body{constructor(r,t={}){let a;if(isRequest(r)){a=new URL(r.url)}else{a=new URL(r);r={}}if(a.username!==""||a.password!==""){throw new TypeError(`${a} is an url with embedded credentials.`)}let n=t.method||r.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(n)){n=n.toUpperCase()}if(!isRequest(t)&&"data"in t){P()}if((t.body!=null||isRequest(r)&&r.body!==null)&&(n==="GET"||n==="HEAD")){throw new TypeError("Request with GET/HEAD method cannot have body")}const o=t.body?t.body:isRequest(r)&&r.body!==null?clone(r):null;super(o,{size:t.size||r.size||0});const i=new Headers(t.headers||r.headers||{});if(o!==null&&!i.has("Content-Type")){const r=extractContentType(o,this);if(r){i.set("Content-Type",r)}}let l=isRequest(r)?r.signal:null;if("signal"in t){l=t.signal}if(l!=null&&!isAbortSignal(l)){throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget")}let s=t.referrer==null?r.referrer:t.referrer;if(s===""){s="no-referrer"}else if(s){const r=new URL(s);s=/^about:(\/\/)?client$/.test(r)?"client":r}else{s=undefined}this[B]={method:n,redirect:t.redirect||r.redirect||"follow",headers:i,parsedURL:a,signal:l,referrer:s};this.follow=t.follow===undefined?r.follow===undefined?20:r.follow:t.follow;this.compress=t.compress===undefined?r.compress===undefined?true:r.compress:t.compress;this.counter=t.counter||r.counter||0;this.agent=t.agent||r.agent;this.highWaterMark=t.highWaterMark||r.highWaterMark||16384;this.insecureHTTPParser=t.insecureHTTPParser||r.insecureHTTPParser||false;this.referrerPolicy=t.referrerPolicy||r.referrerPolicy||""}get method(){return this[B].method}get url(){return(0,_.format)(this[B].parsedURL)}get headers(){return this[B].headers}get redirect(){return this[B].redirect}get signal(){return this[B].signal}get referrer(){if(this[B].referrer==="no-referrer"){return""}if(this[B].referrer==="client"){return"about:client"}if(this[B].referrer){return this[B].referrer.toString()}return undefined}get referrerPolicy(){return this[B].referrerPolicy}set referrerPolicy(r){this[B].referrerPolicy=validateReferrerPolicy(r)}clone(){return new Request(this)}get[Symbol.toStringTag](){return"Request"}}Object.defineProperties(Request.prototype,{method:{enumerable:true},url:{enumerable:true},headers:{enumerable:true},redirect:{enumerable:true},clone:{enumerable:true},signal:{enumerable:true},referrer:{enumerable:true},referrerPolicy:{enumerable:true}});const getNodeRequestOptions=r=>{const{parsedURL:t}=r[B];const a=new Headers(r[B].headers);if(!a.has("Accept")){a.set("Accept","*/*")}let n=null;if(r.body===null&&/^(post|put)$/i.test(r.method)){n="0"}if(r.body!==null){const t=getTotalBytes(r);if(typeof t==="number"&&!Number.isNaN(t)){n=String(t)}}if(n){a.set("Content-Length",n)}if(r.referrerPolicy===""){r.referrerPolicy=W}if(r.referrer&&r.referrer!=="no-referrer"){r[B].referrer=determineRequestsReferrer(r)}else{r[B].referrer="no-referrer"}if(r[B].referrer instanceof URL){a.set("Referer",r.referrer)}if(!a.has("User-Agent")){a.set("User-Agent","node-fetch")}if(r.compress&&!a.has("Accept-Encoding")){a.set("Accept-Encoding","gzip, deflate, br")}let{agent:o}=r;if(typeof o==="function"){o=o(t)}if(!a.has("Connection")&&!o){a.set("Connection","close")}const i=getSearch(t);const l={path:t.pathname+i,method:r.method,headers:a[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:r.insecureHTTPParser,agent:o};return{parsedURL:t,options:l}};class AbortError extends FetchBaseError{constructor(r,t="aborted"){super(r,t)}}var T=__nccwpck_require__(128);const E=new Set(["data:","http:","https:"]);async function fetch(r,n){return new Promise(((l,u)=>{const d=new Request(r,n);const{parsedURL:c,options:m}=getNodeRequestOptions(d);if(!E.has(c.protocol)){throw new TypeError(`node-fetch cannot load ${r}. URL scheme "${c.protocol.replace(/:$/,"")}" is not supported.`)}if(c.protocol==="data:"){const r=s(d.url);const t=new Response(r,{headers:{"Content-Type":r.typeFull}});l(t);return}const b=(c.protocol==="https:"?a:t).request;const{signal:h}=d;let p=null;const abort=()=>{const r=new AbortError("The operation was aborted.");u(r);if(d.body&&d.body instanceof i.Readable){d.body.destroy(r)}if(!p||!p.body){return}p.body.emit("error",r)};if(h&&h.aborted){abort();return}const abortAndFinalize=()=>{abort();finalize()};const S=b(c.toString(),m);if(h){h.addEventListener("abort",abortAndFinalize)}const finalize=()=>{S.abort();if(h){h.removeEventListener("abort",abortAndFinalize)}};S.on("error",(r=>{u(new FetchError(`request to ${d.url} failed, reason: ${r.message}`,"system",r));finalize()}));fixResponseChunkedTransferBadEnding(S,(r=>{if(p&&p.body){p.body.destroy(r)}}));if(process.version<"v14"){S.on("socket",(r=>{let t;r.prependListener("end",(()=>{t=r._eventsCount}));r.prependListener("close",(a=>{if(p&&t<r._eventsCount&&!a){const r=new Error("Premature close");r.code="ERR_STREAM_PREMATURE_CLOSE";p.body.emit("error",r)}}))}))}S.on("response",(r=>{S.setTimeout(0);const t=fromRawHeaders(r.rawHeaders);if(isRedirect(r.statusCode)){const a=t.get("Location");let o=null;try{o=a===null?null:new URL(a,d.url)}catch{if(d.redirect!=="manual"){u(new FetchError(`uri requested responds with an invalid redirect URL: ${a}`,"invalid-redirect"));finalize();return}}switch(d.redirect){case"error":u(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${d.url}`,"no-redirect"));finalize();return;case"manual":break;case"follow":{if(o===null){break}if(d.counter>=d.follow){u(new FetchError(`maximum redirect reached at: ${d.url}`,"max-redirect"));finalize();return}const a={headers:new Headers(d.headers),follow:d.follow,counter:d.counter+1,agent:d.agent,compress:d.compress,method:d.method,body:clone(d),signal:d.signal,size:d.size,referrer:d.referrer,referrerPolicy:d.referrerPolicy};if(!isDomainOrSubdomain(d.url,o)||!isSameProtocol(d.url,o)){for(const r of["authorization","www-authenticate","cookie","cookie2"]){a.headers.delete(r)}}if(r.statusCode!==303&&d.body&&n.body instanceof i.Readable){u(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect"));finalize();return}if(r.statusCode===303||(r.statusCode===301||r.statusCode===302)&&d.method==="POST"){a.method="GET";a.body=undefined;a.headers.delete("content-length")}const s=parseReferrerPolicyFromHeader(t);if(s){a.referrerPolicy=s}l(fetch(new Request(o,a)));finalize();return}default:return u(new TypeError(`Redirect option '${d.redirect}' is not a valid value of RequestRedirect`))}}if(h){r.once("end",(()=>{h.removeEventListener("abort",abortAndFinalize)}))}let a=(0,i.pipeline)(r,new i.PassThrough,(r=>{if(r){u(r)}}));if(process.version<"v12.10"){r.on("aborted",abortAndFinalize)}const s={url:d.url,status:r.statusCode,statusText:r.statusMessage,headers:t,size:d.size,counter:d.counter,highWaterMark:d.highWaterMark};const c=t.get("Content-Encoding");if(!d.compress||d.method==="HEAD"||c===null||r.statusCode===204||r.statusCode===304){p=new Response(a,s);l(p);return}const m={flush:o.Z_SYNC_FLUSH,finishFlush:o.Z_SYNC_FLUSH};if(c==="gzip"||c==="x-gzip"){a=(0,i.pipeline)(a,o.createGunzip(m),(r=>{if(r){u(r)}}));p=new Response(a,s);l(p);return}if(c==="deflate"||c==="x-deflate"){const t=(0,i.pipeline)(r,new i.PassThrough,(r=>{if(r){u(r)}}));t.once("data",(r=>{if((r[0]&15)===8){a=(0,i.pipeline)(a,o.createInflate(),(r=>{if(r){u(r)}}))}else{a=(0,i.pipeline)(a,o.createInflateRaw(),(r=>{if(r){u(r)}}))}p=new Response(a,s);l(p)}));t.once("end",(()=>{if(!p){p=new Response(a,s);l(p)}}));return}if(c==="br"){a=(0,i.pipeline)(a,o.createBrotliDecompress(),(r=>{if(r){u(r)}}));p=new Response(a,s);l(p);return}p=new Response(a,s);l(p)}));writeToStream(S,d).catch(u)}))}function fixResponseChunkedTransferBadEnding(r,t){const a=l.Buffer.from("0\r\n\r\n");let n=false;let o=false;let i;r.on("response",(r=>{const{headers:t}=r;n=t["transfer-encoding"]==="chunked"&&!t["content-length"]}));r.on("socket",(s=>{const onSocketClose=()=>{if(n&&!o){const r=new Error("Premature close");r.code="ERR_STREAM_PREMATURE_CLOSE";t(r)}};const onData=r=>{o=l.Buffer.compare(r.slice(-5),a)===0;if(!o&&i){o=l.Buffer.compare(i.slice(-3),a.slice(0,3))===0&&l.Buffer.compare(r.slice(-2),a.slice(3))===0}i=r};s.prependListener("close",onSocketClose);s.on("data",onData);r.on("close",(()=>{s.removeListener("close",onSocketClose);s.removeListener("data",onData)}))}))}})();var o=n._L;var i=n.t6;var l=n.kp;var s=n.$B;var u=n.Ct;var d=n.PM;var c=n.cf;var m=n.HM;var b=n.xB;var h=n.SX;var p=n.ZP;var S=n.e2;var y=n.RA;var R=n.x8;export{o as AbortError,i as Blob,l as FetchError,s as File,u as FormData,d as Headers,c as Request,m as Response,b as blobFrom,h as blobFromSync,p as default,S as fileFrom,y as fileFromSync,R as isRedirect};