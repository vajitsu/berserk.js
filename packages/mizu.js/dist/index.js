"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// ../../node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "../../node_modules/tslib/tslib.js"(exports2, module2) {
    var __extends;
    var __assign;
    var __rest;
    var __decorate;
    var __param;
    var __metadata;
    var __awaiter;
    var __generator;
    var __exportStar;
    var __values;
    var __read;
    var __spread;
    var __spreadArrays;
    var __spreadArray;
    var __await;
    var __asyncGenerator;
    var __asyncDelegator;
    var __asyncValues;
    var __makeTemplateObject;
    var __importStar;
    var __importDefault;
    var __classPrivateFieldGet;
    var __classPrivateFieldSet;
    var __classPrivateFieldIn;
    var __createBinding;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports3) {
          factory(createExporter(root, createExporter(exports3)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports3, previous) {
        if (exports3 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports3, "__esModule", { value: true });
          } else {
            exports3.__esModule = true;
          }
        }
        return function(id, v) {
          return exports3[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate = function(decorators2, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators2, target, key, desc);
        else
          for (var i = decorators2.length - 1; i >= 0; i--)
            if (d = decorators2[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __metadata = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding(o, m, p);
      };
      __createBinding = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read(arguments[i]));
        return ar;
      };
      __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends);
      exporter("__assign", __assign);
      exporter("__rest", __rest);
      exporter("__decorate", __decorate);
      exporter("__param", __param);
      exporter("__metadata", __metadata);
      exporter("__awaiter", __awaiter);
      exporter("__generator", __generator);
      exporter("__exportStar", __exportStar);
      exporter("__createBinding", __createBinding);
      exporter("__values", __values);
      exporter("__read", __read);
      exporter("__spread", __spread);
      exporter("__spreadArrays", __spreadArrays);
      exporter("__spreadArray", __spreadArray);
      exporter("__await", __await);
      exporter("__asyncGenerator", __asyncGenerator);
      exporter("__asyncDelegator", __asyncDelegator);
      exporter("__asyncValues", __asyncValues);
      exporter("__makeTemplateObject", __makeTemplateObject);
      exporter("__importStar", __importStar);
      exporter("__importDefault", __importDefault);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    });
  }
});

// ../../node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS({
  "../../node_modules/discord-api-types/gateway/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS({
  "../../node_modules/discord-api-types/gateway/v10.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GatewayDispatchEvents = exports2.GatewayIntentBits = exports2.GatewayCloseCodes = exports2.GatewayOpcodes = exports2.GatewayVersion = void 0;
    __exportStar(require_common(), exports2);
    exports2.GatewayVersion = "10";
    var GatewayOpcodes;
    (function(GatewayOpcodes2) {
      GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
      GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
      GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
      GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
      GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
      GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
      GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
      GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
      GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
      GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
      GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
    })(GatewayOpcodes = exports2.GatewayOpcodes || (exports2.GatewayOpcodes = {}));
    var GatewayCloseCodes;
    (function(GatewayCloseCodes2) {
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4e3] = "UnknownError";
      GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
      GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
      GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
      GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
      GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
      GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
      GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
      GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
      GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
    })(GatewayCloseCodes = exports2.GatewayCloseCodes || (exports2.GatewayCloseCodes = {}));
    var GatewayIntentBits;
    (function(GatewayIntentBits2) {
      GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
      GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
      GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
      GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
      GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
      GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
      GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
      GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
      GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
      GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
      GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
      GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
      GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
      GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
      GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
    })(GatewayIntentBits = exports2.GatewayIntentBits || (exports2.GatewayIntentBits = {}));
    var GatewayDispatchEvents;
    (function(GatewayDispatchEvents2) {
      GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
      GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
      GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
      GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
      GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
      GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
      GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
      GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
      GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
      GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
      GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
      GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
      GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
      GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
      GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
      GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
      GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
      GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
      GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
      GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
      GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
      GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
      GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
      GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
      GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
      GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
      GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
      GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
      GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
      GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
      GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
      GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
      GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
      GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
      GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
      GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
      GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
      GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
      GatewayDispatchEvents2["Ready"] = "READY";
      GatewayDispatchEvents2["Resumed"] = "RESUMED";
      GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
      GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
      GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
      GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
      GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
      GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
      GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
      GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
      GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
      GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
      GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
      GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
      GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
      GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
      GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
      GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
      GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
      GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
      GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
    })(GatewayDispatchEvents = exports2.GatewayDispatchEvents || (exports2.GatewayDispatchEvents = {}));
  }
});

// ../../node_modules/discord-api-types/globals.js
var require_globals = __commonJS({
  "../../node_modules/discord-api-types/globals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FormattingPatterns = void 0;
    exports2.FormattingPatterns = {
      User: /<@(?<id>\d{17,20})>/,
      UserWithNickname: /<@!(?<id>\d{17,20})>/,
      UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
      Channel: /<#(?<id>\d{17,20})>/,
      Role: /<@&(?<id>\d{17,20})>/,
      SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
      Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
      Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[tTdDfFR]))?>/,
      DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
      StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[tTdDfFR])>/
    };
    Object.freeze(exports2.FormattingPatterns);
  }
});

// ../../node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS({
  "../../node_modules/discord-api-types/payloads/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PermissionFlagsBits = void 0;
    exports2.PermissionFlagsBits = {
      CreateInstantInvite: 1n << 0n,
      KickMembers: 1n << 1n,
      BanMembers: 1n << 2n,
      Administrator: 1n << 3n,
      ManageChannels: 1n << 4n,
      ManageGuild: 1n << 5n,
      AddReactions: 1n << 6n,
      ViewAuditLog: 1n << 7n,
      PrioritySpeaker: 1n << 8n,
      Stream: 1n << 9n,
      ViewChannel: 1n << 10n,
      SendMessages: 1n << 11n,
      SendTTSMessages: 1n << 12n,
      ManageMessages: 1n << 13n,
      EmbedLinks: 1n << 14n,
      AttachFiles: 1n << 15n,
      ReadMessageHistory: 1n << 16n,
      MentionEveryone: 1n << 17n,
      UseExternalEmojis: 1n << 18n,
      ViewGuildInsights: 1n << 19n,
      Connect: 1n << 20n,
      Speak: 1n << 21n,
      MuteMembers: 1n << 22n,
      DeafenMembers: 1n << 23n,
      MoveMembers: 1n << 24n,
      UseVAD: 1n << 25n,
      ChangeNickname: 1n << 26n,
      ManageNicknames: 1n << 27n,
      ManageRoles: 1n << 28n,
      ManageWebhooks: 1n << 29n,
      ManageEmojisAndStickers: 1n << 30n,
      UseApplicationCommands: 1n << 31n,
      RequestToSpeak: 1n << 32n,
      ManageEvents: 1n << 33n,
      ManageThreads: 1n << 34n,
      CreatePublicThreads: 1n << 35n,
      CreatePrivateThreads: 1n << 36n,
      UseExternalStickers: 1n << 37n,
      SendMessagesInThreads: 1n << 38n,
      UseEmbeddedActivities: 1n << 39n,
      ModerateMembers: 1n << 40n
    };
    Object.freeze(exports2.PermissionFlagsBits);
  }
});

// ../../node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/application.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationFlags = void 0;
    var ApplicationFlags;
    (function(ApplicationFlags2) {
      ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
      ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
      ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
      ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
      ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
      ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
      ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
      ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
      ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
      ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
      ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
      ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
    })(ApplicationFlags = exports2.ApplicationFlags || (exports2.ApplicationFlags = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuditLogOptionsType = exports2.AuditLogEvent = void 0;
    var AuditLogEvent;
    (function(AuditLogEvent2) {
      AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
      AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
      AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
      AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
      AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
      AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
      AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
      AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
      AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
      AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
      AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
      AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
      AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
      AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
      AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
      AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
      AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
      AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
      AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
      AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
      AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
      AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
      AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
      AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
      AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
      AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
      AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
      AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
      AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
      AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
      AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
      AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
      AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
      AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
      AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
      AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
      AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
      AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
      AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
      AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
      AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
      AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
      AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    })(AuditLogEvent = exports2.AuditLogEvent || (exports2.AuditLogEvent = {}));
    var AuditLogOptionsType;
    (function(AuditLogOptionsType2) {
      AuditLogOptionsType2["Role"] = "0";
      AuditLogOptionsType2["Member"] = "1";
    })(AuditLogOptionsType = exports2.AuditLogOptionsType || (exports2.AuditLogOptionsType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AutoModerationActionType = exports2.AutoModerationRuleEventType = exports2.AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleTriggerType = void 0;
    var AutoModerationRuleTriggerType;
    (function(AutoModerationRuleTriggerType2) {
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
      AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
    })(AutoModerationRuleTriggerType = exports2.AutoModerationRuleTriggerType || (exports2.AutoModerationRuleTriggerType = {}));
    var AutoModerationRuleKeywordPresetType;
    (function(AutoModerationRuleKeywordPresetType2) {
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
      AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
    })(AutoModerationRuleKeywordPresetType = exports2.AutoModerationRuleKeywordPresetType || (exports2.AutoModerationRuleKeywordPresetType = {}));
    var AutoModerationRuleEventType;
    (function(AutoModerationRuleEventType2) {
      AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
    })(AutoModerationRuleEventType = exports2.AutoModerationRuleEventType || (exports2.AutoModerationRuleEventType = {}));
    var AutoModerationActionType;
    (function(AutoModerationActionType2) {
      AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
      AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
      AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
    })(AutoModerationActionType = exports2.AutoModerationActionType || (exports2.AutoModerationActionType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelFlags = exports2.TextInputStyle = exports2.ButtonStyle = exports2.ComponentType = exports2.AllowedMentionsTypes = exports2.EmbedType = exports2.ThreadMemberFlags = exports2.ThreadAutoArchiveDuration = exports2.OverwriteType = exports2.MessageFlags = exports2.MessageActivityType = exports2.MessageType = exports2.VideoQualityMode = exports2.ChannelType = exports2.SortOrderType = void 0;
    var SortOrderType;
    (function(SortOrderType2) {
      SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
      SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
    })(SortOrderType = exports2.SortOrderType || (exports2.SortOrderType = {}));
    var ChannelType;
    (function(ChannelType2) {
      ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
      ChannelType2[ChannelType2["DM"] = 1] = "DM";
      ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
      ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
      ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
      ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
      ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
      ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
      ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
      ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
      ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
      ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
      ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
      ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
      ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
      ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
    })(ChannelType = exports2.ChannelType || (exports2.ChannelType = {}));
    var VideoQualityMode;
    (function(VideoQualityMode2) {
      VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
      VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
    })(VideoQualityMode = exports2.VideoQualityMode || (exports2.VideoQualityMode = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["Default"] = 0] = "Default";
      MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
      MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
      MessageType2[MessageType2["Call"] = 3] = "Call";
      MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
      MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
      MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
      MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
      MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
      MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
      MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
      MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
      MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
      MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
      MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
      MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
      MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
      MessageType2[MessageType2["Reply"] = 19] = "Reply";
      MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
      MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
      MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
      MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
      MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var MessageActivityType;
    (function(MessageActivityType2) {
      MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
      MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
      MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
      MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
    })(MessageActivityType = exports2.MessageActivityType || (exports2.MessageActivityType = {}));
    var MessageFlags;
    (function(MessageFlags2) {
      MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
      MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
      MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
      MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
      MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
      MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
      MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
      MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
      MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
    })(MessageFlags = exports2.MessageFlags || (exports2.MessageFlags = {}));
    var OverwriteType;
    (function(OverwriteType2) {
      OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
      OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
    })(OverwriteType = exports2.OverwriteType || (exports2.OverwriteType = {}));
    var ThreadAutoArchiveDuration;
    (function(ThreadAutoArchiveDuration2) {
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
      ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
    })(ThreadAutoArchiveDuration = exports2.ThreadAutoArchiveDuration || (exports2.ThreadAutoArchiveDuration = {}));
    var ThreadMemberFlags;
    (function(ThreadMemberFlags2) {
    })(ThreadMemberFlags = exports2.ThreadMemberFlags || (exports2.ThreadMemberFlags = {}));
    var EmbedType;
    (function(EmbedType2) {
      EmbedType2["Rich"] = "rich";
      EmbedType2["Image"] = "image";
      EmbedType2["Video"] = "video";
      EmbedType2["GIFV"] = "gifv";
      EmbedType2["Article"] = "article";
      EmbedType2["Link"] = "link";
      EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
    })(EmbedType = exports2.EmbedType || (exports2.EmbedType = {}));
    var AllowedMentionsTypes;
    (function(AllowedMentionsTypes2) {
      AllowedMentionsTypes2["Everyone"] = "everyone";
      AllowedMentionsTypes2["Role"] = "roles";
      AllowedMentionsTypes2["User"] = "users";
    })(AllowedMentionsTypes = exports2.AllowedMentionsTypes || (exports2.AllowedMentionsTypes = {}));
    var ComponentType;
    (function(ComponentType2) {
      ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
      ComponentType2[ComponentType2["Button"] = 2] = "Button";
      ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
      ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
    })(ComponentType = exports2.ComponentType || (exports2.ComponentType = {}));
    var ButtonStyle;
    (function(ButtonStyle2) {
      ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
      ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
      ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
      ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
      ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
    })(ButtonStyle = exports2.ButtonStyle || (exports2.ButtonStyle = {}));
    var TextInputStyle;
    (function(TextInputStyle2) {
      TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
      TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
    })(TextInputStyle = exports2.TextInputStyle || (exports2.TextInputStyle = {}));
    var ChannelFlags;
    (function(ChannelFlags2) {
      ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
      ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
    })(ChannelFlags = exports2.ChannelFlags || (exports2.ChannelFlags = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/emoji.js
var require_emoji = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ActivityFlags = exports2.ActivityType = exports2.ActivityPlatform = exports2.PresenceUpdateStatus = void 0;
    var PresenceUpdateStatus;
    (function(PresenceUpdateStatus2) {
      PresenceUpdateStatus2["Online"] = "online";
      PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
      PresenceUpdateStatus2["Idle"] = "idle";
      PresenceUpdateStatus2["Invisible"] = "invisible";
      PresenceUpdateStatus2["Offline"] = "offline";
    })(PresenceUpdateStatus = exports2.PresenceUpdateStatus || (exports2.PresenceUpdateStatus = {}));
    var ActivityPlatform;
    (function(ActivityPlatform2) {
      ActivityPlatform2["Desktop"] = "desktop";
      ActivityPlatform2["Xbox"] = "xbox";
      ActivityPlatform2["Samsung"] = "samsung";
      ActivityPlatform2["IOS"] = "ios";
      ActivityPlatform2["Android"] = "android";
      ActivityPlatform2["Embedded"] = "embedded";
      ActivityPlatform2["PS4"] = "ps4";
      ActivityPlatform2["PS5"] = "ps5";
    })(ActivityPlatform = exports2.ActivityPlatform || (exports2.ActivityPlatform = {}));
    var ActivityType;
    (function(ActivityType2) {
      ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
      ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
      ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
      ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
      ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
      ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
    })(ActivityType = exports2.ActivityType || (exports2.ActivityType = {}));
    var ActivityFlags;
    (function(ActivityFlags2) {
      ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
      ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
      ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
      ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
      ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
      ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
      ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
      ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
      ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
    })(ActivityFlags = exports2.ActivityFlags || (exports2.ActivityFlags = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MembershipScreeningFieldType = exports2.GuildWidgetStyle = exports2.IntegrationExpireBehavior = exports2.GuildFeature = exports2.GuildSystemChannelFlags = exports2.GuildHubType = exports2.GuildPremiumTier = exports2.GuildVerificationLevel = exports2.GuildNSFWLevel = exports2.GuildMFALevel = exports2.GuildExplicitContentFilter = exports2.GuildDefaultMessageNotifications = void 0;
    var GuildDefaultMessageNotifications;
    (function(GuildDefaultMessageNotifications2) {
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
      GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
    })(GuildDefaultMessageNotifications = exports2.GuildDefaultMessageNotifications || (exports2.GuildDefaultMessageNotifications = {}));
    var GuildExplicitContentFilter;
    (function(GuildExplicitContentFilter2) {
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
      GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
    })(GuildExplicitContentFilter = exports2.GuildExplicitContentFilter || (exports2.GuildExplicitContentFilter = {}));
    var GuildMFALevel;
    (function(GuildMFALevel2) {
      GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
      GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
    })(GuildMFALevel = exports2.GuildMFALevel || (exports2.GuildMFALevel = {}));
    var GuildNSFWLevel;
    (function(GuildNSFWLevel2) {
      GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
      GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
      GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
      GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
    })(GuildNSFWLevel = exports2.GuildNSFWLevel || (exports2.GuildNSFWLevel = {}));
    var GuildVerificationLevel;
    (function(GuildVerificationLevel2) {
      GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
      GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
      GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
      GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
      GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
    })(GuildVerificationLevel = exports2.GuildVerificationLevel || (exports2.GuildVerificationLevel = {}));
    var GuildPremiumTier;
    (function(GuildPremiumTier2) {
      GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
      GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
      GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
      GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
    })(GuildPremiumTier = exports2.GuildPremiumTier || (exports2.GuildPremiumTier = {}));
    var GuildHubType;
    (function(GuildHubType2) {
      GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
      GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
      GuildHubType2[GuildHubType2["College"] = 2] = "College";
    })(GuildHubType = exports2.GuildHubType || (exports2.GuildHubType = {}));
    var GuildSystemChannelFlags;
    (function(GuildSystemChannelFlags2) {
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
      GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    })(GuildSystemChannelFlags = exports2.GuildSystemChannelFlags || (exports2.GuildSystemChannelFlags = {}));
    var GuildFeature;
    (function(GuildFeature2) {
      GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
      GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
      GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
      GuildFeature2["Banner"] = "BANNER";
      GuildFeature2["Community"] = "COMMUNITY";
      GuildFeature2["Discoverable"] = "DISCOVERABLE";
      GuildFeature2["Featurable"] = "FEATURABLE";
      GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
      GuildFeature2["Hub"] = "HUB";
      GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
      GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
      GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
      GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
      GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
      GuildFeature2["MoreStickers"] = "MORE_STICKERS";
      GuildFeature2["News"] = "NEWS";
      GuildFeature2["Partnered"] = "PARTNERED";
      GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
      GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
      GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
      GuildFeature2["RoleIcons"] = "ROLE_ICONS";
      GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
      GuildFeature2["VanityURL"] = "VANITY_URL";
      GuildFeature2["Verified"] = "VERIFIED";
      GuildFeature2["VIPRegions"] = "VIP_REGIONS";
      GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
    })(GuildFeature = exports2.GuildFeature || (exports2.GuildFeature = {}));
    var IntegrationExpireBehavior;
    (function(IntegrationExpireBehavior2) {
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
      IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
    })(IntegrationExpireBehavior = exports2.IntegrationExpireBehavior || (exports2.IntegrationExpireBehavior = {}));
    var GuildWidgetStyle;
    (function(GuildWidgetStyle2) {
      GuildWidgetStyle2["Shield"] = "shield";
      GuildWidgetStyle2["Banner1"] = "banner1";
      GuildWidgetStyle2["Banner2"] = "banner2";
      GuildWidgetStyle2["Banner3"] = "banner3";
      GuildWidgetStyle2["Banner4"] = "banner4";
    })(GuildWidgetStyle = exports2.GuildWidgetStyle || (exports2.GuildWidgetStyle = {}));
    var MembershipScreeningFieldType;
    (function(MembershipScreeningFieldType2) {
      MembershipScreeningFieldType2["Terms"] = "TERMS";
    })(MembershipScreeningFieldType = exports2.MembershipScreeningFieldType || (exports2.MembershipScreeningFieldType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventStatus = exports2.GuildScheduledEventEntityType = void 0;
    var GuildScheduledEventEntityType;
    (function(GuildScheduledEventEntityType2) {
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
      GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
    })(GuildScheduledEventEntityType = exports2.GuildScheduledEventEntityType || (exports2.GuildScheduledEventEntityType = {}));
    var GuildScheduledEventStatus;
    (function(GuildScheduledEventStatus2) {
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
      GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
    })(GuildScheduledEventStatus = exports2.GuildScheduledEventStatus || (exports2.GuildScheduledEventStatus = {}));
    var GuildScheduledEventPrivacyLevel;
    (function(GuildScheduledEventPrivacyLevel2) {
      GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(GuildScheduledEventPrivacyLevel = exports2.GuildScheduledEventPrivacyLevel || (exports2.GuildScheduledEventPrivacyLevel = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandOptionType = void 0;
    var ApplicationCommandOptionType;
    (function(ApplicationCommandOptionType2) {
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
      ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
    })(ApplicationCommandOptionType = exports2.ApplicationCommandOptionType || (exports2.ApplicationCommandOptionType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_attachment(), exports2);
    __exportStar(require_base(), exports2);
    __exportStar(require_boolean(), exports2);
    __exportStar(require_channel2(), exports2);
    __exportStar(require_integer(), exports2);
    __exportStar(require_mentionable(), exports2);
    __exportStar(require_number(), exports2);
    __exportStar(require_role(), exports2);
    __exportStar(require_shared(), exports2);
    __exportStar(require_string(), exports2);
    __exportStar(require_subcommand(), exports2);
    __exportStar(require_subcommandGroup(), exports2);
    __exportStar(require_user(), exports2);
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.APIApplicationCommandPermissionsConstant = exports2.ApplicationCommandPermissionType = void 0;
    var ApplicationCommandPermissionType;
    (function(ApplicationCommandPermissionType2) {
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
      ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
    })(ApplicationCommandPermissionType = exports2.ApplicationCommandPermissionType || (exports2.ApplicationCommandPermissionType = {}));
    exports2.APIApplicationCommandPermissionsConstant = {
      Everyone: (guildId) => String(guildId),
      AllChannels: (guildId) => String(BigInt(guildId) - 1n)
    };
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ApplicationCommandType = void 0;
    __exportStar(require_chatInput(), exports2);
    __exportStar(require_contextMenu(), exports2);
    __exportStar(require_permissions(), exports2);
    var ApplicationCommandType;
    (function(ApplicationCommandType2) {
      ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
      ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
      ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
    })(ApplicationCommandType = exports2.ApplicationCommandType || (exports2.ApplicationCommandType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js
var require_autocomplete = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/base.js
var require_base2 = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js
var require_messageComponents = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/ping.js
var require_ping = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/ping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/_interactions/responses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InteractionResponseType = exports2.InteractionType = void 0;
    var InteractionType;
    (function(InteractionType2) {
      InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
      InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
      InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
      InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
      InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
    })(InteractionType = exports2.InteractionType || (exports2.InteractionType = {}));
    var InteractionResponseType;
    (function(InteractionResponseType2) {
      InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
      InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
      InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
      InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
      InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
      InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
    })(InteractionResponseType = exports2.InteractionResponseType || (exports2.InteractionResponseType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/interactions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_applicationCommands(), exports2);
    __exportStar(require_autocomplete(), exports2);
    __exportStar(require_base2(), exports2);
    __exportStar(require_messageComponents(), exports2);
    __exportStar(require_modalSubmit(), exports2);
    __exportStar(require_ping(), exports2);
    __exportStar(require_responses(), exports2);
  }
});

// ../../node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InviteTargetType = void 0;
    var InviteTargetType;
    (function(InviteTargetType2) {
      InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
      InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
    })(InviteTargetType = exports2.InviteTargetType || (exports2.InviteTargetType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Scopes = void 0;
    var OAuth2Scopes2;
    (function(OAuth2Scopes3) {
      OAuth2Scopes3["Bot"] = "bot";
      OAuth2Scopes3["Connections"] = "connections";
      OAuth2Scopes3["DMChannelsRead"] = "dm_channels.read";
      OAuth2Scopes3["Email"] = "email";
      OAuth2Scopes3["Identify"] = "identify";
      OAuth2Scopes3["Guilds"] = "guilds";
      OAuth2Scopes3["GuildsJoin"] = "guilds.join";
      OAuth2Scopes3["GuildsMembersRead"] = "guilds.members.read";
      OAuth2Scopes3["GroupDMJoins"] = "gdm.join";
      OAuth2Scopes3["MessagesRead"] = "messages.read";
      OAuth2Scopes3["RPC"] = "rpc";
      OAuth2Scopes3["RPCNotificationsRead"] = "rpc.notifications.read";
      OAuth2Scopes3["WebhookIncoming"] = "webhook.incoming";
      OAuth2Scopes3["Voice"] = "voice";
      OAuth2Scopes3["ApplicationsBuildsUpload"] = "applications.builds.upload";
      OAuth2Scopes3["ApplicationsBuildsRead"] = "applications.builds.read";
      OAuth2Scopes3["ApplicationsStoreUpdate"] = "applications.store.update";
      OAuth2Scopes3["ApplicationsEntitlements"] = "applications.entitlements";
      OAuth2Scopes3["RelationshipsRead"] = "relationships.read";
      OAuth2Scopes3["ActivitiesRead"] = "activities.read";
      OAuth2Scopes3["ActivitiesWrite"] = "activities.write";
      OAuth2Scopes3["ApplicationsCommands"] = "applications.commands";
      OAuth2Scopes3["ApplicationsCommandsUpdate"] = "applications.commands.update";
      OAuth2Scopes3["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
    })(OAuth2Scopes2 = exports2.OAuth2Scopes || (exports2.OAuth2Scopes = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/permissions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StageInstancePrivacyLevel = void 0;
    var StageInstancePrivacyLevel;
    (function(StageInstancePrivacyLevel2) {
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
      StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
    })(StageInstancePrivacyLevel = exports2.StageInstancePrivacyLevel || (exports2.StageInstancePrivacyLevel = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StickerFormatType = exports2.StickerType = void 0;
    var StickerType;
    (function(StickerType2) {
      StickerType2[StickerType2["Standard"] = 1] = "Standard";
      StickerType2[StickerType2["Guild"] = 2] = "Guild";
    })(StickerType = exports2.StickerType || (exports2.StickerType = {}));
    var StickerFormatType;
    (function(StickerFormatType2) {
      StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
      StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
      StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
    })(StickerFormatType = exports2.StickerFormatType || (exports2.StickerFormatType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/teams.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TeamMemberMembershipState = void 0;
    var TeamMemberMembershipState;
    (function(TeamMemberMembershipState2) {
      TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
      TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
    })(TeamMemberMembershipState = exports2.TeamMemberMembershipState || (exports2.TeamMemberMembershipState = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/template.js
var require_template = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/user.js
var require_user2 = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectionVisibility = exports2.ConnectionService = exports2.UserPremiumType = exports2.UserFlags = void 0;
    var UserFlags;
    (function(UserFlags2) {
      UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
      UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
      UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
      UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
      UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
      UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
      UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
      UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
      UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
      UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
      UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
      UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
      UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
      UserFlags2[UserFlags2["Quarantined"] = Math.pow(2, 44)] = "Quarantined";
    })(UserFlags = exports2.UserFlags || (exports2.UserFlags = {}));
    var UserPremiumType;
    (function(UserPremiumType2) {
      UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
      UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
      UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
    })(UserPremiumType = exports2.UserPremiumType || (exports2.UserPremiumType = {}));
    var ConnectionService;
    (function(ConnectionService2) {
      ConnectionService2["BattleNet"] = "battlenet";
      ConnectionService2["eBay"] = "ebay";
      ConnectionService2["EpicGames"] = "epicgames";
      ConnectionService2["Facebook"] = "facebook";
      ConnectionService2["GitHub"] = "github";
      ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
      ConnectionService2["PayPal"] = "paypal";
      ConnectionService2["PlayStationNetwork"] = "playstation";
      ConnectionService2["Reddit"] = "reddit";
      ConnectionService2["RiotGames"] = "riotgames";
      ConnectionService2["Spotify"] = "spotify";
      ConnectionService2["Skype"] = "skype";
      ConnectionService2["Steam"] = "steam";
      ConnectionService2["Twitch"] = "twitch";
      ConnectionService2["Twitter"] = "twitter";
      ConnectionService2["Xbox"] = "xbox";
      ConnectionService2["YouTube"] = "youtube";
    })(ConnectionService = exports2.ConnectionService || (exports2.ConnectionService = {}));
    var ConnectionVisibility;
    (function(ConnectionVisibility2) {
      ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
      ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
    })(ConnectionVisibility = exports2.ConnectionVisibility || (exports2.ConnectionVisibility = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/voice.js
var require_voice = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebhookType = void 0;
    var WebhookType;
    (function(WebhookType2) {
      WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
      WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
      WebhookType2[WebhookType2["Application"] = 3] = "Application";
    })(WebhookType = exports2.WebhookType || (exports2.WebhookType = {}));
  }
});

// ../../node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS({
  "../../node_modules/discord-api-types/payloads/v10/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_common2(), exports2);
    __exportStar(require_application(), exports2);
    __exportStar(require_auditLog(), exports2);
    __exportStar(require_autoModeration(), exports2);
    __exportStar(require_channel(), exports2);
    __exportStar(require_emoji(), exports2);
    __exportStar(require_gateway(), exports2);
    __exportStar(require_guild(), exports2);
    __exportStar(require_guildScheduledEvent(), exports2);
    __exportStar(require_interactions(), exports2);
    __exportStar(require_invite(), exports2);
    __exportStar(require_oauth2(), exports2);
    __exportStar(require_permissions2(), exports2);
    __exportStar(require_stageInstance(), exports2);
    __exportStar(require_sticker(), exports2);
    __exportStar(require_teams(), exports2);
    __exportStar(require_template(), exports2);
    __exportStar(require_user2(), exports2);
    __exportStar(require_voice(), exports2);
    __exportStar(require_webhook(), exports2);
  }
});

// ../../node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS({
  "../../node_modules/discord-api-types/rest/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Locale = exports2.RESTJSONErrorCodes = void 0;
    var RESTJSONErrorCodes;
    (function(RESTJSONErrorCodes2) {
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 13e4] = "APIResourceOverloaded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 18e4] = "CannotUpdateAFinishedEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 2e5] = "MessageWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
      RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 24e4] = "MessageBlockedByHarmfulLinksFilter";
    })(RESTJSONErrorCodes = exports2.RESTJSONErrorCodes || (exports2.RESTJSONErrorCodes = {}));
    var Locale;
    (function(Locale2) {
      Locale2["EnglishUS"] = "en-US";
      Locale2["EnglishGB"] = "en-GB";
      Locale2["Bulgarian"] = "bg";
      Locale2["ChineseCN"] = "zh-CN";
      Locale2["ChineseTW"] = "zh-TW";
      Locale2["Croatian"] = "hr";
      Locale2["Czech"] = "cs";
      Locale2["Danish"] = "da";
      Locale2["Dutch"] = "nl";
      Locale2["Finnish"] = "fi";
      Locale2["French"] = "fr";
      Locale2["German"] = "de";
      Locale2["Greek"] = "el";
      Locale2["Hindi"] = "hi";
      Locale2["Hungarian"] = "hu";
      Locale2["Italian"] = "it";
      Locale2["Japanese"] = "ja";
      Locale2["Korean"] = "ko";
      Locale2["Lithuanian"] = "lt";
      Locale2["Norwegian"] = "no";
      Locale2["Polish"] = "pl";
      Locale2["PortugueseBR"] = "pt-BR";
      Locale2["Romanian"] = "ro";
      Locale2["Russian"] = "ru";
      Locale2["SpanishES"] = "es-ES";
      Locale2["Swedish"] = "sv-SE";
      Locale2["Thai"] = "th";
      Locale2["Turkish"] = "tr";
      Locale2["Ukrainian"] = "uk";
      Locale2["Vietnamese"] = "vi";
    })(Locale = exports2.Locale || (exports2.Locale = {}));
  }
});

// ../../node_modules/discord-api-types/rest/v10/auditLog.js
var require_auditLog2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/auditLog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/autoModeration.js
var require_autoModeration2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/autoModeration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/channel.js
var require_channel3 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/emoji.js
var require_emoji2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/emoji.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/gateway.js
var require_gateway2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/gateway.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/guild.js
var require_guild2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/guild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/guildScheduledEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/interactions.js
var require_interactions2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/interactions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/invite.js
var require_invite2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/invite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/oauth2.js
var require_oauth22 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/oauth2.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/stageInstance.js
var require_stageInstance2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/stageInstance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/sticker.js
var require_sticker2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/sticker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/template.js
var require_template2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/template.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/user.js
var require_user3 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/user.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/voice.js
var require_voice2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/voice.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/webhook.js
var require_webhook2 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/webhook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS({
  "../../node_modules/discord-api-types/rest/v10/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OAuth2Routes = exports2.RouteBases = exports2.ImageFormat = exports2.CDNRoutes = exports2.StickerPackApplicationId = exports2.Routes = exports2.APIVersion = void 0;
    __exportStar(require_common3(), exports2);
    __exportStar(require_auditLog2(), exports2);
    __exportStar(require_autoModeration2(), exports2);
    __exportStar(require_channel3(), exports2);
    __exportStar(require_emoji2(), exports2);
    __exportStar(require_gateway2(), exports2);
    __exportStar(require_guild2(), exports2);
    __exportStar(require_guildScheduledEvent2(), exports2);
    __exportStar(require_interactions2(), exports2);
    __exportStar(require_invite2(), exports2);
    __exportStar(require_oauth22(), exports2);
    __exportStar(require_stageInstance2(), exports2);
    __exportStar(require_sticker2(), exports2);
    __exportStar(require_template2(), exports2);
    __exportStar(require_user3(), exports2);
    __exportStar(require_voice2(), exports2);
    __exportStar(require_webhook2(), exports2);
    exports2.APIVersion = "10";
    exports2.Routes = {
      guildAutoModerationRules(guildId) {
        return `/guilds/${guildId}/auto-moderation/rules`;
      },
      guildAutoModerationRule(guildId, ruleId) {
        return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
      },
      guildAuditLog(guildId) {
        return `/guilds/${guildId}/audit-logs`;
      },
      channel(channelId) {
        return `/channels/${channelId}`;
      },
      channelMessages(channelId) {
        return `/channels/${channelId}/messages`;
      },
      channelMessage(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}`;
      },
      channelMessageCrosspost(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/crosspost`;
      },
      channelMessageOwnReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
      },
      channelMessageUserReaction(channelId, messageId, emoji, userId) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
      },
      channelMessageReaction(channelId, messageId, emoji) {
        return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
      },
      channelMessageAllReactions(channelId, messageId) {
        return `/channels/${channelId}/messages/${messageId}/reactions`;
      },
      channelBulkDelete(channelId) {
        return `/channels/${channelId}/messages/bulk-delete`;
      },
      channelPermission(channelId, overwriteId) {
        return `/channels/${channelId}/permissions/${overwriteId}`;
      },
      channelInvites(channelId) {
        return `/channels/${channelId}/invites`;
      },
      channelFollowers(channelId) {
        return `/channels/${channelId}/followers`;
      },
      channelTyping(channelId) {
        return `/channels/${channelId}/typing`;
      },
      channelPins(channelId) {
        return `/channels/${channelId}/pins`;
      },
      channelPin(channelId, messageId) {
        return `/channels/${channelId}/pins/${messageId}`;
      },
      channelRecipient(channelId, userId) {
        return `/channels/${channelId}/recipients/${userId}`;
      },
      guildEmojis(guildId) {
        return `/guilds/${guildId}/emojis`;
      },
      guildEmoji(guildId, emojiId) {
        return `/guilds/${guildId}/emojis/${emojiId}`;
      },
      guilds() {
        return "/guilds";
      },
      guild(guildId) {
        return `/guilds/${guildId}`;
      },
      guildPreview(guildId) {
        return `/guilds/${guildId}/preview`;
      },
      guildChannels(guildId) {
        return `/guilds/${guildId}/channels`;
      },
      guildMember(guildId, userId = "@me") {
        return `/guilds/${guildId}/members/${userId}`;
      },
      guildMembers(guildId) {
        return `/guilds/${guildId}/members`;
      },
      guildMembersSearch(guildId) {
        return `/guilds/${guildId}/members/search`;
      },
      guildCurrentMemberNickname(guildId) {
        return `/guilds/${guildId}/members/@me/nick`;
      },
      guildMemberRole(guildId, memberId, roleId) {
        return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
      },
      guildMFA(guildId) {
        return `/guilds/${guildId}/mfa`;
      },
      guildBans(guildId) {
        return `/guilds/${guildId}/bans`;
      },
      guildBan(guildId, userId) {
        return `/guilds/${guildId}/bans/${userId}`;
      },
      guildRoles(guildId) {
        return `/guilds/${guildId}/roles`;
      },
      guildRole(guildId, roleId) {
        return `/guilds/${guildId}/roles/${roleId}`;
      },
      guildPrune(guildId) {
        return `/guilds/${guildId}/prune`;
      },
      guildVoiceRegions(guildId) {
        return `/guilds/${guildId}/regions`;
      },
      guildInvites(guildId) {
        return `/guilds/${guildId}/invites`;
      },
      guildIntegrations(guildId) {
        return `/guilds/${guildId}/integrations`;
      },
      guildIntegration(guildId, integrationId) {
        return `/guilds/${guildId}/integrations/${integrationId}`;
      },
      guildWidgetSettings(guildId) {
        return `/guilds/${guildId}/widget`;
      },
      guildWidgetJSON(guildId) {
        return `/guilds/${guildId}/widget.json`;
      },
      guildVanityUrl(guildId) {
        return `/guilds/${guildId}/vanity-url`;
      },
      guildWidgetImage(guildId) {
        return `/guilds/${guildId}/widget.png`;
      },
      invite(code) {
        return `/invites/${code}`;
      },
      template(code) {
        return `/guilds/templates/${code}`;
      },
      guildTemplates(guildId) {
        return `/guilds/${guildId}/templates`;
      },
      guildTemplate(guildId, code) {
        return `/guilds/${guildId}/templates/${code}`;
      },
      threads(parentId, messageId) {
        const parts = ["", "channels", parentId];
        if (messageId)
          parts.push("messages", messageId);
        parts.push("threads");
        return parts.join("/");
      },
      guildActiveThreads(guildId) {
        return `/guilds/${guildId}/threads/active`;
      },
      channelThreads(channelId, archivedStatus) {
        return `/channels/${channelId}/threads/archived/${archivedStatus}`;
      },
      channelJoinedArchivedThreads(channelId) {
        return `/channels/${channelId}/users/@me/threads/archived/private`;
      },
      threadMembers(threadId, userId) {
        const parts = ["", "channels", threadId, "thread-members"];
        if (userId)
          parts.push(userId);
        return parts.join("/");
      },
      user(userId = "@me") {
        return `/users/${userId}`;
      },
      userGuilds() {
        return `/users/@me/guilds`;
      },
      userGuildMember(guildId) {
        return `/users/@me/guilds/${guildId}/member`;
      },
      userGuild(guildId) {
        return `/users/@me/guilds/${guildId}`;
      },
      userChannels() {
        return `/users/@me/channels`;
      },
      userConnections() {
        return `/users/@me/connections`;
      },
      voiceRegions() {
        return `/voice/regions`;
      },
      channelWebhooks(channelId) {
        return `/channels/${channelId}/webhooks`;
      },
      guildWebhooks(guildId) {
        return `/guilds/${guildId}/webhooks`;
      },
      webhook(webhookId, webhookToken) {
        const parts = ["", "webhooks", webhookId];
        if (webhookToken)
          parts.push(webhookToken);
        return parts.join("/");
      },
      webhookMessage(webhookId, webhookToken, messageId = "@original") {
        return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
      },
      webhookPlatform(webhookId, webhookToken, platform) {
        return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
      },
      gateway() {
        return `/gateway`;
      },
      gatewayBot() {
        return `/gateway/bot`;
      },
      oauth2CurrentApplication() {
        return `/oauth2/applications/@me`;
      },
      oauth2CurrentAuthorization() {
        return `/oauth2/@me`;
      },
      oauth2Authorization() {
        return `/oauth2/authorize`;
      },
      oauth2TokenExchange() {
        return `/oauth2/token`;
      },
      oauth2TokenRevocation() {
        return `/oauth2/token/revoke`;
      },
      applicationCommands(applicationId) {
        return `/applications/${applicationId}/commands`;
      },
      applicationCommand(applicationId, commandId) {
        return `/applications/${applicationId}/commands/${commandId}`;
      },
      applicationGuildCommands(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands`;
      },
      applicationGuildCommand(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
      },
      interactionCallback(interactionId, interactionToken) {
        return `/interactions/${interactionId}/${interactionToken}/callback`;
      },
      guildMemberVerification(guildId) {
        return `/guilds/${guildId}/member-verification`;
      },
      guildVoiceState(guildId, userId = "@me") {
        return `/guilds/${guildId}/voice-states/${userId}`;
      },
      guildApplicationCommandsPermissions(applicationId, guildId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
      },
      applicationCommandPermissions(applicationId, guildId, commandId) {
        return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
      },
      guildWelcomeScreen(guildId) {
        return `/guilds/${guildId}/welcome-screen`;
      },
      stageInstances() {
        return `/stage-instances`;
      },
      stageInstance(channelId) {
        return `/stage-instances/${channelId}`;
      },
      sticker(stickerId) {
        return `/stickers/${stickerId}`;
      },
      nitroStickerPacks() {
        return "/sticker-packs";
      },
      guildStickers(guildId) {
        return `/guilds/${guildId}/stickers`;
      },
      guildSticker(guildId, stickerId) {
        return `/guilds/${guildId}/stickers/${stickerId}`;
      },
      guildScheduledEvents(guildId) {
        return `/guilds/${guildId}/scheduled-events`;
      },
      guildScheduledEvent(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
      },
      guildScheduledEventUsers(guildId, guildScheduledEventId) {
        return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
      }
    };
    exports2.StickerPackApplicationId = "710982414301790216";
    exports2.CDNRoutes = {
      emoji(emojiId, format) {
        return `/emojis/${emojiId}.${format}`;
      },
      guildIcon(guildId, guildIcon, format) {
        return `icons/${guildId}/${guildIcon}.${format}`;
      },
      guildSplash(guildId, guildSplash, format) {
        return `/splashes/${guildId}/${guildSplash}.${format}`;
      },
      guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
        return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
      },
      guildBanner(guildId, guildBanner, format) {
        return `/banners/${guildId}/${guildBanner}.${format}`;
      },
      userBanner(userId, userBanner, format) {
        return `/banners/${userId}/${userBanner}.${format}`;
      },
      defaultUserAvatar(userDiscriminator) {
        return `/embed/avatars/${userDiscriminator}.png`;
      },
      userAvatar(userId, userAvatar, format) {
        return `/avatars/${userId}/${userAvatar}.${format}`;
      },
      guildMemberAvatar(guildId, userId, memberAvatar, format) {
        return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
      },
      applicationIcon(applicationId, applicationIcon, format) {
        return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
      },
      applicationCover(applicationId, applicationCoverImage, format) {
        return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
      },
      applicationAsset(applicationId, applicationAssetId, format) {
        return `/app-icons/${applicationId}/${applicationAssetId}.${format}`;
      },
      achievementIcon(applicationId, achievementId, achievementIconHash, format) {
        return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
      },
      stickerPackBanner(stickerPackBannerAssetId, format) {
        return `/app-assets/${exports2.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
      },
      teamIcon(teamId, teamIcon, format) {
        return `/team-icons/${teamId}/${teamIcon}.${format}`;
      },
      sticker(stickerId, format) {
        return `/stickers/${stickerId}.${format}`;
      },
      roleIcon(roleId, roleIcon, format) {
        return `/role-icons/${roleId}/${roleIcon}.${format}`;
      },
      guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
        return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
      },
      guildMemberBanner(guildId, userId, guildMemberBanner, format) {
        return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
      }
    };
    var ImageFormat;
    (function(ImageFormat2) {
      ImageFormat2["JPEG"] = "jpeg";
      ImageFormat2["PNG"] = "png";
      ImageFormat2["WebP"] = "webp";
      ImageFormat2["GIF"] = "gif";
      ImageFormat2["Lottie"] = "json";
    })(ImageFormat = exports2.ImageFormat || (exports2.ImageFormat = {}));
    exports2.RouteBases = {
      api: `https://discord.com/api/v${exports2.APIVersion}`,
      cdn: "https://cdn.discordapp.com",
      invite: "https://discord.gg",
      template: "https://discord.new",
      gift: "https://discord.gift",
      scheduledEvent: "https://discord.com/events"
    };
    Object.freeze(exports2.RouteBases);
    exports2.OAuth2Routes = {
      authorizationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2Authorization()}`,
      tokenURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenExchange()}`,
      tokenRevocationURL: `${exports2.RouteBases.api}${exports2.Routes.oauth2TokenRevocation()}`
    };
    Object.freeze(exports2.OAuth2Routes);
  }
});

// ../../node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS({
  "../../node_modules/discord-api-types/rpc/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RPCCloseEventCodes = exports2.RPCErrorCodes = void 0;
    var RPCErrorCodes;
    (function(RPCErrorCodes2) {
      RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1e3] = "UnknownError";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4e3] = "InvalidPayload";
      RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
      RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
      RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
      RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
      RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
      RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
      RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
      RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
      RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
      RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5e3] = "OAuth2Error";
      RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
      RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
      RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
    })(RPCErrorCodes = exports2.RPCErrorCodes || (exports2.RPCErrorCodes = {}));
    var RPCCloseEventCodes;
    (function(RPCCloseEventCodes2) {
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4e3] = "InvalidClientId";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
      RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
      RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
      RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
    })(RPCCloseEventCodes = exports2.RPCCloseEventCodes || (exports2.RPCCloseEventCodes = {}));
  }
});

// ../../node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS({
  "../../node_modules/discord-api-types/rpc/v10.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_common4(), exports2);
  }
});

// ../../node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS({
  "../../node_modules/discord-api-types/utils/v10.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isContextMenuApplicationCommandInteraction = exports2.isChatInputApplicationCommandInteraction = exports2.isMessageComponentSelectMenuInteraction = exports2.isMessageComponentButtonInteraction = exports2.isMessageComponentInteraction = exports2.isInteractionButton = exports2.isLinkButton = exports2.isMessageComponentGuildInteraction = exports2.isMessageComponentDMInteraction = exports2.isApplicationCommandGuildInteraction = exports2.isApplicationCommandDMInteraction = exports2.isGuildInteraction = exports2.isDMInteraction = void 0;
    var index_1 = require_v102();
    function isDMInteraction(interaction) {
      return Reflect.has(interaction, "user");
    }
    exports2.isDMInteraction = isDMInteraction;
    function isGuildInteraction(interaction) {
      return Reflect.has(interaction, "guild_id");
    }
    exports2.isGuildInteraction = isGuildInteraction;
    function isApplicationCommandDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    exports2.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
    function isApplicationCommandGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    exports2.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
    function isMessageComponentDMInteraction(interaction) {
      return isDMInteraction(interaction);
    }
    exports2.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
    function isMessageComponentGuildInteraction(interaction) {
      return isGuildInteraction(interaction);
    }
    exports2.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
    function isLinkButton(component) {
      return component.style === index_1.ButtonStyle.Link;
    }
    exports2.isLinkButton = isLinkButton;
    function isInteractionButton(component) {
      return component.style !== index_1.ButtonStyle.Link;
    }
    exports2.isInteractionButton = isInteractionButton;
    function isMessageComponentInteraction(interaction) {
      return interaction.type === index_1.InteractionType.MessageComponent;
    }
    exports2.isMessageComponentInteraction = isMessageComponentInteraction;
    function isMessageComponentButtonInteraction(interaction) {
      return interaction.data.component_type === index_1.ComponentType.Button;
    }
    exports2.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
    function isMessageComponentSelectMenuInteraction(interaction) {
      return interaction.data.component_type === index_1.ComponentType.SelectMenu;
    }
    exports2.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
    function isChatInputApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
    }
    exports2.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
    function isContextMenuApplicationCommandInteraction(interaction) {
      return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
    }
    exports2.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
  }
});

// ../../node_modules/discord-api-types/v10.js
var require_v106 = __commonJS({
  "../../node_modules/discord-api-types/v10.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Utils = void 0;
    __exportStar(require_v10(), exports2);
    __exportStar(require_globals(), exports2);
    __exportStar(require_v102(), exports2);
    __exportStar(require_v103(), exports2);
    __exportStar(require_v104(), exports2);
    exports2.Utils = require_v105();
  }
});

// ../../node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "../../node_modules/undici/lib/core/symbols.js"(exports2, module2) {
    module2.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol("destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelinig"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors")
    };
  }
});

// ../../node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "../../node_modules/undici/lib/core/errors.js"(exports2, module2) {
    "use strict";
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    module2.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError
    };
  }
});

// ../../node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "../../node_modules/undici/lib/core/util.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = require("http");
    var stream = require("stream");
    var net = require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob } = require("buffer");
    var nodeUtil = require("util");
    var { stringify: stringify2 } = require("querystring");
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj.pipe === "function";
    }
    function isBlobLike(object) {
      return Blob && object instanceof Blob || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify2(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("invalid url");
      }
      if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
        throw new InvalidArgumentError("invalid port");
      }
      if (url.path != null && typeof url.path !== "string") {
        throw new InvalidArgumentError("invalid path");
      }
      if (url.pathname != null && typeof url.pathname !== "string") {
        throw new InvalidArgumentError("invalid pathname");
      }
      if (url.hostname != null && typeof url.hostname !== "string") {
        throw new InvalidArgumentError("invalid hostname");
      }
      if (url.origin != null && typeof url.origin !== "string") {
        throw new InvalidArgumentError("invalid origin");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("invalid protocol");
      }
      if (!(url instanceof URL)) {
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(origin + path);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substr(1, idx2 - 1);
      }
      const idx = host.indexOf(":");
      if (idx === -1)
        return host;
      return host.substr(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (!isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function parseHeaders(headers, obj = {}) {
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1];
          } else {
            obj[key] = headers[i + 1].toString();
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString());
        }
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      return headers.map((header) => header.toString());
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(iterable);
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(chunk) {
      return chunk && chunk.constructor && chunk.constructor.name === "FormData";
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module2.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL
    };
  }
});

// ../../node_modules/busboy/lib/utils.js
var require_utils = __commonJS({
  "../../node_modules/busboy/lib/utils.js"(exports2, module2) {
    "use strict";
    function parseContentType(str) {
      if (str.length === 0)
        return;
      const params = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 47 || i === 0)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      const type = str.slice(0, i).toLowerCase();
      const subtypeStart = ++i;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (i === subtypeStart)
            return;
          if (parseContentTypeParams(str, i, params) === void 0)
            return;
          break;
        }
      }
      if (i === subtypeStart)
        return;
      const subtype = str.slice(subtypeStart, i).toLowerCase();
      return { type, subtype, params };
    }
    function parseContentTypeParams(str, i, params) {
      while (i < str.length) {
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          break;
        if (str.charCodeAt(i++) !== 59)
          return;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          return;
        let name;
        const nameStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (code !== 61)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        name = str.slice(nameStart, i);
        ++i;
        if (i === str.length)
          return;
        let value = "";
        let valueStart;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        name = name.toLowerCase();
        if (params[name] === void 0)
          params[name] = value;
      }
      return params;
    }
    function parseDisposition(str, defDecoder) {
      if (str.length === 0)
        return;
      const params = /* @__PURE__ */ Object.create(null);
      let i = 0;
      for (; i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (parseDispositionParams(str, i, params, defDecoder) === void 0)
            return;
          break;
        }
      }
      const type = str.slice(0, i).toLowerCase();
      return { type, params };
    }
    function parseDispositionParams(str, i, params, defDecoder) {
      while (i < str.length) {
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          break;
        if (str.charCodeAt(i++) !== 59)
          return;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code !== 32 && code !== 9)
            break;
        }
        if (i === str.length)
          return;
        let name;
        const nameStart = i;
        for (; i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (code === 61)
              break;
            return;
          }
        }
        if (i === str.length)
          return;
        let value = "";
        let valueStart;
        let charset;
        name = str.slice(nameStart, i);
        if (name.charCodeAt(name.length - 1) === 42) {
          const charsetStart = ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (CHARSET[code] !== 1) {
              if (code !== 39)
                return;
              break;
            }
          }
          if (i === str.length)
            return;
          charset = str.slice(charsetStart, i);
          ++i;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 39)
              break;
          }
          if (i === str.length)
            return;
          ++i;
          if (i === str.length)
            return;
          valueStart = i;
          let encode = 0;
          for (; i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (EXTENDED_VALUE[code] !== 1) {
              if (code === 37) {
                let hexUpper;
                let hexLower;
                if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                  const byteVal = (hexUpper << 4) + hexLower;
                  value += str.slice(valueStart, i);
                  value += String.fromCharCode(byteVal);
                  i += 2;
                  valueStart = i + 1;
                  if (byteVal >= 128)
                    encode = 2;
                  else if (encode === 0)
                    encode = 1;
                  continue;
                }
                return;
              }
              break;
            }
          }
          value += str.slice(valueStart, i);
          value = convertToUTF8(value, charset, encode);
          if (value === void 0)
            return;
        } else {
          ++i;
          if (i === str.length)
            return;
          if (str.charCodeAt(i) === 34) {
            valueStart = ++i;
            let escaping = false;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (code === 92) {
                if (escaping) {
                  valueStart = i;
                  escaping = false;
                } else {
                  value += str.slice(valueStart, i);
                  escaping = true;
                }
                continue;
              }
              if (code === 34) {
                if (escaping) {
                  valueStart = i;
                  escaping = false;
                  continue;
                }
                value += str.slice(valueStart, i);
                break;
              }
              if (escaping) {
                valueStart = i - 1;
                escaping = false;
              }
              if (QDTEXT[code] !== 1)
                return;
            }
            if (i === str.length)
              return;
            ++i;
          } else {
            valueStart = i;
            for (; i < str.length; ++i) {
              const code = str.charCodeAt(i);
              if (TOKEN[code] !== 1) {
                if (i === valueStart)
                  return;
                break;
              }
            }
            value = str.slice(valueStart, i);
          }
          value = defDecoder(value, 2);
          if (value === void 0)
            return;
        }
        name = name.toLowerCase();
        if (params[name] === void 0)
          params[name] = value;
      }
      return params;
    }
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string") {
          if (hint < 2)
            return data;
          data = Buffer.from(data, "latin1");
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          return data;
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        return data.base64Slice(0, data.length);
      },
      other: (data, hint) => {
        if (data.length === 0)
          return "";
        if (typeof data === "string")
          data = Buffer.from(data, "latin1");
        try {
          const decoder = new TextDecoder(exports2);
          return decoder.decode(data);
        } catch {
        }
      }
    };
    function convertToUTF8(data, charset, hint) {
      const decode = getDecoder(charset);
      if (decode)
        return decode(data, hint);
    }
    function basename(path) {
      if (typeof path !== "string")
        return "";
      for (let i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    }
    var TOKEN = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var QDTEXT = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    var CHARSET = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var EXTENDED_VALUE = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var HEX_VALUES = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    module2.exports = {
      basename,
      convertToUTF8,
      getDecoder,
      parseContentType,
      parseDisposition
    };
  }
});

// ../../node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS({
  "../../node_modules/streamsearch/lib/sbmh.js"(exports2, module2) {
    "use strict";
    function memcmp(buf1, pos1, buf2, pos2, num) {
      for (let i = 0; i < num; ++i) {
        if (buf1[pos1 + i] !== buf2[pos2 + i])
          return false;
      }
      return true;
    }
    var SBMH = class {
      constructor(needle, cb) {
        if (typeof cb !== "function")
          throw new Error("Missing match callback");
        if (typeof needle === "string")
          needle = Buffer.from(needle);
        else if (!Buffer.isBuffer(needle))
          throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
        const needleLen = needle.length;
        this.maxMatches = Infinity;
        this.matches = 0;
        this._cb = cb;
        this._lookbehindSize = 0;
        this._needle = needle;
        this._bufPos = 0;
        this._lookbehind = Buffer.allocUnsafe(needleLen);
        this._occ = [
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen,
          needleLen
        ];
        if (needleLen > 1) {
          for (let i = 0; i < needleLen - 1; ++i)
            this._occ[needle[i]] = needleLen - 1 - i;
        }
      }
      reset() {
        this.matches = 0;
        this._lookbehindSize = 0;
        this._bufPos = 0;
      }
      push(chunk, pos) {
        let result;
        if (!Buffer.isBuffer(chunk))
          chunk = Buffer.from(chunk, "latin1");
        const chunkLen = chunk.length;
        this._bufPos = pos || 0;
        while (result !== chunkLen && this.matches < this.maxMatches)
          result = feed(this, chunk);
        return result;
      }
      destroy() {
        const lbSize = this._lookbehindSize;
        if (lbSize)
          this._cb(false, this._lookbehind, 0, lbSize, false);
        this.reset();
      }
    };
    function feed(self2, data) {
      const len = data.length;
      const needle = self2._needle;
      const needleLen = needle.length;
      let pos = -self2._lookbehindSize;
      const lastNeedleCharPos = needleLen - 1;
      const lastNeedleChar = needle[lastNeedleCharPos];
      const end = len - needleLen;
      const occ = self2._occ;
      const lookbehind = self2._lookbehind;
      if (pos < 0) {
        while (pos < 0 && pos <= end) {
          const nextPos = pos + lastNeedleCharPos;
          const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
          if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
            self2._lookbehindSize = 0;
            ++self2.matches;
            if (pos > -self2._lookbehindSize)
              self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
            else
              self2._cb(true, void 0, 0, 0, true);
            return self2._bufPos = pos + needleLen;
          }
          pos += occ[ch];
        }
        while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
          ++pos;
        if (pos < 0) {
          const bytesToCutOff = self2._lookbehindSize + pos;
          if (bytesToCutOff > 0) {
            self2._cb(false, lookbehind, 0, bytesToCutOff, false);
          }
          self2._lookbehindSize -= bytesToCutOff;
          lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
          lookbehind.set(data, self2._lookbehindSize);
          self2._lookbehindSize += len;
          self2._bufPos = len;
          return len;
        }
        self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
        self2._lookbehindSize = 0;
      }
      pos += self2._bufPos;
      const firstNeedleChar = needle[0];
      while (pos <= end) {
        const ch = data[pos + lastNeedleCharPos];
        if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
          ++self2.matches;
          if (pos > 0)
            self2._cb(true, data, self2._bufPos, pos, true);
          else
            self2._cb(true, void 0, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < len) {
        if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
          ++pos;
          continue;
        }
        data.copy(lookbehind, 0, pos, len);
        self2._lookbehindSize = len - pos;
        break;
      }
      if (pos > 0)
        self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
      self2._bufPos = len;
      return len;
    }
    function matchNeedle(self2, data, pos, len) {
      const lb = self2._lookbehind;
      const lbSize = self2._lookbehindSize;
      const needle = self2._needle;
      for (let i = 0; i < len; ++i, ++pos) {
        const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
        if (ch !== needle[i])
          return false;
      }
      return true;
    }
    module2.exports = SBMH;
  }
});

// ../../node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "../../node_modules/busboy/lib/types/multipart.js"(exports2, module2) {
    "use strict";
    var { Readable, Writable } = require("stream");
    var StreamSearch = require_sbmh();
    var {
      basename,
      convertToUTF8,
      getDecoder,
      parseContentType,
      parseDisposition
    } = require_utils();
    var BUF_CRLF = Buffer.from("\r\n");
    var BUF_CR = Buffer.from("\r");
    var BUF_DASH = Buffer.from("-");
    function noop() {
    }
    var MAX_HEADER_PAIRS = 2e3;
    var MAX_HEADER_SIZE = 16 * 1024;
    var HPARSER_NAME = 0;
    var HPARSER_PRE_OWS = 1;
    var HPARSER_VALUE = 2;
    var HeaderParser = class {
      constructor(cb) {
        this.header = /* @__PURE__ */ Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
        this.cb = cb;
      }
      reset() {
        this.header = /* @__PURE__ */ Object.create(null);
        this.pairCount = 0;
        this.byteCount = 0;
        this.state = HPARSER_NAME;
        this.name = "";
        this.value = "";
        this.crlf = 0;
      }
      push(chunk, pos, end) {
        let start = pos;
        while (pos < end) {
          switch (this.state) {
            case HPARSER_NAME: {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (TOKEN[code] !== 1) {
                  if (code !== 58)
                    return -1;
                  this.name += chunk.latin1Slice(start, pos);
                  if (this.name.length === 0)
                    return -1;
                  ++pos;
                  done = true;
                  this.state = HPARSER_PRE_OWS;
                  break;
                }
              }
              if (!done) {
                this.name += chunk.latin1Slice(start, pos);
                break;
              }
            }
            case HPARSER_PRE_OWS: {
              let done = false;
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code !== 32 && code !== 9) {
                  start = pos;
                  done = true;
                  this.state = HPARSER_VALUE;
                  break;
                }
              }
              if (!done)
                break;
            }
            case HPARSER_VALUE:
              switch (this.crlf) {
                case 0:
                  for (; pos < end; ++pos) {
                    if (this.byteCount === MAX_HEADER_SIZE)
                      return -1;
                    ++this.byteCount;
                    const code = chunk[pos];
                    if (FIELD_VCHAR[code] !== 1) {
                      if (code !== 13)
                        return -1;
                      ++this.crlf;
                      break;
                    }
                  }
                  this.value += chunk.latin1Slice(start, pos++);
                  break;
                case 1:
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10)
                    return -1;
                  ++this.crlf;
                  break;
                case 2: {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (code === 32 || code === 9) {
                    start = pos;
                    this.crlf = 0;
                  } else {
                    if (++this.pairCount < MAX_HEADER_PAIRS) {
                      this.name = this.name.toLowerCase();
                      if (this.header[this.name] === void 0)
                        this.header[this.name] = [this.value];
                      else
                        this.header[this.name].push(this.value);
                    }
                    if (code === 13) {
                      ++this.crlf;
                      ++pos;
                    } else {
                      start = pos;
                      this.crlf = 0;
                      this.state = HPARSER_NAME;
                      this.name = "";
                      this.value = "";
                    }
                  }
                  break;
                }
                case 3: {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  if (chunk[pos++] !== 10)
                    return -1;
                  const header = this.header;
                  this.reset();
                  this.cb(header);
                  return pos;
                }
              }
              break;
          }
        }
        return pos;
      }
    };
    var FileStream = class extends Readable {
      constructor(opts, owner) {
        super(opts);
        this.truncated = false;
        this._readcb = null;
        this.once("end", () => {
          this._read();
          if (--owner._fileEndsLeft === 0 && owner._finalcb) {
            const cb = owner._finalcb;
            owner._finalcb = null;
            process.nextTick(cb);
          }
        });
      }
      _read(n) {
        const cb = this._readcb;
        if (cb) {
          this._readcb = null;
          cb();
        }
      }
    };
    var ignoreData = {
      push: (chunk, pos) => {
      },
      destroy: () => {
      }
    };
    function callAndUnsetCb(self2, err) {
      const cb = self2._writecb;
      self2._writecb = null;
      if (err)
        self2.destroy(err);
      else if (cb)
        cb();
    }
    function nullDecoder(val, hint) {
      return val;
    }
    var Multipart = class extends Writable {
      constructor(cfg) {
        const streamOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
        };
        super(streamOpts);
        if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
          throw new Error("Multipart: Boundary not found");
        const boundary = cfg.conType.params.boundary;
        const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
        const defCharset = cfg.defCharset || "utf8";
        const preservePath = cfg.preservePath;
        const fileOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
        };
        const limits = cfg.limits;
        const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
        const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
        const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
        let parts = -1;
        let fields = 0;
        let files = 0;
        let skipPart = false;
        this._fileEndsLeft = 0;
        this._fileStream = void 0;
        this._complete = false;
        let fileSize = 0;
        let field;
        let fieldSize = 0;
        let partCharset;
        let partEncoding;
        let partType;
        let partName;
        let partTruncated = false;
        let hitFilesLimit = false;
        let hitFieldsLimit = false;
        this._hparser = null;
        const hparser = new HeaderParser((header) => {
          this._hparser = null;
          skipPart = false;
          partType = "text/plain";
          partCharset = defCharset;
          partEncoding = "7bit";
          partName = void 0;
          partTruncated = false;
          let filename;
          if (!header["content-disposition"]) {
            skipPart = true;
            return;
          }
          const disp = parseDisposition(
            header["content-disposition"][0],
            paramDecoder
          );
          if (!disp || disp.type !== "form-data") {
            skipPart = true;
            return;
          }
          if (disp.params) {
            if (disp.params.name)
              partName = disp.params.name;
            if (disp.params["filename*"])
              filename = disp.params["filename*"];
            else if (disp.params.filename)
              filename = disp.params.filename;
            if (filename !== void 0 && !preservePath)
              filename = basename(filename);
          }
          if (header["content-type"]) {
            const conType = parseContentType(header["content-type"][0]);
            if (conType) {
              partType = `${conType.type}/${conType.subtype}`;
              if (conType.params && typeof conType.params.charset === "string")
                partCharset = conType.params.charset.toLowerCase();
            }
          }
          if (header["content-transfer-encoding"])
            partEncoding = header["content-transfer-encoding"][0].toLowerCase();
          if (partType === "application/octet-stream" || filename !== void 0) {
            if (files === filesLimit) {
              if (!hitFilesLimit) {
                hitFilesLimit = true;
                this.emit("filesLimit");
              }
              skipPart = true;
              return;
            }
            ++files;
            if (this.listenerCount("file") === 0) {
              skipPart = true;
              return;
            }
            fileSize = 0;
            this._fileStream = new FileStream(fileOpts, this);
            ++this._fileEndsLeft;
            this.emit(
              "file",
              partName,
              this._fileStream,
              {
                filename,
                encoding: partEncoding,
                mimeType: partType
              }
            );
          } else {
            if (fields === fieldsLimit) {
              if (!hitFieldsLimit) {
                hitFieldsLimit = true;
                this.emit("fieldsLimit");
              }
              skipPart = true;
              return;
            }
            ++fields;
            if (this.listenerCount("field") === 0) {
              skipPart = true;
              return;
            }
            field = [];
            fieldSize = 0;
          }
        });
        let matchPostBoundary = 0;
        const ssCb = (isMatch, data, start, end, isDataSafe) => {
          retrydata:
            while (data) {
              if (this._hparser !== null) {
                const ret = this._hparser.push(data, start, end);
                if (ret === -1) {
                  this._hparser = null;
                  hparser.reset();
                  this.emit("error", new Error("Malformed part header"));
                  break;
                }
                start = ret;
              }
              if (start === end)
                break;
              if (matchPostBoundary !== 0) {
                if (matchPostBoundary === 1) {
                  switch (data[start]) {
                    case 45:
                      matchPostBoundary = 2;
                      ++start;
                      break;
                    case 13:
                      matchPostBoundary = 3;
                      ++start;
                      break;
                    default:
                      matchPostBoundary = 0;
                  }
                  if (start === end)
                    return;
                }
                if (matchPostBoundary === 2) {
                  matchPostBoundary = 0;
                  if (data[start] === 45) {
                    this._complete = true;
                    this._bparser = ignoreData;
                    return;
                  }
                  const writecb = this._writecb;
                  this._writecb = noop;
                  ssCb(false, BUF_DASH, 0, 1, false);
                  this._writecb = writecb;
                } else if (matchPostBoundary === 3) {
                  matchPostBoundary = 0;
                  if (data[start] === 10) {
                    ++start;
                    if (parts >= partsLimit)
                      break;
                    this._hparser = hparser;
                    if (start === end)
                      break;
                    continue retrydata;
                  } else {
                    const writecb = this._writecb;
                    this._writecb = noop;
                    ssCb(false, BUF_CR, 0, 1, false);
                    this._writecb = writecb;
                  }
                }
              }
              if (!skipPart) {
                if (this._fileStream) {
                  let chunk;
                  const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                  if (!isDataSafe) {
                    chunk = Buffer.allocUnsafe(actualLen);
                    data.copy(chunk, 0, start, start + actualLen);
                  } else {
                    chunk = data.slice(start, start + actualLen);
                  }
                  fileSize += chunk.length;
                  if (fileSize === fileSizeLimit) {
                    if (chunk.length > 0)
                      this._fileStream.push(chunk);
                    this._fileStream.emit("limit");
                    this._fileStream.truncated = true;
                    skipPart = true;
                  } else if (!this._fileStream.push(chunk)) {
                    if (this._writecb)
                      this._fileStream._readcb = this._writecb;
                    this._writecb = null;
                  }
                } else if (field !== void 0) {
                  let chunk;
                  const actualLen = Math.min(
                    end - start,
                    fieldSizeLimit - fieldSize
                  );
                  if (!isDataSafe) {
                    chunk = Buffer.allocUnsafe(actualLen);
                    data.copy(chunk, 0, start, start + actualLen);
                  } else {
                    chunk = data.slice(start, start + actualLen);
                  }
                  fieldSize += actualLen;
                  field.push(chunk);
                  if (fieldSize === fieldSizeLimit) {
                    skipPart = true;
                    partTruncated = true;
                  }
                }
              }
              break;
            }
          if (isMatch) {
            matchPostBoundary = 1;
            if (this._fileStream) {
              this._fileStream.push(null);
              this._fileStream = null;
            } else if (field !== void 0) {
              let data2;
              switch (field.length) {
                case 0:
                  data2 = "";
                  break;
                case 1:
                  data2 = convertToUTF8(field[0], partCharset, 0);
                  break;
                default:
                  data2 = convertToUTF8(
                    Buffer.concat(field, fieldSize),
                    partCharset,
                    0
                  );
              }
              field = void 0;
              fieldSize = 0;
              this.emit(
                "field",
                partName,
                data2,
                {
                  nameTruncated: false,
                  valueTruncated: partTruncated,
                  encoding: partEncoding,
                  mimeType: partType
                }
              );
            }
            if (++parts === partsLimit)
              this.emit("partsLimit");
          }
        };
        this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
        this._writecb = null;
        this._finalcb = null;
        this.write(BUF_CRLF);
      }
      static detect(conType) {
        return conType.type === "multipart" && conType.subtype === "form-data";
      }
      _write(chunk, enc, cb) {
        this._writecb = cb;
        this._bparser.push(chunk, 0);
        if (this._writecb)
          callAndUnsetCb(this);
      }
      _destroy(err, cb) {
        this._hparser = null;
        this._bparser = ignoreData;
        if (!err)
          err = checkEndState(this);
        const fileStream = this._fileStream;
        if (fileStream) {
          this._fileStream = null;
          fileStream.destroy(err);
        }
        cb(err);
      }
      _final(cb) {
        this._bparser.destroy();
        if (!this._complete)
          return cb(new Error("Unexpected end of form"));
        if (this._fileEndsLeft)
          this._finalcb = finalcb.bind(null, this, cb);
        else
          finalcb(this, cb);
      }
    };
    function finalcb(self2, cb, err) {
      if (err)
        return cb(err);
      err = checkEndState(self2);
      cb(err);
    }
    function checkEndState(self2) {
      if (self2._hparser)
        return new Error("Malformed part header");
      const fileStream = self2._fileStream;
      if (fileStream) {
        self2._fileStream = null;
        fileStream.destroy(new Error("Unexpected end of file"));
      }
      if (!self2._complete)
        return new Error("Unexpected end of form");
    }
    var TOKEN = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    var FIELD_VCHAR = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1
    ];
    module2.exports = Multipart;
  }
});

// ../../node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "../../node_modules/busboy/lib/types/urlencoded.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var { getDecoder } = require_utils();
    var URLEncoded = class extends Writable {
      constructor(cfg) {
        const streamOpts = {
          autoDestroy: true,
          emitClose: true,
          highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
        };
        super(streamOpts);
        let charset = cfg.defCharset || "utf8";
        if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
          charset = cfg.conType.params.charset;
        this.charset = charset;
        const limits = cfg.limits;
        this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
        this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
        this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
        this._inKey = true;
        this._keyTrunc = false;
        this._valTrunc = false;
        this._bytesKey = 0;
        this._bytesVal = 0;
        this._fields = 0;
        this._key = "";
        this._val = "";
        this._byte = -2;
        this._lastPos = 0;
        this._encode = 0;
        this._decoder = getDecoder(charset);
      }
      static detect(conType) {
        return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
      }
      _write(chunk, enc, cb) {
        if (this._fields >= this.fieldsLimit)
          return cb();
        let i = 0;
        const len = chunk.length;
        this._lastPos = 0;
        if (this._byte !== -2) {
          i = readPctEnc(this, chunk, i, len);
          if (i === -1)
            return cb(new Error("Malformed urlencoded form"));
          if (i >= len)
            return cb();
          if (this._inKey)
            ++this._bytesKey;
          else
            ++this._bytesVal;
        }
        main:
          while (i < len) {
            if (this._inKey) {
              i = skipKeyBytes(this, chunk, i, len);
              while (i < len) {
                switch (chunk[i]) {
                  case 61:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._key = this._decoder(this._key, this._encode);
                    this._encode = 0;
                    this._inKey = false;
                    continue main;
                  case 38:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._key = this._decoder(this._key, this._encode);
                    this._encode = 0;
                    if (this._bytesKey > 0) {
                      this.emit(
                        "field",
                        this._key,
                        "",
                        {
                          nameTruncated: this._keyTrunc,
                          valueTruncated: false,
                          encoding: this.charset,
                          mimeType: "text/plain"
                        }
                      );
                    }
                    this._key = "";
                    this._val = "";
                    this._keyTrunc = false;
                    this._valTrunc = false;
                    this._bytesKey = 0;
                    this._bytesVal = 0;
                    if (++this._fields >= this.fieldsLimit) {
                      this.emit("fieldsLimit");
                      return cb();
                    }
                    continue;
                  case 43:
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._key += " ";
                    this._lastPos = i + 1;
                    break;
                  case 37:
                    if (this._encode === 0)
                      this._encode = 1;
                    if (this._lastPos < i)
                      this._key += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = i + 1;
                    this._byte = -1;
                    i = readPctEnc(this, chunk, i + 1, len);
                    if (i === -1)
                      return cb(new Error("Malformed urlencoded form"));
                    if (i >= len)
                      return cb();
                    ++this._bytesKey;
                    i = skipKeyBytes(this, chunk, i, len);
                    continue;
                }
                ++i;
                ++this._bytesKey;
                i = skipKeyBytes(this, chunk, i, len);
              }
              if (this._lastPos < i)
                this._key += chunk.latin1Slice(this._lastPos, i);
            } else {
              i = skipValBytes(this, chunk, i, len);
              while (i < len) {
                switch (chunk[i]) {
                  case 38:
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = ++i;
                    this._inKey = true;
                    this._val = this._decoder(this._val, this._encode);
                    this._encode = 0;
                    if (this._bytesKey > 0 || this._bytesVal > 0) {
                      this.emit(
                        "field",
                        this._key,
                        this._val,
                        {
                          nameTruncated: this._keyTrunc,
                          valueTruncated: this._valTrunc,
                          encoding: this.charset,
                          mimeType: "text/plain"
                        }
                      );
                    }
                    this._key = "";
                    this._val = "";
                    this._keyTrunc = false;
                    this._valTrunc = false;
                    this._bytesKey = 0;
                    this._bytesVal = 0;
                    if (++this._fields >= this.fieldsLimit) {
                      this.emit("fieldsLimit");
                      return cb();
                    }
                    continue main;
                  case 43:
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._val += " ";
                    this._lastPos = i + 1;
                    break;
                  case 37:
                    if (this._encode === 0)
                      this._encode = 1;
                    if (this._lastPos < i)
                      this._val += chunk.latin1Slice(this._lastPos, i);
                    this._lastPos = i + 1;
                    this._byte = -1;
                    i = readPctEnc(this, chunk, i + 1, len);
                    if (i === -1)
                      return cb(new Error("Malformed urlencoded form"));
                    if (i >= len)
                      return cb();
                    ++this._bytesVal;
                    i = skipValBytes(this, chunk, i, len);
                    continue;
                }
                ++i;
                ++this._bytesVal;
                i = skipValBytes(this, chunk, i, len);
              }
              if (this._lastPos < i)
                this._val += chunk.latin1Slice(this._lastPos, i);
            }
          }
        cb();
      }
      _final(cb) {
        if (this._byte !== -2)
          return cb(new Error("Malformed urlencoded form"));
        if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
          if (this._inKey)
            this._key = this._decoder(this._key, this._encode);
          else
            this._val = this._decoder(this._val, this._encode);
          this.emit(
            "field",
            this._key,
            this._val,
            {
              nameTruncated: this._keyTrunc,
              valueTruncated: this._valTrunc,
              encoding: this.charset,
              mimeType: "text/plain"
            }
          );
        }
        cb();
      }
    };
    function readPctEnc(self2, chunk, pos, len) {
      if (pos >= len)
        return len;
      if (self2._byte === -1) {
        const hexUpper = HEX_VALUES[chunk[pos++]];
        if (hexUpper === -1)
          return -1;
        if (hexUpper >= 8)
          self2._encode = 2;
        if (pos < len) {
          const hexLower = HEX_VALUES[chunk[pos++]];
          if (hexLower === -1)
            return -1;
          if (self2._inKey)
            self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
          else
            self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
          self2._byte = -2;
          self2._lastPos = pos;
        } else {
          self2._byte = hexUpper;
        }
      } else {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
        else
          self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      }
      return pos;
    }
    function skipKeyBytes(self2, chunk, pos, len) {
      if (self2._bytesKey > self2.fieldNameSizeLimit) {
        if (!self2._keyTrunc) {
          if (self2._lastPos < pos)
            self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
        }
        self2._keyTrunc = true;
        for (; pos < len; ++pos) {
          const code = chunk[pos];
          if (code === 61 || code === 38)
            break;
          ++self2._bytesKey;
        }
        self2._lastPos = pos;
      }
      return pos;
    }
    function skipValBytes(self2, chunk, pos, len) {
      if (self2._bytesVal > self2.fieldSizeLimit) {
        if (!self2._valTrunc) {
          if (self2._lastPos < pos)
            self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
        }
        self2._valTrunc = true;
        for (; pos < len; ++pos) {
          if (chunk[pos] === 38)
            break;
          ++self2._bytesVal;
        }
        self2._lastPos = pos;
      }
      return pos;
    }
    var HEX_VALUES = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    module2.exports = URLEncoded;
  }
});

// ../../node_modules/busboy/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/busboy/lib/index.js"(exports2, module2) {
    "use strict";
    var { parseContentType } = require_utils();
    function getInstance(cfg) {
      const headers = cfg.headers;
      const conType = parseContentType(headers["content-type"]);
      if (!conType)
        throw new Error("Malformed content type");
      for (const type of TYPES) {
        const matched = type.detect(conType);
        if (!matched)
          continue;
        const instanceCfg = {
          limits: cfg.limits,
          headers,
          conType,
          highWaterMark: void 0,
          fileHwm: void 0,
          defCharset: void 0,
          defParamCharset: void 0,
          preservePath: false
        };
        if (cfg.highWaterMark)
          instanceCfg.highWaterMark = cfg.highWaterMark;
        if (cfg.fileHwm)
          instanceCfg.fileHwm = cfg.fileHwm;
        instanceCfg.defCharset = cfg.defCharset;
        instanceCfg.defParamCharset = cfg.defParamCharset;
        instanceCfg.preservePath = cfg.preservePath;
        return new type(instanceCfg);
      }
      throw new Error(`Unsupported content type: ${headers["content-type"]}`);
    }
    var TYPES = [
      require_multipart(),
      require_urlencoded()
    ].filter(function(typemod) {
      return typeof typemod.detect === "function";
    });
    module2.exports = (cfg) => {
      if (typeof cfg !== "object" || cfg === null)
        cfg = {};
      if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
        throw new Error("Missing Content-Type");
      }
      return getInstance(cfg);
    };
  }
});

// ../../node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS({
  "../../node_modules/undici/lib/fetch/constants.js"(exports2, module2) {
    "use strict";
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var DOMException = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    module2.exports = {
      DOMException,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods
    };
  }
});

// ../../node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "../../node_modules/undici/lib/fetch/util.js"(exports2, module2) {
    "use strict";
    var { redirectStatus } = require_constants();
    var { performance: performance2 } = require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = require("assert");
    var { isUint8Array } = require("util/types");
    var crypto;
    try {
      crypto = require("crypto");
    } catch {
    }
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatus.includes(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      location = location ? new URL(location, responseURL(response)) : null;
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      var _a, _b;
      return object instanceof Error || (((_a = object == null ? void 0 : object.constructor) == null ? void 0 : _a.name) === "Error" || ((_b = object == null ? void 0 : object.constructor) == null ? void 0 : _b.name) === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenChar(c) {
      return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
    }
    function isValidHTTPToken(characters) {
      if (!characters || typeof characters !== "string") {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        const c = characters.charCodeAt(i);
        if (c > 127 || !isTokenChar(c)) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      if (potentialValue.length === 0) {
        return false;
      }
      for (const char of potentialValue) {
        if (!isValidHTTPToken(char)) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const policy = "";
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("Origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          default:
        }
        if (serializedOrigin) {
          request.headersList.append("Origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {};
    }
    function clonePolicyContainer() {
      return {};
    }
    function determineRequestsReferrer(request) {
      var _a, _b, _c, _d, _e, _f;
      const policy = request.referrerPolicy;
      if (policy == null || policy === "" || policy === "no-referrer") {
        return "no-referrer";
      }
      const environment = request.client;
      let referrerSource = null;
      if (request.referrer === "client") {
        if (((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) == null ? void 0 : _c.name) === "Window") {
          const origin = ((_d = environment.globalObject.self) == null ? void 0 : _d.origin) ?? ((_e = environment.globalObject.location) == null ? void 0 : _e.origin);
          if (origin == null || origin === "null")
            return "no-referrer";
          referrerSource = new URL(environment.globalObject.location.href);
        } else {
          if (((_f = environment == null ? void 0 : environment.globalObject) == null ? void 0 : _f.location) == null) {
            return "no-referrer";
          }
          referrerSource = new URL(environment.globalObject.location.href);
        }
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      } else {
        return "no-referrer";
      }
      const urlProtocol = referrerSource.protocol;
      if (urlProtocol === "about:" || urlProtocol === "data:" || urlProtocol === "blob:") {
        return "no-referrer";
      }
      let temp;
      let referrerOrigin;
      const referrerUrl = (temp = stripURLForReferrer(referrerSource)).length > 4096 ? referrerOrigin = stripURLForReferrer(referrerSource, true) : temp;
      const areSameOrigin = sameOrigin(request, referrerUrl);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerUrl) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerUrl;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerUrl : referrerOrigin;
        case "strict-origin-when-cross-origin":
          if (areSameOrigin)
            return referrerOrigin;
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
      function stripURLForReferrer(url, originOnly = false) {
        const urlObject = new URL(url.href);
        urlObject.username = "";
        urlObject.password = "";
        urlObject.hash = "";
        return originOnly ? urlObject.origin : urlObject.href;
      }
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:")
        return true;
      if (url.protocol === "file:")
        return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null")
          return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const metadata = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        const actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue === expectedValue) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={1,2}))( +[\x21-\x7e]?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      const supportedHashes = crypto.getHashes();
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo;
        if (supportedHashes.includes(algorithm.toLowerCase())) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A, B) {
      if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    function normalizeMethod(method) {
      return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name) {
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          return iterator.next();
        },
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      try {
        const chunks = [];
        let length = 0;
        const reader = body.stream.getReader();
        while (true) {
          const { done, value } = await reader.read();
          if (done === true) {
            break;
          }
          assert(isUint8Array(value));
          chunks.push(value);
          length += value.byteLength;
        }
        const fulfilledSteps = (bytes) => queueMicrotask(() => {
          processBody(bytes);
        });
        fulfilledSteps(Buffer.concat(chunks, length));
      } catch (err) {
        queueMicrotask(() => processBodyError(err));
      }
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module2.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch
    };
  }
});

// ../../node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "../../node_modules/undici/lib/fetch/symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// ../../node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "../../node_modules/undici/lib/fetch/webidl.js"(exports2, module2) {
    "use strict";
    var { types } = require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      throw new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.util.Type = function(V) {
      switch (typeof V) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x = Number(V);
      if (Object.is(-0, x)) {
        x = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
          webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V} to an integer.`
          });
        }
        x = webidl.util.IntegerPart(x);
        if (x < lowerBound || x > upperBound) {
          webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
          });
        }
        return x;
      }
      if (!Number.isNaN(x) && opts.clamp === true) {
        x = Math.min(Math.max(x, lowerBound), upperBound);
        if (Math.floor(x) % 2 === 0) {
          x = Math.floor(x);
        } else {
          x = Math.ceil(x);
        }
        return x;
      }
      if (Number.isNaN(x) || Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x = webidl.util.IntegerPart(x);
      x = x % Math.pow(2, bitLength);
      if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
        return x - Math.pow(2, bitLength);
      }
      return x;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V) => {
        var _a;
        if (webidl.util.Type(V) !== "Object") {
          webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V)} is not an Object.`
          });
        }
        const method = (_a = V == null ? void 0 : V[Symbol.iterator]) == null ? void 0 : _a.call(V);
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (V) => {
        const record = {};
        const type = webidl.util.Type(V);
        if (type === "Undefined" || type === "Null") {
          return record;
        }
        if (type !== "Object") {
          webidl.errors.exception({
            header: "Record",
            message: `Expected ${V} to be an Object type.`
          });
        }
        for (let [key, value] of Object.entries(V)) {
          key = keyConverter(key);
          value = valueConverter(value);
          record[key] = value;
        }
        return record;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V, opts = {}) => {
        if (opts.strict !== false && !(V instanceof i)) {
          webidl.errors.exception({
            header: i.name,
            message: `Expected ${V} to be an instance of ${i.name}.`
          });
        }
        return V;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type !== "Null" && type !== "Undefined" && type !== "Object") {
          webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V) => {
        if (V === null) {
          return V;
        }
        return converter(V);
      };
    };
    webidl.converters.DOMString = function(V, opts = {}) {
      if (V === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V);
    };
    webidl.converters.ByteString = function(V) {
      const x = webidl.converters.DOMString(V);
      for (let index = 0; index < x.length; index++) {
        const charCode = x.charCodeAt(index);
        if (charCode > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character atindex ${index} has a value of ${charCode} which is greater than 255.`
          );
        }
      }
      return x;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V) {
      const x = Boolean(V);
      return x;
    };
    webidl.converters.any = function(V) {
      return V;
    };
    webidl.converters["long long"] = function(V, opts) {
      const x = webidl.util.ConvertToInt(V, 64, "signed", opts);
      return x;
    };
    webidl.converters["unsigned short"] = function(V) {
      const x = webidl.util.ConvertToInt(V, 16, "unsigned");
      return x;
    };
    webidl.converters.ArrayBuffer = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
        webidl.errors.conversionFailed({
          prefix: `${V}`,
          argument: `${V}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
        webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.TypedArray = function(V, T, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
        webidl.errors.conversionFailed({
          prefix: `${T.name}`,
          argument: `${V}`,
          types: [T.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.DataView = function(V, opts = {}) {
      if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
        webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
        webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V;
    };
    webidl.converters.BufferSource = function(V, opts = {}) {
      if (types.isAnyArrayBuffer(V)) {
        return webidl.converters.ArrayBuffer(V, opts);
      }
      if (types.isTypedArray(V)) {
        return webidl.converters.TypedArray(V, V.constructor);
      }
      if (types.isDataView(V)) {
        return webidl.converters.DataView(V, opts);
      }
      throw new TypeError(`Could not convert ${V} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module2.exports = {
      webidl
    };
  }
});

// ../../node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "../../node_modules/undici/lib/fetch/file.js"(exports2, module2) {
    "use strict";
    var { Blob } = require("buffer");
    var { types } = require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var File = class extends Blob {
      constructor(fileBits, fileName, options = {}) {
        if (arguments.length < 2) {
          throw new TypeError("2 arguments required");
        }
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        const d = options.lastModified;
        super(processBlobParts(fileBits, options), { type: options.type });
        this[kState] = {
          name: n,
          lastModified: d
        };
      }
      get name() {
        if (!(this instanceof File)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].name;
      }
      get lastModified() {
        if (!(this instanceof File)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
    };
    var FileLike = class {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.text(...args);
      }
      get size() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.size;
      }
      get type() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].blobLike.type;
      }
      get name() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].name;
      }
      get lastModified() {
        if (!(this instanceof FileLike)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    webidl.converters.Blob = webidl.interfaceConverter(Blob);
    webidl.converters.BlobPart = function(V, opts) {
      if (webidl.util.Type(V) === "Object") {
        if (isBlobLike(V)) {
          return webidl.converters.Blob(V, { strict: false });
        }
        return webidl.converters.BufferSource(V, opts);
      } else {
        return webidl.converters.USVString(V, opts);
      }
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(new TextEncoder().encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module2.exports = { File, FileLike, isFileLike };
  }
});

// ../../node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "../../node_modules/undici/lib/fetch/formdata.js"(exports2, module2) {
    "use strict";
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob } = require("buffer");
    var _FormData = class {
      constructor(form) {
        if (arguments.length > 0 && form != null) {
          webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["null"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 2) {
          throw new TypeError(
            `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.USVString(name);
        const next = [];
        for (const entry of this[kState]) {
          if (entry.name !== name) {
            next.push(entry);
          }
        }
        this[kState] = next;
      }
      get(name) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 2) {
          throw new TypeError(
            `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      entries() {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        return makeIterator(
          makeIterable(this[kState], "entries"),
          "FormData"
        );
      }
      keys() {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        return makeIterator(
          makeIterable(this[kState], "keys"),
          "FormData"
        );
      }
      values() {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        return makeIterator(
          makeIterable(this[kState], "values"),
          "FormData"
        );
      }
      forEach(callbackFn, thisArg = globalThis) {
        if (!(this instanceof _FormData)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'forEach' on 'FormData': 1 argument required, but only ${arguments.length} present.`
          );
        }
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    var FormData = _FormData;
    __publicField(FormData, "name", "FormData");
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          value = value instanceof File ? new File([value], filename, { type: value.type }) : new FileLike(value, filename, { type: value.type });
        }
      }
      return { name, value };
    }
    function* makeIterable(entries, type) {
      for (const { name, value } of entries) {
        if (type === "entries") {
          yield [name, value];
        } else if (type === "values") {
          yield value;
        } else {
          yield name;
        }
      }
    }
    module2.exports = { FormData };
  }
});

// ../../node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "../../node_modules/undici/lib/fetch/body.js"(exports2, module2) {
    "use strict";
    var Busboy = require_lib();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString, isBlobLike } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException } = require_constants();
    var { Blob } = require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = require("util/types");
    var { File } = require_file();
    var ReadableStream;
    async function* blobGen(blob) {
      yield* blob.stream();
    }
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      let stream = null;
      let action = null;
      let source = null;
      let length = null;
      let contentType = null;
      if (object == null) {
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        contentType = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = "----formdata-undici-" + Math.random();
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        action = async function* (object2) {
          const enc = new TextEncoder();
          for (const [name, value] of object2) {
            if (typeof value === "string") {
              yield enc.encode(
                prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`
              );
            } else {
              yield enc.encode(
                prefix + `; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`
              );
              yield* blobGen(value);
              yield enc.encode("\r\n");
            }
          }
          yield enc.encode(`--${boundary}--`);
        };
        source = object;
        contentType = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        action = blobGen;
        source = object;
        length = object.size;
        if (object.type) {
          contentType = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      } else {
        source = toUSVString(object);
        contentType = "text/plain;charset=UTF-8";
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        });
      } else if (!stream) {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? new TextEncoder().encode(source) : source
            );
            queueMicrotask(() => {
              controller.close();
            });
          }
        });
      }
      const body = { stream, source, length };
      return [body, contentType];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      body.stream = out1;
      return {
        stream: out2,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        async blob() {
          if (!(this instanceof instance)) {
            throw new TypeError("Illegal invocation");
          }
          throwIfAborted(this[kState]);
          const chunks = [];
          for await (const chunk of consumeBody(this[kState].body)) {
            if (!isUint8Array(chunk)) {
              throw new TypeError("Expected Uint8Array chunk");
            }
            chunks.push(new Blob([chunk]));
          }
          return new Blob(chunks, { type: this.headers.get("Content-Type") || "" });
        },
        async arrayBuffer() {
          if (!(this instanceof instance)) {
            throw new TypeError("Illegal invocation");
          }
          throwIfAborted(this[kState]);
          const contentLength = this.headers.get("content-length");
          const encoded = this.headers.has("content-encoding");
          if (!encoded && contentLength) {
            const buffer2 = new Uint8Array(contentLength);
            let offset2 = 0;
            for await (const chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk)) {
                throw new TypeError("Expected Uint8Array chunk");
              }
              buffer2.set(chunk, offset2);
              offset2 += chunk.length;
            }
            return buffer2.buffer;
          }
          const chunks = [];
          let size = 0;
          for await (const chunk of consumeBody(this[kState].body)) {
            if (!isUint8Array(chunk)) {
              throw new TypeError("Expected Uint8Array chunk");
            }
            chunks.push(chunk);
            size += chunk.byteLength;
          }
          const buffer = new Uint8Array(size);
          let offset = 0;
          for (const chunk of chunks) {
            buffer.set(chunk, offset);
            offset += chunk.byteLength;
          }
          return buffer.buffer;
        },
        async text() {
          if (!(this instanceof instance)) {
            throw new TypeError("Illegal invocation");
          }
          throwIfAborted(this[kState]);
          let result = "";
          const textDecoder = new TextDecoder();
          for await (const chunk of consumeBody(this[kState].body)) {
            if (!isUint8Array(chunk)) {
              throw new TypeError("Expected Uint8Array chunk");
            }
            result += textDecoder.decode(chunk, { stream: true });
          }
          result += textDecoder.decode();
          return result;
        },
        async json() {
          if (!(this instanceof instance)) {
            throw new TypeError("Illegal invocation");
          }
          throwIfAborted(this[kState]);
          return JSON.parse(await this.text());
        },
        async formData() {
          if (!(this instanceof instance)) {
            throw new TypeError("Illegal invocation");
          }
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers)
              headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = Busboy({ headers });
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, info) => {
              const { filename, encoding, mimeType } = info;
              const chunks = [];
              if (encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(err));
            });
            if (this.body !== null)
              for await (const chunk of consumeBody(this[kState].body))
                busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const textDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += textDecoder.decode(chunk, { stream: true });
              }
              text += textDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    var properties = {
      body: {
        enumerable: true,
        get() {
          if (!this || !this[kState]) {
            throw new TypeError("Illegal invocation");
          }
          return this[kState].body ? this[kState].body.stream : null;
        }
      },
      bodyUsed: {
        enumerable: true,
        get() {
          if (!this || !this[kState]) {
            throw new TypeError("Illegal invocation");
          }
          return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
        }
      }
    };
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
      Object.defineProperties(prototype.prototype, properties);
    }
    module2.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// ../../node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "../../node_modules/undici/lib/core/request.js"(exports2, module2) {
    "use strict";
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = require("assert");
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    var nodeVersion = process.versions.node.split(".");
    var nodeMajor = Number(nodeVersion[0]);
    var nodeMinor = Number(nodeVersion[1]);
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        throwOnError
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (nodeMajor < 16 || nodeMajor === 16 && nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.onError(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onConnect(abort);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onData(chunk);
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        return this[kHandler].onComplete(trailers);
      }
      onError(error) {
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
    };
    function processHeader(request, key, val) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type" && headerCharRegex.exec(val) === null) {
        request.contentType = val;
        request.headers += `${key}: ${val}\r
`;
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else {
        request.headers += `${key}: ${val}\r
`;
      }
    }
    module2.exports = Request;
  }
});

// ../../node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "../../node_modules/undici/lib/dispatcher.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module2.exports = Dispatcher;
  }
});

// ../../node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "../../node_modules/undici/lib/dispatcher-base.js"(exports2, module2) {
    "use strict";
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = [];
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? reject(err2) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module2.exports = DispatcherBase;
  }
});

// ../../node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "../../node_modules/undici/lib/core/connect.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var assert = require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    function buildConnector({ maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = /* @__PURE__ */ new Map();
      timeout = timeout == null ? 1e4 : timeout;
      maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;
      return function connect({ hostname, host, protocol, port, servername, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            ...options,
            servername,
            session,
            socket: httpSocket,
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            if (maxCachedSessions === 0) {
              return;
            }
            if (sessionCache.size >= maxCachedSessions) {
              const { value: oldestKey } = sessionCache.keys().next();
              sessionCache.delete(oldestKey);
            }
            sessionCache.set(sessionKey, session2);
          }).on("error", function(err) {
            if (sessionKey && err.code !== "UND_ERR_INFO") {
              sessionCache.delete(sessionKey);
            }
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            ...options,
            port: port || 80,
            host: hostname
          });
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module2.exports = buildConnector;
  }
});

// ../../node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "../../node_modules/undici/lib/llhttp/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports2.enumToMap = enumToMap;
  }
});

// ../../node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/undici/lib/llhttp/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SPECIAL_HEADERS = exports2.HEADER_STATE = exports2.MINOR = exports2.MAJOR = exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS = exports2.TOKEN = exports2.STRICT_TOKEN = exports2.HEX = exports2.URL_CHAR = exports2.STRICT_URL_CHAR = exports2.USERINFO_CHARS = exports2.MARK = exports2.ALPHANUM = exports2.NUM = exports2.HEX_MAP = exports2.NUM_MAP = exports2.ALPHA = exports2.FINISH = exports2.H_METHOD_MAP = exports2.METHOD_MAP = exports2.METHODS_RTSP = exports2.METHODS_ICE = exports2.METHODS_HTTP = exports2.METHODS = exports2.LENIENT_FLAGS = exports2.FLAGS = exports2.TYPE = exports2.ERROR = void 0;
    var utils_1 = require_utils2();
    var ERROR;
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(ERROR = exports2.ERROR || (exports2.ERROR = {}));
    var TYPE;
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(TYPE = exports2.TYPE || (exports2.TYPE = {}));
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    var LENIENT_FLAGS;
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(LENIENT_FLAGS = exports2.LENIENT_FLAGS || (exports2.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports2.METHODS || (exports2.METHODS = {}));
    exports2.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      METHODS.SOURCE
    ];
    exports2.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports2.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      METHODS.GET,
      METHODS.POST
    ];
    exports2.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports2.H_METHOD_MAP = {};
    Object.keys(exports2.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports2.H_METHOD_MAP[key] = exports2.METHOD_MAP[key];
      }
    });
    var FINISH;
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(FINISH = exports2.FINISH || (exports2.FINISH = {}));
    exports2.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports2.ALPHA.push(String.fromCharCode(i));
      exports2.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports2.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports2.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports2.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports2.ALPHANUM = exports2.ALPHA.concat(exports2.NUM);
    exports2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports2.USERINFO_CHARS = exports2.ALPHANUM.concat(exports2.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports2.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.URL_CHAR = exports2.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports2.URL_CHAR.push(i);
    }
    exports2.HEX = exports2.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports2.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports2.ALPHANUM);
    exports2.TOKEN = exports2.STRICT_TOKEN.concat([" "]);
    exports2.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports2.HEADER_CHARS.push(i);
      }
    }
    exports2.CONNECTION_TOKEN_CHARS = exports2.HEADER_CHARS.filter((c) => c !== 44);
    exports2.MAJOR = exports2.NUM_MAP;
    exports2.MINOR = exports2.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports2.HEADER_STATE || (exports2.HEADER_STATE = {}));
    exports2.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// ../../node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "../../node_modules/undici/lib/handler/RedirectHandler.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) {
        } else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module2.exports = RedirectHandler;
  }
});

// ../../node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "../../node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports2, module2) {
    "use strict";
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module2.exports = createRedirectInterceptor;
  }
});

// ../../node_modules/undici/lib/llhttp/llhttp.wasm.js
var require_llhttp_wasm = __commonJS({
  "../../node_modules/undici/lib/llhttp/llhttp.wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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f2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC08AIABBGGpCADcDACAAQgA3AwAgAEEwakIANwMAIABBKGpCADcDACAAQSBqQgA3AwAgAEEQakIANwMAIABBCGpCADcDACAAQbwBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9POAQMcfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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HgwTC0GZASEeDBILQZ0BIR4MEQtBmgEhHgwQC0EBIR4MDwtBmwEhHgwOC0GcASEeDA0LQZ4BIR4MDAtBoAEhHgwLC0GfASEeDAoLQaEBIR4MCQtBogEhHgwIC0GjASEeDAcLQaQBIR4MBgtBpQEhHgwFC0GmASEeDAQLQacBIR4MAwtBqAEhHgwCC0GpASEeDAELQa8BIR4LA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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AbsBuwG7AbsBuwG7AbsBuwG7AQG7AQsgCEEBaiEBQdQAIR4MmAILIAhBAWohAUHVACEeDJcCC0HnACEeIAEiIiACRg2mAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB7bOAgABqLQAARw25ASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpwILIABBADYCACAiICZrQQNqIQFBECEeDLYBC0HoACEeIAEiIiACRg2lAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB9rKAgABqLQAARw24ASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpgILIABBADYCACAiICZrQQZqIQFBFiEeDLUBC0HpACEeIAEiIiACRg2kAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB/LKAgABqLQAARw23ASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpQILIABBADYCACAiICZrQQRqIQFBBSEeDLQBCwJAIAEiCCACRw0AQeoAIR4MpAILIAgtAABB2QBHDbUBIAhBAWohAUEIIR4MswELAkAgASIIIAJHDQBB6wAhHgyjAgsCQAJAIAgtAABBsn9qDgMAtgEBtgELIAhBAWohAUHZACEeDJMCCyAIQQFqIQFB2gAhHgySAgsCQCABIgggAkcNAEHsACEeDKICCwJAAkAgCC0AAEG4f2oOCAC1AbUBtQG1AbUBtQEBtQELIAhBAWohAUHYACEeDJICCyAIQQFqIQFB2wAhHgyRAgtB7QAhHiABIiIgAkYNoAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYCzgIAAai0AAEcNswEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKECC0EAIR4gAEEANgIAICIgJmtBA2ohAQywAQtB7gAhHiABIiIgAkYNnwIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYOzgIAAai0AAEcNsgEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKACCyAAQQA2AgAgIiAma0EFaiEBQSMhHgyvAQsCQCABIgggAkcNAEHvACEeDJ8CCwJAAkAgCC0AAEG0f2oOCACyAbIBsgGyAbIBsgEBsgELIAhBAWohAUHdACEeDI8CCyAIQQFqIQFB3gAhHgyOAgsCQCABIgggAkcNAEHwACEeDJ4CCyAILQAAQcUARw2vASAIQQFqIQEM3gELQfEAIR4gASIiIAJGDZwCIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGIs4CAAGotAABHDa8BIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAydAgsgAEEANgIAICIgJmtBBGohAUEtIR4MrAELQfIAIR4gASIiIAJGDZsCIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUHQs4CAAGotAABHDa4BIAFBCEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAycAgsgAEEANgIAICIgJmtBCWohAUEpIR4MqwELAkAgASIBIAJHDQBB8wAhHgybAgtBASEeIAEtAABB3wBHDaoBIAFBAWohAQzcAQtB9AAhHiABIiIgAkYNmQIgAiAiayAAKAIAIiZqISMgIiEIICYhAQNAIAgtAAAgAUGMs4CAAGotAABHDasBIAFBAUYN9wEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMmQILAkAgASIeIAJHDQBB9QAhHgyZAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQY6zgIAAai0AAEcNqwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfUAIR4MmQILIABBADYCACAeICJrQQNqIQFBAiEeDKgBCwJAIAEiHiACRw0AQfYAIR4MmAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHws4CAAGotAABHDaoBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH2ACEeDJgCCyAAQQA2AgAgHiAia0ECaiEBQR8hHgynAQsCQCABIh4gAkcNAEH3ACEeDJcCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8rOAgABqLQAARw2pASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9wAhHgyXAgsgAEEANgIAIB4gImtBAmohAUEJIR4MpgELAkAgASIIIAJHDQBB+AAhHgyWAgsCQAJAIAgtAABBt39qDgcAqQGpAakBqQGpAQGpAQsgCEEBaiEBQeYAIR4MhgILIAhBAWohAUHnACEeDIUCCwJAIAEiHiACRw0AQfkAIR4MlQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGRs4CAAGotAABHDacBIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH5ACEeDJUCCyAAQQA2AgAgHiAia0EGaiEBQRghHgykAQsCQCABIh4gAkcNAEH6ACEeDJQCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBl7OAgABqLQAARw2mASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB+gAhHgyUAgsgAEEANgIAIB4gImtBA2ohAUEXIR4MowELAkAgASIeIAJHDQBB+wAhHgyTAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQZqzgIAAai0AAEcNpQEgAUEGRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfsAIR4MkwILIABBADYCACAeICJrQQdqIQFBFSEeDKIBCwJAIAEiHiACRw0AQfwAIR4MkgILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGhs4CAAGotAABHDaQBIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH8ACEeDJICCyAAQQA2AgAgHiAia0EGaiEBQR4hHgyhAQsCQCABIgggAkcNAEH9ACEeDJECCyAILQAAQcwARw2iASAIQQFqIQFBCiEeDKABCwJAIAEiCCACRw0AQf4AIR4MkAILAkACQCAILQAAQb9/ag4PAKMBowGjAaMBowGjAaMBowGjAaMBowGjAaMBAaMBCyAIQQFqIQFB7AAhHgyAAgsgCEEBaiEBQe0AIR4M/wELAkAgASIIIAJHDQBB/wAhHgyPAgsCQAJAIAgtAABBv39qDgMAogEBogELIAhBAWohAUHrACEeDP8BCyAIQQFqIQFB7gAhHgz+AQsCQCABIh4gAkcNAEGAASEeDI4CCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBp7OAgABqLQAARw2gASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBgAEhHgyOAgsgAEEANgIAIB4gImtBAmohAUELIR4MnQELAkAgASIIIAJHDQBBgQEhHgyNAgsCQAJAAkACQCAILQAAQVNqDiMAogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAQGiAaIBogGiAaIBAqIBogGiAQOiAQsgCEEBaiEBQekAIR4M/wELIAhBAWohAUHqACEeDP4BCyAIQQFqIQFB7wAhHgz9AQsgCEEBaiEBQfAAIR4M/AELAkAgASIeIAJHDQBBggEhHgyMAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQamzgIAAai0AAEcNngEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYIBIR4MjAILIABBADYCACAeICJrQQVqIQFBGSEeDJsBCwJAIAEiIiACRw0AQYMBIR4MiwILIAIgImsgACgCACImaiEeICIhCCAmIQECQANAIAgtAAAgAUGus4CAAGotAABHDZ0BIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgHjYCAEGDASEeDIsCCyAAQQA2AgBBBiEeICIgJmtBBmohAQyaAQsCQCABIh4gAkcNAEGEASEeDIoCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBtLOAgABqLQAARw2cASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhAEhHgyKAgsgAEEANgIAIB4gImtBAmohAUEcIR4MmQELAkAgASIeIAJHDQBBhQEhHgyJAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbazgIAAai0AAEcNmwEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYUBIR4MiQILIABBADYCACAeICJrQQJqIQFBJyEeDJgBCwJAIAEiCCACRw0AQYYBIR4MiAILAkACQCAILQAAQax/ag4CAAGbAQsgCEEBaiEBQfQAIR4M+AELIAhBAWohAUH1ACEeDPcBCwJAIAEiHiAC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IiEBDDELIABBxAA2AhwgACAiNgIUIAAgATYCDEEAIR4MeQsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMMQsgAEHFADYCHCAAICI2AhQgACABNgIMQQAhHgx4CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQw1CyAAQdAANgIcIAAgIjYCFCAAIAE2AgxBACEeDHcLIABBADYCHCAAICI2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHYLIABBADYCHCAAIAE2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHULQQAhHiAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMDHQLIABBADYCHCAAICI2AhQgAEG/lICAADYCECAAQQc2AgxBACEeDHMLIABBADYCHCAAICI2AhQgAEHUjoCAADYCECAAQQc2AgxBACEeDHILIABBADYCHCAAIAE2AhQgAEHBk4CAADYCECAAQQY2AgxBACEeDHELIABBADYCACAiICZrQQZqIQFBJCEeCyAAIB46ACkgASEBDE4LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGklICAADYCECAAQQY2AgwMbQsgACgCBCETIABBADYCBCAAIBMgHhCmgICAACITDQEgHkEBaiETC0GdASEeDFsLIABBqgE2AhwgACATNgIMIAAgHkEBajYCFEEAIR4MagsgACgCBCEUIABBADYCBCAAIBQgHhCmgICAACIUDQEgHkEBaiEUC0GaASEeDFgLIABBqwE2AhwgACAUNgIMIAAgHkEBajYCFEEAIR4MZwsgAEEANgIcIAAgFTYCFCAAQfOKgIAANgIQIABBDTYCDEEAIR4MZgsgAEEANgIcIAAgFjYCFCAAQc6NgIAANgIQIABBCTYCDEEAIR4MZQtBASEeCyAAIB46ACsgF0EBaiEWDC4LIABBADYCHCAAIBc2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDGILIABBADYCHCAAIBg2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDGELQQEhHgsgACAeOgAqIBlBAWohGAwsCyAAQQA2AhwgACAZNgIUIABBuI2AgAA2AhAgAEEJNgIMQQAhHgxeCyAAQQA2AhwgACAZNgIUIABB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QR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAFBGGogBDYCACABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQRhqQQA2AgAgASAENgIMIAEgADYCCAtBAEEAKAKotICAAEF/aiIBQX8gARs2Aqi0gIAACwtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+LeAgABBfw8LIABBEHQPCxC/gICAAAALBAAAAAsLjiwBAEGACAuGLAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgcGFyYW1ldGVycwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBQQVVTRQBQVVJHRQBNRVJHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAFBST1BGSU5EAFVO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AAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// ../../node_modules/undici/lib/llhttp/llhttp_simd.wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "../../node_modules/undici/lib/llhttp/llhttp_simd.wasm.js"(exports2, module2) {
    module2.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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ASEeDBELQZoBIR4MEAtBASEeDA8LQZsBIR4MDgtBnAEhHgwNC0GeASEeDAwLQaABIR4MCwtBnwEhHgwKC0GhASEeDAkLQaIBIR4MCAtBowEhHgwHC0GkASEeDAYLQaUBIR4MBQtBpgEhHgwEC0GnASEeDAMLQagBIR4MAgtBqQEhHgwBC0GvASEeCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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IAgtAABBtH9qDggAsgGyAbIBsgGyAbIBAbIBCyAIQQFqIQFB3QAhHgyPAgsgCEEBaiEBQd4AIR4MjgILAkAgASIIIAJHDQBB8AAhHgyeAgsgCC0AAEHFAEcNrwEgCEEBaiEBDN4BC0HxACEeIAEiIiACRg2cAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFBiLOAgABqLQAARw2vASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnQILIABBADYCACAiICZrQQRqIQFBLSEeDKwBC0HyACEeIAEiIiACRg2bAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB0LOAgABqLQAARw2uASABQQhGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnAILIABBADYCACAiICZrQQlqIQFBKSEeDKsBCwJAIAEiASACRw0AQfMAIR4MmwILQQEhHiABLQAAQd8ARw2qASABQQFqIQEM3AELQfQAIR4gASIiIAJGDZkCIAIgImsgACgCACImaiEjICIhCCAmIQEDQCAILQAAIAFBjLOAgABqLQAARw2rASABQQFGDfcBIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADJkCCwJAIAEiHiACRw0AQfUAIR4MmQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGOs4CAAGotAABHDasBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH1ACEeDJkCCyAAQQA2AgAgHiAia0EDaiEBQQIhHgyoAQsCQCABIh4gAkcNAEH2ACEeDJgCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8LOAgABqLQAARw2qASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9gAhHgyYAgsgAEEANgIAIB4gImtBAmohAUEfIR4MpwELAkAgASIeIAJHDQBB9wAhHgyXAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQfKzgIAAai0AAEcNqQEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfcAIR4MlwILIABBADYCACAeICJrQQJq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LwEwQRByOwEwDIcBCyAAQTY2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MoAELIAEtAABBOkcNAiAAKAIEIR4gAEEANgIEIAAgHiABEKiAgIAAIh4NASABQQFqIQELQTEhHgyOAQsgAEE2NgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDJ0BCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhHgycAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIR4MiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDFALIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MmAELIABBADYCHCAAICI2AhQgAEHlmICAADYCECAAQQc2AgwgAEEANgIAQQAhHgyXAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMTwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyWAQtBACEeIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMlQELQQEhHgsgACAeOgArIAFBAWohASAALQApQSJGDYsBDEwLIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDJIBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgyRAQtBASEeCyAAIB46ACogAUEBaiEBDEoLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEeDI4BCyAAQQA2AgAgJiAja0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxKCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhHgyNAQsgAEEANgIAC0EAIR4gAEEANgIcIAAgATYCFCAAQbmbgIAANgIQIABBCDYCDAyLAQsgAEEANgIAICYgI2tBA2ohAQJAIAAtAClBIUcNACABIQEMRwsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIR4MigELIABBADYCACAmICNrQQRqIQECQCAALQApIh5BXWpBC08NACABIQEMRgsCQCAeQQZLDQBBASAedEHKAHFFDQAgASEBDEYLQQAhHiAAQQA2AhwgACAB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HiAAQQA2AhwgACABNgIUIABB6pCAgAA2AhAgAEEZNgIMDAILIABBIDYCHCAAIAg2AgwgACABQQFqNgIUQQAhHgwBCwJAIAEiASACRw0AQRQhHgwBCyAAQYmAgIAANgIIIAAgATYCBEETIR4LIANBEGokgICAgAAgHguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKgtICAAA0AQQAQvoCAgABBgLiEgABrIgJB2QBJDQBBACEDAkBBACgC4LeAgAAiBA0AQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQhqQXBxQdiq1aoFcyIENgLgt4CAAEEAQQA2AvS3gIAAQQBBADYCxLeAgAALQQAgAjYCzLeAgABBAEGAuISAADYCyLeAgABBAEGAuISAADYCmLSAgABBACAENgKstICAAEEAQX82Aqi0gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgLiEgABBeEGAuISAAGtBD3FBAEGAuISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAJBgLiEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKItICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuLSAgABqKAIAIgRBCGohAwJA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AkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqLSAgABBf2oiAUF/IAEbNgKotICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Avi3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC44sAQBBgAgLhiwBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AATUtBQ1RJVklUWQBDT1BZAE5PVElGWQBQTEFZAFBVVABDSEVDS09VVABQT1NUAFJFUE9SVABIUEVfSU5WQUxJRF9DT05TVEFOVABHRVQASFBFX1NUUklDVABSRURJUkVDVABDT05ORUNUAEhQRV9JTlZBTElEX1NUQVRVUwBPUFRJT05TAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAEhQRV9JTlZBTElEX1VSTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUAUEFVU0UAUFVSR0UATUVSR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABQUk9QRklORABVTkJJTkQAUkVCSU5EAEhQ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BQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv";
  }
});

// ../../node_modules/undici/lib/client.js
var require_client = __commonJS({
  "../../node_modules/undici/lib/client.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var net = require("net");
    var util = require_util();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors
    } = require_symbols();
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client3 = class extends DispatcherBase {
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            socketPath,
            timeout: connectTimeout,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || 16384;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = new Request(origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) {
        } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            this.destroy(resolve);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    var constants = require_constants2();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          wasm_on_url: (p, at, len) => {
            return 0;
          },
          wasm_on_status: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_header_value: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at - currentBufferPtr;
            const end = start + len;
            return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp().catch(() => {
    });
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports3 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports3;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          clearTimeout(this.timeout);
          if (value) {
            this.timeout = setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      finish() {
        try {
          try {
            currentParser = this;
          } finally {
            currentParser = null;
          }
        } catch (err) {
          util.destroy(this.socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive;
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        let pause;
        try {
          pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        } catch (err) {
          util.destroy(socket, err);
          return -1;
        }
        if (request.method === "HEAD") {
          assert(socket[kReset]);
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        this.bytesRead += buf.length;
        try {
          if (request.onData(buf) === false) {
            return constants.ERROR.PAUSED;
          }
        } catch (err) {
          util.destroy(socket, err);
          return -1;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        try {
          request.onComplete(headers);
        } catch (err) {
          errorRequest(client, request, err);
        }
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      parser.readMore();
    }
    function onSocketError(err) {
      const { [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
        parser.finish();
        return;
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser } = this;
      if (parser.statusCode && !parser.shouldKeepAlive) {
        parser.finish();
        return;
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client } = this;
      this[kParser].destroy();
      this[kParser] = null;
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substr(1, idx - 1);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (!llhttpInstance) {
          llhttpInstance = await llhttpPromise;
          llhttpPromise = null;
        }
        client[kConnecting] = false;
        assert(socket);
        client[kSocket] = socket;
        socket[kNoRef] = false;
        socket[kWriting] = false;
        socket[kReset] = false;
        socket[kBlocking] = false;
        socket[kError] = null;
        socket[kParser] = new Parser(client, socket, llhttpInstance);
        socket[kClient] = client;
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client.closed && !client[kSize]) {
          client.destroy();
          return;
        }
        const socket = client[kSocket];
        if (socket) {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket) {
          connect(client);
          continue;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {
          request.body.on("data", function() {
            assert(false);
          }).on("error", function(err) {
            errorRequest(client, request, err);
          }).on("end", function() {
            util.destroy(this);
          });
          request.body = null;
        }
        if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write2(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function write2(client, request) {
      const { body, method, path, host, upgrade, headers, blocking } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "ascii");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "ascii");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeStream({ body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        try {
          assert(!finished);
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        assert(!finished);
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        onFinished(new RequestAbortedError());
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er) {
            err = er;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
        socket.write(buffer);
        socket.uncork();
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    async function writeIterable({ body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "ascii");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "ascii");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "ascii");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "ascii");
          } else {
            socket.write(`${header}\r
`, "ascii");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "ascii");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module2.exports = Client3;
  }
});

// ../../node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "../../node_modules/undici/lib/node/fixed-queue.js"(exports2, module2) {
    "use strict";
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module2.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// ../../node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "../../node_modules/undici/lib/pool-stats.js"(exports2, module2) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module2.exports = PoolStats;
  }
});

// ../../node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "../../node_modules/undici/lib/pool-base.js"(exports2, module2) {
    "use strict";
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size } of this[kClients]) {
          ret += size;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module2.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// ../../node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "../../node_modules/undici/lib/pool.js"(exports2, module2) {
    "use strict";
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client3 = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client3(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            socketPath,
            timeout: connectTimeout == null ? 1e4 : connectTimeout,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module2.exports = Pool;
  }
});

// ../../node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "../../node_modules/undici/lib/balanced-pool.js"(exports2, module2) {
    "use strict";
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0)
        return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module2.exports = BalancedPool;
  }
});

// ../../node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "../../node_modules/undici/lib/compat/dispatcher-weakref.js"(exports2, module2) {
    "use strict";
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        dispatcher.on("disconnect", () => {
          if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
            this.finalizer(key);
          }
        });
      }
    };
    module2.exports = function() {
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// ../../node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "../../node_modules/undici/lib/agent.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client3 = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client3(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry((key) => {
          const ref = this[kClients].get(key);
          if (ref !== void 0 && ref.deref() === void 0) {
            this[kClients].delete(key);
          }
        });
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module2.exports = Agent;
  }
});

// ../../node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "../../node_modules/undici/lib/api/readable.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var { Readable } = require("stream");
    var { RequestAbortedError, NotSupportedError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    module2.exports = class BodyReadable extends Readable {
      constructor(resume, abort, contentType = "") {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark: 64 * 1024
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      async text() {
        return consume(this, "text");
      }
      async json() {
        return consume(this, "json");
      }
      async blob() {
        return consume(this, "blob");
      }
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      async formData() {
        throw new NotSupportedError();
      }
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      async dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        try {
          for await (const chunk of this) {
            limit -= Buffer.byteLength(chunk);
            if (limit < 0) {
              return;
            }
          }
        } catch {
        }
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst);
        } else if (type === "blob") {
          if (!Blob) {
            Blob = require("buffer").Blob;
          }
          resolve(new Blob(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// ../../node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "../../node_modules/undici/lib/api/abort-signal.js"(exports2, module2) {
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      if ("addEventListener" in self2[kSignal]) {
        self2[kSignal].addEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].addListener("abort", self2[kListener]);
      }
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module2.exports = {
      addSignal,
      removeSignal
    };
  }
});

// ../../node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "../../node_modules/undici/lib/api/api-request.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError,
      ResponseStatusCodeError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers2 = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers: headers2 });
          }
          return;
        }
        const parsedHeaders = util.parseHeaders(rawHeaders);
        const contentType = parsedHeaders["content-type"];
        const body = new Readable(resume, abort, contentType);
        this.callback = null;
        this.res = body;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
            return;
          }
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      if (statusCode === 204 || !contentType) {
        body.dump();
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = await body.json();
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = await body.text();
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      body.dump();
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = request;
  }
});

// ../../node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "../../node_modules/undici/lib/api/api-stream.js"(exports2, module2) {
    "use strict";
    var { finished } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { factory, opaque, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers2 = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers: headers2 });
          }
          return;
        }
        this.factory = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        const res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        res.on("drain", resume);
        finished(res, { readable: false }, (err) => {
          const { callback, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res.write(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = stream;
  }
});

// ../../node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "../../node_modules/undici/lib/api/api-pipeline.js"(exports2, module2) {
    "use strict";
    var {
      Readable,
      Duplex,
      PassThrough
    } = require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module2.exports = pipeline;
  }
});

// ../../node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "../../node_modules/undici/lib/api/api-upgrade.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = upgrade;
  }
});

// ../../node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "../../node_modules/undici/lib/api/api-connect.js"(exports2, module2) {
    "use strict";
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module2.exports = connect;
  }
});

// ../../node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "../../node_modules/undici/lib/api/index.js"(exports2, module2) {
    "use strict";
    module2.exports.request = require_api_request();
    module2.exports.stream = require_api_stream();
    module2.exports.pipeline = require_api_pipeline();
    module2.exports.upgrade = require_api_upgrade();
    module2.exports.connect = require_api_connect();
  }
});

// ../../node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "../../node_modules/undici/lib/mock/mock-errors.js"(exports2, module2) {
    "use strict";
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module2.exports = {
      MockNotMatchedError
    };
  }
});

// ../../node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "../../node_modules/undici/lib/mock/mock-symbols.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// ../../node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "../../node_modules/undici/lib/mock/mock-utils.js"(exports2, module2) {
    "use strict";
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = require("http");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const responseData = getResponseData(
          typeof data === "function" ? data({ ...opts, headers: optsHeaders }) : data
        );
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module2.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// ../../node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "../../node_modules/undici/lib/mock/mock-interceptor.js"(exports2, module2) {
    "use strict";
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module2.exports.MockInterceptor = MockInterceptor;
    module2.exports.MockScope = MockScope;
  }
});

// ../../node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "../../node_modules/undici/lib/mock/mock-client.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Client3 = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client3 {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockClient;
  }
});

// ../../node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "../../node_modules/undici/lib/mock/mock-pool.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module2.exports = MockPool;
  }
});

// ../../node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "../../node_modules/undici/lib/mock/pluralizer.js"(exports2, module2) {
    "use strict";
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module2.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// ../../node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "../../node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports2, module2) {
    "use strict";
    var { Transform } = require("stream");
    var { Console } = require("console");
    module2.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// ../../node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "../../node_modules/undici/lib/mock/mock-agent.js"(exports2, module2) {
    "use strict";
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module2.exports = MockAgent;
  }
});

// ../../node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "../../node_modules/undici/lib/proxy-agent.js"(exports2, module2) {
    "use strict";
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = require("url");
    var Agent = require_agent();
    var Client3 = require_client();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = {};
        if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        }
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host } = resolvedUrl;
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = new Client3(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module2.exports = ProxyAgent;
  }
});

// ../../node_modules/undici/lib/global.js
var require_global = __commonJS({
  "../../node_modules/undici/lib/global.js"(exports2, module2) {
    "use strict";
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module2.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// ../../node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "../../node_modules/undici/lib/handler/DecoratorHandler.js"(exports2, module2) {
    "use strict";
    module2.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// ../../node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "../../node_modules/undici/lib/fetch/headers.js"(exports2, module2) {
    "use strict";
    var { kHeadersList } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function headerValueNormalize(potentialValue) {
      return potentialValue.replace(
        /^[\r\n\t ]+|[\r\n\t ]+$/g,
        ""
      );
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (const header of object) {
          if (header.length !== 2) {
            webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          headers.append(header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        for (const [key, value] of Object.entries(object)) {
          headers.append(key, value);
        }
      } else {
        webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    var HeadersList = class {
      constructor(init) {
        if (init instanceof HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
      }
      append(name, value) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        const exists = this[kHeadersMap].get(name);
        if (exists) {
          this[kHeadersMap].set(name, `${exists}, ${value}`);
        } else {
          this[kHeadersMap].set(name, `${value}`);
        }
      }
      set(name, value) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        return this[kHeadersMap].set(name, value);
      }
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        return this[kHeadersMap].delete(name);
      }
      get(name) {
        name = name.toLowerCase();
        if (!this.contains(name)) {
          return null;
        }
        return this[kHeadersMap].get(name) ?? null;
      }
      has(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      keys() {
        return this[kHeadersMap].keys();
      }
      values() {
        return this[kHeadersMap].values();
      }
      entries() {
        return this[kHeadersMap].entries();
      }
      [Symbol.iterator]() {
        return this[kHeadersMap][Symbol.iterator]();
      }
    };
    var Headers = class {
      constructor(init = void 0) {
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      append(name, value) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 2) {
          throw new TypeError(
            `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.append",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        return this[kHeadersList].append(name, value);
      }
      delete(name) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        return this[kHeadersList].delete(name);
      }
      get(name) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      has(name) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      set(name, value) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 2) {
          throw new TypeError(
            `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
          );
        }
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") {
        }
        return this[kHeadersList].set(name, value);
      }
      get [kHeadersSortedMap]() {
        if (!this[kHeadersList][kHeadersSortedMap]) {
          this[kHeadersList][kHeadersSortedMap] = new Map([...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1));
        }
        return this[kHeadersList][kHeadersSortedMap];
      }
      keys() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return makeIterator(this[kHeadersSortedMap].keys(), "Headers");
      }
      values() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return makeIterator(this[kHeadersSortedMap].values(), "Headers");
      }
      entries() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return makeIterator(this[kHeadersSortedMap].entries(), "Headers");
      }
      forEach(callbackFn, thisArg = globalThis) {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`
          );
        }
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        if (!(this instanceof Headers)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kHeadersList];
      }
    };
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty
    });
    webidl.converters.HeadersInit = function(V) {
      if (webidl.util.Type(V) === "Object") {
        if (V[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V);
        }
        return webidl.converters["record<ByteString, ByteString>"](V);
      }
      webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module2.exports = {
      fill,
      Headers,
      HeadersList
    };
  }
});

// ../../node_modules/undici/lib/fetch/global.js
var require_global2 = __commonJS({
  "../../node_modules/undici/lib/fetch/global.js"(exports2, module2) {
    "use strict";
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin !== void 0 && typeof newOrigin !== "string" && !(newOrigin instanceof URL)) {
        throw new Error("Invalid base url");
      }
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// ../../node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "../../node_modules/undici/lib/fetch/response.js"(exports2, module2) {
    "use strict";
    var { Headers, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      responseURL,
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike
    } = require_util2();
    var {
      redirectStatus,
      nullBodyStatus,
      DOMException
    } = require_constants();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global2();
    var { kHeadersList } = require_symbols();
    var assert = require("assert");
    var { types } = require("util");
    var ReadableStream = globalThis.ReadableStream || require("stream/web").ReadableStream;
    var Response = class {
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      static json(data, init = {}) {
        if (arguments.length === 0) {
          throw new TypeError(
            "Failed to execute 'json' on 'Response': 1 argument required, but 0 present."
          );
        }
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = new TextEncoder("utf-8").encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`
          );
        }
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatus.includes(status)) {
          throw new RangeError("Invalid status code");
        }
        const responseObject = new Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = parsedURL.toString();
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers();
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      get type() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].type;
      }
      get url() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        let url = responseURL(this[kState]);
        if (url == null) {
          return "";
        }
        if (url.hash) {
          url = new URL(url);
          url.hash = "";
        }
        return url.toString();
      }
      get redirected() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].urlList.length > 1;
      }
      get status() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].status;
      }
      get ok() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      get statusText() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].statusText;
      }
      get headers() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kHeaders];
      }
      clone() {
        if (!(this instanceof Response)) {
          throw new TypeError("Illegal invocation");
        }
        if (this.bodyUsed || this.body && this.body.locked) {
          webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason, {
          cause: isError ? reason : void 0
        }),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(new DOMException("The operation was aborted.", "AbortError")) : makeNetworkError(fetchParams.controller.terminated.reason);
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kState].headersList, init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code."
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.has("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
        return webidl.converters.BufferSource(V);
      }
      if (util.isFormDataLike(V)) {
        return webidl.converters.FormData(V, { strict: false });
      }
      if (V instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V);
      }
      return webidl.converters.DOMString(V);
    };
    webidl.converters.BodyInit = function(V) {
      if (V instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V);
      }
      if (V == null ? void 0 : V[Symbol.asyncIterator]) {
        return V;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module2.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response
    };
  }
});

// ../../node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "../../node_modules/undici/lib/fetch/request.js"(exports2, module2) {
    "use strict";
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod
    } = require_util2();
    var {
      forbiddenMethods,
      corsSafeListedMethods,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache
    } = require_constants();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global2();
    var { kHeadersList } = require_symbols();
    var assert = require("assert");
    var TransformStream;
    var kInit = Symbol("init");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class {
      constructor(input, init = {}) {
        var _a, _b;
        if (input === kInit) {
          return;
        }
        if (arguments.length < 1) {
          throw new TypeError(
            `Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`
          );
        }
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window = "client";
        if (((_b = (_a = request.window) == null ? void 0 : _a.constructor) == null ? void 0 : _b.name) === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window = request.window;
        }
        if (init.window !== void 0 && init.window != null) {
          throw new TypeError(`'window' option '${window}' must be null`);
        }
        if (init.window !== void 0) {
          window = "no-window";
        }
        request = makeRequest({
          method: request.method,
          headersList: request.headersList,
          unsafeRequest: request.unsafeRequest,
          client: this[kRealm].settingsObject,
          window,
          priority: request.priority,
          origin: request.origin,
          referrer: request.referrer,
          referrerPolicy: request.referrerPolicy,
          mode: request.mode,
          credentials: request.credentials,
          cache: request.cache,
          redirect: request.redirect,
          integrity: request.integrity,
          keepalive: request.keepalive,
          reloadNavigation: request.reloadNavigation,
          historyNavigation: request.historyNavigation,
          urlList: [...request.urlList]
        });
        if (Object.keys(init).length > 0) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            request.referrer = parsedReferrer;
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
          if (!referrerPolicy.includes(request.referrerPolicy)) {
            throw new TypeError(
              `Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`
            );
          }
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
          if (!requestMode.includes(mode)) {
            throw new TypeError(
              `Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`
            );
          }
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
          if (!requestCredentials.includes(request.credentials)) {
            throw new TypeError(
              `Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`
            );
          }
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
          if (!requestCache.includes(request.cache)) {
            throw new TypeError(
              `Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`
            );
          }
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
          if (!requestRedirect.includes(request.redirect)) {
            throw new TypeError(
              `Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`
            );
          }
        }
        if (init.integrity !== void 0 && init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(init.method)) {
            throw TypeError(`'${init.method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
            throw TypeError(`'${init.method}' HTTP method is unsupported.`);
          }
          method = normalizeMethod(init.method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            const abort = () => ac.abort(signal.reason);
            signal.addEventListener("abort", abort, { once: true });
            requestFinalizer.register(this, { signal, abort });
          }
        }
        this[kHeaders] = new Headers();
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethods.includes(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (Object.keys(init).length !== 0) {
          let headers = new Headers(this[kHeaders]);
          if (init.headers !== void 0) {
            headers = init.headers;
          }
          this[kHeaders][kHeadersList].clear();
          if (headers.constructor.name === "Headers") {
            for (const [key, val] of headers) {
              this[kHeaders].append(key, val);
            }
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof Request ? input[kState].body : null;
        if ((init.body !== void 0 && init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body !== void 0 && init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders].has("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      get [Symbol.toStringTag]() {
        return this.constructor.name;
      }
      get method() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].method;
      }
      get url() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].url.toString();
      }
      get headers() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kHeaders];
      }
      get destination() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].destination;
      }
      get referrer() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      get referrerPolicy() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].referrerPolicy;
      }
      get mode() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].mode;
      }
      get credentials() {
        return this[kState].credentials;
      }
      get cache() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].cache;
      }
      get redirect() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].redirect;
      }
      get integrity() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].integrity;
      }
      get keepalive() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].keepalive;
      }
      get isReloadNavigation() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].reloadNavigation;
      }
      get isHistoryNavigation() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kState].historyNavigation;
      }
      get signal() {
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        return this[kSignal];
      }
      clone() {
        var _a;
        if (!(this instanceof Request)) {
          throw new TypeError("Illegal invocation");
        }
        if (this.bodyUsed || ((_a = this.body) == null ? void 0 : _a.locked)) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new Request(kInit);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers();
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          this.signal.addEventListener(
            "abort",
            () => {
              ac.abort(this.signal.reason);
            },
            { once: true }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V) {
      if (typeof V === "string") {
        return webidl.converters.USVString(V);
      }
      if (V instanceof Request) {
        return webidl.converters.Request(V);
      }
      return webidl.converters.USVString(V);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        allowedValues: [
          "",
          "no-referrer",
          "no-referrer-when-downgrade",
          "same-origin",
          "origin",
          "strict-origin",
          "origin-when-cross-origin",
          "strict-origin-when-cross-origin",
          "unsafe-url"
        ]
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        allowedValues: [
          "same-origin",
          "cors",
          "no-cors",
          "navigate",
          "websocket"
        ]
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        allowedValues: [
          "omit",
          "same-origin",
          "include"
        ]
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        allowedValues: [
          "default",
          "no-store",
          "reload",
          "no-cache",
          "force-cache",
          "only-if-cached"
        ]
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        allowedValues: [
          "follow",
          "error",
          "manual"
        ]
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      }
    ]);
    module2.exports = { Request, makeRequest };
  }
});

// ../../node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "../../node_modules/undici/lib/fetch/dataURL.js"(exports2, module2) {
    var assert = require("assert");
    var { atob: atob2 } = require("buffer");
    var { isValidHTTPToken } = require_util2();
    var encoder = new TextEncoder();
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePoints(
        (char) => char !== ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, "");
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = decodeURIComponent(new TextDecoder("utf-8").decode(body));
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      let output = url.protocol;
      if (url.host.length > 0) {
        output += "//";
        if (url.username.length > 0 || url.password.length > 0) {
          output += url.username;
          if (url.password.length > 0) {
            output += ":" + url.password;
          }
          output += "@";
        }
        output += decodeURIComponent(url.host);
        if (url.port.length > 0) {
          output += ":" + url.port;
        }
      }
      if (url.host.length === 0 && url.pathname.length > 1 && url.href.slice(url.protocol.length + 1)[0] === ".") {
        output += "/.";
      }
      output += url.pathname;
      if (url.search.length > 0) {
        output += url.search;
      }
      if (excludeFragment === false && url.hash.length > 0) {
        output += url.hash;
      }
      return output;
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function stringPercentDecode(input) {
      const bytes = encoder.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = input.trim();
      const position = { position: 0 };
      const type = collectASequenceOfCodePoints(
        (char) => char !== "/",
        input,
        position
      );
      if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePoints(
        (char) => char !== ";",
        input,
        position
      );
      subtype = subtype.trim();
      if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {
        return "failure";
      }
      const mimeType = {
        type: type.toLowerCase(),
        subtype: subtype.toLowerCase(),
        parameters: /* @__PURE__ */ new Map()
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          (char) => /(\u000A|\u000D|\u0009|\u0020)/.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePoints(
            (char) => char !== ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePoints(
            (char) => char !== ";",
            input,
            position
          );
          parameterValue = parameterValue.trimEnd();
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) && !/^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/.test(parameterValue) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { type, subtype, parameters } = mimeType;
      let serialization = `${type}/${subtype}`;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!isValidHTTPToken(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    module2.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// ../../node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "../../node_modules/undici/lib/fetch/index.js"(exports2, module2) {
    "use strict";
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = require("assert");
    var { safelyExtractBody, extractBody } = require_body();
    var {
      redirectStatus,
      nullBodyStatus,
      safeMethods,
      requestBodyHeader,
      subresource,
      DOMException
    } = require_constants();
    var { kHeadersList } = require_symbols();
    var EE = require("events");
    var { Readable, pipeline } = require("stream");
    var { isErrored, isReadable } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = require("stream/web");
    var resolveObjectURL;
    var ReadableStream;
    var nodeVersion = process.versions.node.split(".");
    var nodeMajor = Number(nodeVersion[0]);
    var nodeMinor = Number(nodeVersion[1]);
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
      }
      terminate(reason) {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        (_a = this.connection) == null ? void 0 : _a.destroy(reason);
        this.emit("terminated", reason);
      }
      abort() {
        var _a;
        if (this.state !== "ongoing") {
          return;
        }
        const reason = new DOMException("The operation was aborted.", "AbortError");
        this.state = "aborted";
        (_a = this.connection) == null ? void 0 : _a.destroy(reason);
        this.emit("terminated", reason);
      }
    };
    async function fetch(input, init = {}) {
      var _a;
      if (arguments.length < 1) {
        throw new TypeError(
          `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`
        );
      }
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (((_a = globalObject == null ? void 0 : globalObject.constructor) == null ? void 0 : _a.name) === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      requestObject.signal.addEventListener(
        "abort",
        () => {
          locallyAborted = true;
          abortFetch(p, request, responseObject);
          if (controller != null) {
            controller.abort();
          }
        },
        { once: true }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return;
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject);
          return;
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return;
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: this
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      var _a;
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!((_a = response.urlList) == null ? void 0 : _a.length)) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!/^https?:/.test(originalURL.protocol)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!timingInfo.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      response.timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor >= 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject) {
      var _a, _b;
      const error = new DOMException("The operation was aborted.", "AbortError");
      p.reject(error);
      if (request.body != null && isReadable((_a = request.body) == null ? void 0 : _a.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable((_b = response.body) == null ? void 0 : _b.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
    }) {
      var _a, _b, _c, _d;
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = ((_c = (_b = (_a = request.client) == null ? void 0 : _a.globalObject) == null ? void 0 : _b.constructor) == null ? void 0 : _c.name) === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = (_d = request.client) == null ? void 0 : _d.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.has("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.has("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) {
      }
      if (subresource.includes(request.destination)) {
      }
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!/^https?:/.test(requestCurrentURL(request).protocol)) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") {
        }
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.has("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    async function schemeFetch(fetchParams) {
      const { request } = fetchParams;
      const {
        protocol: scheme,
        pathname: path
      } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          if (path === "blank") {
            const resp = makeResponse({
              statusText: "OK",
              headersList: [
                ["content-type", "text/html;charset=utf-8"]
              ]
            });
            resp.urlList = [new URL("about:blank")];
            return resp;
          }
          return makeNetworkError("invalid path called");
        }
        case "blob:": {
          resolveObjectURL = resolveObjectURL || require("buffer").resolveObjectURL;
          const currentURL = requestCurrentURL(request);
          if (currentURL.search.length !== 0) {
            return makeNetworkError("NetworkError when attempting to fetch resource.");
          }
          const blob = resolveObjectURL(currentURL.toString());
          if (request.method !== "GET" || !isBlobLike(blob)) {
            return makeNetworkError("invalid method");
          }
          const response = makeResponse({ statusText: "OK", urlList: [currentURL] });
          response.headersList.set("content-length", `${blob.size}`);
          response.headersList.set("content-type", blob.type);
          response.body = extractBody(blob)[0];
          return response;
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return makeNetworkError("failed to fetch the data URL");
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", mimeType]
            ],
            body: extractBody(dataURLStruct.body)[0]
          });
        }
        case "file:": {
          return makeNetworkError("not implemented... yet...");
        }
        case "http:":
        case "https:": {
          return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return makeNetworkError("unknown scheme");
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    async function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          await fullyReadBody(response.body, processBody, processBodyError);
        }
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") {
      }
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatus.includes(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    async function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return makeNetworkError(err);
      }
      if (!/^https?:/.test(locationURL.protocol)) {
        return makeNetworkError("URL scheme must be a HTTP(S) scheme");
      }
      if (request.redirectCount === 20) {
        return makeNetworkError("redirect count exceeded");
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return makeNetworkError('cross origin not allowed for request mode "cors"');
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        );
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return makeNetworkError();
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !["GET", "HEAD"].includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (request.body != null) {
        assert(request.body.source);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      const httpCache = null;
      const revalidatingFlag = false;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = String(contentLength);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) {
      }
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", httpRequest.referrer.href);
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.has("user-agent")) {
        httpRequest.headersList.append("user-agent", "undici");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.has("if-modified-since") || httpRequest.headersList.has("if-none-match") || httpRequest.headersList.has("if-unmodified-since") || httpRequest.headersList.has("if-match") || httpRequest.headersList.has("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.has("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.has("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.has("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.has("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.has("accept-encoding")) {
        if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      if (includeCredentials) {
      }
      if (httpCache == null) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
      }
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
        }
        if (revalidatingFlag && forwardResponse.status === 304) {
        }
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.has("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      if (isAuthenticationFetch) {
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          var _a;
          if (!this.destroyed) {
            this.destroyed = true;
            (_a = this.abort) == null ? void 0 : _a.call(this, err ?? new DOMException("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      const httpCache = null;
      if (httpCache == null) {
        request.cache = "no-store";
      }
      const newConnection = forceNewConnection ? "yes" : "no";
      if (request.mode === "websocket") {
      } else {
      }
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          var _a;
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          (_a = fetchParams.processRequestBodyChunkLength) == null ? void 0 : _a.call(fetchParams, bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList } = await dispatch({ body: requestBody });
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = () => {
        fetchParams.controller.abort();
      };
      if (!ReadableStream) {
        ReadableStream = require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm(controller);
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        { highWaterMark: 0 }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
            }
          }
          if (bytes === void 0) {
            try {
              fetchParams.controller.controller.close();
            } catch (err) {
              if (!/Controller is already closed/.test(err)) {
                throw err;
              }
            }
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += (bytes == null ? void 0 : bytes.byteLength) ?? 0;
          if (isErrorLike(bytes)) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              new DOMException("The operation was aborted.", "AbortError")
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
            headers: [...request.headersList].flat(),
            maxRedirections: 0,
            bodyTimeout: 3e5,
            headersTimeout: 3e5
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                if (key.toLowerCase() === "content-encoding") {
                  codings = val.split(",").map((x) => x.trim());
                } else if (key.toLowerCase() === "location") {
                  location = val;
                }
                headers.append(key, val);
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatus.includes(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (/(x-)?gzip/.test(coding)) {
                    decoders.push(zlib.createGunzip());
                  } else if (/(x-)?deflate/.test(coding)) {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              var _a;
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              (_a = this.body) == null ? void 0 : _a.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            }
          }
        ));
      }
    }
    module2.exports = {
      fetch,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// ../../node_modules/undici/index.js
var require_undici = __commonJS({
  "../../node_modules/undici/index.js"(exports2, module2) {
    "use strict";
    var Client3 = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var nodeVersion = process.versions.node.split(".");
    var nodeMajor = Number(nodeVersion[0]);
    var nodeMinor = Number(nodeVersion[1]);
    Object.assign(Dispatcher.prototype, api);
    module2.exports.Dispatcher = Dispatcher;
    module2.exports.Client = Client3;
    module2.exports.Pool = Pool;
    module2.exports.BalancedPool = BalancedPool;
    module2.exports.Agent = Agent;
    module2.exports.ProxyAgent = ProxyAgent;
    module2.exports.DecoratorHandler = DecoratorHandler;
    module2.exports.RedirectHandler = RedirectHandler;
    module2.exports.createRedirectInterceptor = createRedirectInterceptor;
    module2.exports.buildConnector = buildConnector;
    module2.exports.errors = errors;
    function makeDispatcher(fn) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module2.exports.setGlobalDispatcher = setGlobalDispatcher;
    module2.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (nodeMajor > 16 || nodeMajor === 16 && nodeMinor >= 8) {
      let fetchImpl = null;
      module2.exports.fetch = async function fetch(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        const dispatcher = arguments[1] && arguments[1].dispatcher || getGlobalDispatcher();
        try {
          return await fetchImpl.apply(dispatcher, arguments);
        } catch (err) {
          Error.captureStackTrace(err, this);
          throw err;
        }
      };
      module2.exports.Headers = require_headers().Headers;
      module2.exports.Response = require_response().Response;
      module2.exports.Request = require_request2().Request;
      module2.exports.FormData = require_formdata().FormData;
      module2.exports.File = require_file().File;
      const { setGlobalOrigin, getGlobalOrigin } = require_global2();
      module2.exports.setGlobalOrigin = setGlobalOrigin;
      module2.exports.getGlobalOrigin = getGlobalOrigin;
    }
    module2.exports.request = makeDispatcher(api.request);
    module2.exports.stream = makeDispatcher(api.stream);
    module2.exports.pipeline = makeDispatcher(api.pipeline);
    module2.exports.connect = makeDispatcher(api.connect);
    module2.exports.upgrade = makeDispatcher(api.upgrade);
    module2.exports.MockClient = MockClient;
    module2.exports.MockPool = MockPool;
    module2.exports.MockAgent = MockAgent;
    module2.exports.mockErrors = mockErrors;
  }
});

// ../../node_modules/@discordjs/collection/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@discordjs/collection/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports2 = {};
    __export2(src_exports2, {
      Collection: () => Collection2,
      version: () => version2
    });
    module2.exports = __toCommonJS2(src_exports2);
    var Collection2 = class extends Map {
      ensure(key, defaultValueGenerator) {
        if (this.has(key))
          return this.get(key);
        if (typeof defaultValueGenerator !== "function")
          throw new TypeError(`${defaultValueGenerator} is not a function`);
        const defaultValue = defaultValueGenerator(key, this);
        this.set(key, defaultValue);
        return defaultValue;
      }
      hasAll(...keys) {
        return keys.every((k) => super.has(k));
      }
      hasAny(...keys) {
        return keys.some((k) => super.has(k));
      }
      first(amount) {
        if (typeof amount === "undefined")
          return this.values().next().value;
        if (amount < 0)
          return this.last(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.values();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      firstKey(amount) {
        if (typeof amount === "undefined")
          return this.keys().next().value;
        if (amount < 0)
          return this.lastKey(amount * -1);
        amount = Math.min(this.size, amount);
        const iter = this.keys();
        return Array.from({ length: amount }, () => iter.next().value);
      }
      last(amount) {
        const arr = [...this.values()];
        if (typeof amount === "undefined")
          return arr[arr.length - 1];
        if (amount < 0)
          return this.first(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      lastKey(amount) {
        const arr = [...this.keys()];
        if (typeof amount === "undefined")
          return arr[arr.length - 1];
        if (amount < 0)
          return this.firstKey(amount * -1);
        if (!amount)
          return [];
        return arr.slice(-amount);
      }
      at(index) {
        index = Math.floor(index);
        const arr = [...this.values()];
        return arr.at(index);
      }
      keyAt(index) {
        index = Math.floor(index);
        const arr = [...this.keys()];
        return arr.at(index);
      }
      random(amount) {
        const arr = [...this.values()];
        if (typeof amount === "undefined")
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      randomKey(amount) {
        const arr = [...this.keys()];
        if (typeof amount === "undefined")
          return arr[Math.floor(Math.random() * arr.length)];
        if (!arr.length || !amount)
          return [];
        return Array.from(
          { length: Math.min(amount, arr.length) },
          () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]
        );
      }
      reverse() {
        const entries = [...this.entries()].reverse();
        this.clear();
        for (const [key, value] of entries)
          this.set(key, value);
        return this;
      }
      find(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return val;
        }
        return void 0;
      }
      findKey(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return key;
        }
        return void 0;
      }
      sweep(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        const previousSize = this.size;
        for (const [key, val] of this) {
          if (fn(val, key, this))
            this.delete(key);
        }
        return previousSize - this.size;
      }
      filter(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        const results = new this.constructor[Symbol.species]();
        for (const [key, val] of this) {
          if (fn(val, key, this))
            results.set(key, val);
        }
        return results;
      }
      partition(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        const results = [
          new this.constructor[Symbol.species](),
          new this.constructor[Symbol.species]()
        ];
        for (const [key, val] of this) {
          if (fn(val, key, this)) {
            results[0].set(key, val);
          } else {
            results[1].set(key, val);
          }
        }
        return results;
      }
      flatMap(fn, thisArg) {
        const collections = this.map(fn, thisArg);
        return new this.constructor[Symbol.species]().concat(...collections);
      }
      map(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        const iter = this.entries();
        return Array.from({ length: this.size }, () => {
          const [key, value] = iter.next().value;
          return fn(value, key, this);
        });
      }
      mapValues(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        const coll = new this.constructor[Symbol.species]();
        for (const [key, val] of this)
          coll.set(key, fn(val, key, this));
        return coll;
      }
      some(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (fn(val, key, this))
            return true;
        }
        return false;
      }
      every(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        for (const [key, val] of this) {
          if (!fn(val, key, this))
            return false;
        }
        return true;
      }
      reduce(fn, initialValue) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        let accumulator;
        if (typeof initialValue !== "undefined") {
          accumulator = initialValue;
          for (const [key, val] of this)
            accumulator = fn(accumulator, val, key, this);
          return accumulator;
        }
        let first = true;
        for (const [key, val] of this) {
          if (first) {
            accumulator = val;
            first = false;
            continue;
          }
          accumulator = fn(accumulator, val, key, this);
        }
        if (first) {
          throw new TypeError("Reduce of empty collection with no initial value");
        }
        return accumulator;
      }
      each(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        this.forEach(fn, thisArg);
        return this;
      }
      tap(fn, thisArg) {
        if (typeof fn !== "function")
          throw new TypeError(`${fn} is not a function`);
        if (typeof thisArg !== "undefined")
          fn = fn.bind(thisArg);
        fn(this);
        return this;
      }
      clone() {
        return new this.constructor[Symbol.species](this);
      }
      concat(...collections) {
        const newColl = this.clone();
        for (const coll of collections) {
          for (const [key, val] of coll)
            newColl.set(key, val);
        }
        return newColl;
      }
      equals(collection) {
        if (!collection)
          return false;
        if (this === collection)
          return true;
        if (this.size !== collection.size)
          return false;
        for (const [key, value] of this) {
          if (!collection.has(key) || value !== collection.get(key)) {
            return false;
          }
        }
        return true;
      }
      sort(compareFunction = Collection2.defaultSort) {
        const entries = [...this.entries()];
        entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
        super.clear();
        for (const [k, v] of entries) {
          super.set(k, v);
        }
        return this;
      }
      intersect(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [k, v] of other) {
          if (this.has(k) && Object.is(v, this.get(k))) {
            coll.set(k, v);
          }
        }
        return coll;
      }
      difference(other) {
        const coll = new this.constructor[Symbol.species]();
        for (const [k, v] of other) {
          if (!this.has(k))
            coll.set(k, v);
        }
        for (const [k, v] of this) {
          if (!other.has(k))
            coll.set(k, v);
        }
        return coll;
      }
      merge(other, whenInSelf, whenInOther, whenInBoth) {
        const coll = new this.constructor[Symbol.species]();
        const keys = /* @__PURE__ */ new Set([...this.keys(), ...other.keys()]);
        for (const k of keys) {
          const hasInSelf = this.has(k);
          const hasInOther = other.has(k);
          if (hasInSelf && hasInOther) {
            const r = whenInBoth(this.get(k), other.get(k), k);
            if (r.keep)
              coll.set(k, r.value);
          } else if (hasInSelf) {
            const r = whenInSelf(this.get(k), k);
            if (r.keep)
              coll.set(k, r.value);
          } else if (hasInOther) {
            const r = whenInOther(other.get(k), k);
            if (r.keep)
              coll.set(k, r.value);
          }
        }
        return coll;
      }
      sorted(compareFunction = Collection2.defaultSort) {
        return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
      }
      toJSON() {
        return [...this.values()];
      }
      static defaultSort(firstValue, secondValue) {
        return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
      }
      static combineEntries(entries, combine) {
        const coll = new Collection2();
        for (const [k, v] of entries) {
          if (coll.has(k)) {
            coll.set(k, combine(coll.get(k), v, k));
          } else {
            coll.set(k, v);
          }
        }
        return coll;
      }
    };
    __name(Collection2, "Collection");
    var version2 = "1.2.0";
  }
});

// ../../node_modules/@discordjs/util/dist/index.js
var require_dist2 = __commonJS({
  "../../node_modules/@discordjs/util/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports2 = {};
    __export2(src_exports2, {
      isEquatable: () => isEquatable,
      isJSONEncodable: () => isJSONEncodable,
      lazy: () => lazy,
      range: () => range
    });
    module2.exports = __toCommonJS2(src_exports2);
    function lazy(cb) {
      let defaultValue;
      return () => defaultValue ?? (defaultValue = cb());
    }
    __name(lazy, "lazy");
    function range(start, end, step = 1) {
      return Array.from({ length: (end - start) / step + 1 }, (_, index) => start + index * step);
    }
    __name(range, "range");
    function isJSONEncodable(maybeEncodable) {
      return maybeEncodable !== null && typeof maybeEncodable === "object" && "toJSON" in maybeEncodable;
    }
    __name(isJSONEncodable, "isJSONEncodable");
    function isEquatable(maybeEquatable) {
      return maybeEquatable !== null && typeof maybeEquatable === "object" && "equals" in maybeEquatable;
    }
    __name(isEquatable, "isEquatable");
  }
});

// ../../node_modules/@sapphire/snowflake/dist/index.js
var require_dist3 = __commonJS({
  "../../node_modules/@sapphire/snowflake/dist/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var __publicField2 = (obj, key, value) => {
      __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var __accessCheck2 = (obj, member, msg) => {
      if (!member.has(obj))
        throw TypeError("Cannot " + msg);
    };
    var __privateGet2 = (obj, member, getter) => {
      __accessCheck2(obj, member, "read from private field");
      return getter ? getter.call(obj) : member.get(obj);
    };
    var __privateAdd2 = (obj, member, value) => {
      if (member.has(obj))
        throw TypeError("Cannot add the same private member more than once");
      member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
    };
    var __privateSet2 = (obj, member, value, setter) => {
      __accessCheck2(obj, member, "write to private field");
      setter ? setter.call(obj, value) : member.set(obj, value);
      return value;
    };
    var __privateWrapper = (obj, member, setter, getter) => {
      return {
        set _(value) {
          __privateSet2(obj, member, value, setter);
        },
        get _() {
          return __privateGet2(obj, member, getter);
        }
      };
    };
    var src_exports2 = {};
    __export2(src_exports2, {
      DiscordSnowflake: () => DiscordSnowflake,
      Snowflake: () => Snowflake,
      TwitterSnowflake: () => TwitterSnowflake
    });
    module2.exports = __toCommonJS2(src_exports2);
    var ProcessId = 1n;
    var WorkerId = 0n;
    var _increment;
    var _epoch;
    var Snowflake = class {
      constructor(epoch) {
        __privateAdd2(this, _increment, 0n);
        __privateAdd2(this, _epoch, void 0);
        __publicField2(this, "decode", this.deconstruct);
        __privateSet2(this, _epoch, BigInt(epoch instanceof Date ? epoch.getTime() : epoch));
      }
      get epoch() {
        return __privateGet2(this, _epoch);
      }
      generate({ increment, timestamp = Date.now(), workerId = WorkerId, processId = ProcessId } = {}) {
        if (timestamp instanceof Date)
          timestamp = BigInt(timestamp.getTime());
        else if (typeof timestamp === "number")
          timestamp = BigInt(timestamp);
        else if (typeof timestamp !== "bigint") {
          throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
        }
        if (typeof increment === "bigint" && increment >= 4095n)
          increment = 0n;
        else {
          increment = __privateWrapper(this, _increment)._++;
          if (__privateGet2(this, _increment) >= 4095n)
            __privateSet2(this, _increment, 0n);
        }
        return timestamp - __privateGet2(this, _epoch) << 22n | (workerId & 0b11111n) << 17n | (processId & 0b11111n) << 12n | increment;
      }
      deconstruct(id) {
        const bigIntId = BigInt(id);
        return {
          id: bigIntId,
          timestamp: (bigIntId >> 22n) + __privateGet2(this, _epoch),
          workerId: bigIntId >> 17n & 0b11111n,
          processId: bigIntId >> 12n & 0b11111n,
          increment: bigIntId & 0b111111111111n,
          epoch: __privateGet2(this, _epoch)
        };
      }
      timestampFrom(id) {
        return Number((BigInt(id) >> 22n) + __privateGet2(this, _epoch));
      }
    };
    __name(Snowflake, "Snowflake");
    _increment = /* @__PURE__ */ new WeakMap();
    _epoch = /* @__PURE__ */ new WeakMap();
    var DiscordSnowflake = new Snowflake(1420070400000n);
    var TwitterSnowflake = new Snowflake(1142974214000n);
  }
});

// ../../node_modules/@sapphire/async-queue/dist/index.js
var require_dist4 = __commonJS({
  "../../node_modules/@sapphire/async-queue/dist/index.js"(exports2, module2) {
    "use strict";
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var __publicField2 = (obj, key, value) => {
      __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
      return value;
    };
    var src_exports2 = {};
    __export2(src_exports2, {
      AsyncQueue: () => AsyncQueue
    });
    module2.exports = __toCommonJS2(src_exports2);
    var AsyncQueueEntry = class {
      constructor(queue) {
        __publicField2(this, "promise");
        __publicField2(this, "resolve");
        __publicField2(this, "reject");
        __publicField2(this, "queue");
        __publicField2(this, "signal", null);
        __publicField2(this, "signalListener", null);
        this.queue = queue;
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
      setSignal(signal) {
        if (signal.aborted)
          return this;
        this.signal = signal;
        this.signalListener = () => {
          const index = this.queue["promises"].indexOf(this);
          if (index !== -1)
            this.queue["promises"].splice(index, 1);
          this.reject(new Error("Request aborted manually"));
        };
        this.signal.addEventListener("abort", this.signalListener);
        return this;
      }
      use() {
        this.dispose();
        this.resolve();
        return this;
      }
      abort() {
        this.dispose();
        this.reject(new Error("Request aborted manually"));
        return this;
      }
      dispose() {
        if (this.signal) {
          this.signal.removeEventListener("abort", this.signalListener);
          this.signal = null;
          this.signalListener = null;
        }
      }
    };
    __name(AsyncQueueEntry, "AsyncQueueEntry");
    var AsyncQueue = class {
      constructor() {
        __publicField2(this, "promises", []);
      }
      get remaining() {
        return this.promises.length;
      }
      get queued() {
        return this.remaining === 0 ? 0 : this.remaining - 1;
      }
      wait(options) {
        const entry = new AsyncQueueEntry(this);
        if (this.promises.length === 0) {
          this.promises.push(entry);
          return Promise.resolve();
        }
        this.promises.push(entry);
        if (options == null ? void 0 : options.signal)
          entry.setSignal(options.signal);
        return entry.promise;
      }
      shift() {
        if (this.promises.length === 0)
          return;
        if (this.promises.length === 1) {
          this.promises.shift();
          return;
        }
        this.promises.shift();
        this.promises[0].use();
      }
      abortAll() {
        if (this.queued === 0)
          return;
        for (let i = 1; i < this.promises.length; ++i) {
          this.promises[i].abort();
        }
        this.promises.length = 1;
      }
    };
    __name(AsyncQueue, "AsyncQueue");
  }
});

// ../../node_modules/strtok3/lib/FsPromise.js
async function stat(path) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.stat(path, (err, stats) => {
      if (err)
        reject(err);
      else
        resolve(stats);
    });
  });
}
async function close(fd) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.close(fd, (err) => {
      if (err)
        reject(err);
      else
        resolve();
    });
  });
}
async function open(path, mode) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.open(path, mode, (err, fd) => {
      if (err)
        reject(err);
      else
        resolve(fd);
    });
  });
}
async function read(fd, buffer, offset, length, position) {
  return new Promise((resolve, reject) => {
    import_node_fs.default.read(fd, buffer, offset, length, position, (err, bytesRead, _buffer) => {
      if (err)
        reject(err);
      else
        resolve({ bytesRead, buffer: _buffer });
    });
  });
}
var import_node_fs, pathExists, createReadStream;
var init_FsPromise = __esm({
  "../../node_modules/strtok3/lib/FsPromise.js"() {
    import_node_fs = __toESM(require("fs"), 1);
    pathExists = import_node_fs.default.existsSync;
    createReadStream = import_node_fs.default.createReadStream;
  }
});

// ../../node_modules/peek-readable/lib/EndOfFileStream.js
var defaultMessages, EndOfStreamError;
var init_EndOfFileStream = __esm({
  "../../node_modules/peek-readable/lib/EndOfFileStream.js"() {
    defaultMessages = "End-Of-Stream";
    EndOfStreamError = class extends Error {
      constructor() {
        super(defaultMessages);
      }
    };
  }
});

// ../../node_modules/peek-readable/lib/Deferred.js
var Deferred;
var init_Deferred = __esm({
  "../../node_modules/peek-readable/lib/Deferred.js"() {
    Deferred = class {
      constructor() {
        this.resolve = () => null;
        this.reject = () => null;
        this.promise = new Promise((resolve, reject) => {
          this.reject = reject;
          this.resolve = resolve;
        });
      }
    };
  }
});

// ../../node_modules/peek-readable/lib/StreamReader.js
var maxStreamReadSize, StreamReader;
var init_StreamReader = __esm({
  "../../node_modules/peek-readable/lib/StreamReader.js"() {
    init_EndOfFileStream();
    init_Deferred();
    init_EndOfFileStream();
    maxStreamReadSize = 1 * 1024 * 1024;
    StreamReader = class {
      constructor(s) {
        this.s = s;
        this.deferred = null;
        this.endOfStream = false;
        this.peekQueue = [];
        if (!s.read || !s.once) {
          throw new Error("Expected an instance of stream.Readable");
        }
        this.s.once("end", () => this.reject(new EndOfStreamError()));
        this.s.once("error", (err) => this.reject(err));
        this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      async peek(uint8Array, offset, length) {
        const bytesRead = await this.read(uint8Array, offset, length);
        this.peekQueue.push(uint8Array.subarray(offset, offset + bytesRead));
        return bytesRead;
      }
      async read(buffer, offset, length) {
        if (length === 0) {
          return 0;
        }
        if (this.peekQueue.length === 0 && this.endOfStream) {
          throw new EndOfStreamError();
        }
        let remaining = length;
        let bytesRead = 0;
        while (this.peekQueue.length > 0 && remaining > 0) {
          const peekData = this.peekQueue.pop();
          if (!peekData)
            throw new Error("peekData should be defined");
          const lenCopy = Math.min(peekData.length, remaining);
          buffer.set(peekData.subarray(0, lenCopy), offset + bytesRead);
          bytesRead += lenCopy;
          remaining -= lenCopy;
          if (lenCopy < peekData.length) {
            this.peekQueue.push(peekData.subarray(lenCopy));
          }
        }
        while (remaining > 0 && !this.endOfStream) {
          const reqLen = Math.min(remaining, maxStreamReadSize);
          const chunkLen = await this.readFromStream(buffer, offset + bytesRead, reqLen);
          bytesRead += chunkLen;
          if (chunkLen < reqLen)
            break;
          remaining -= chunkLen;
        }
        return bytesRead;
      }
      async readFromStream(buffer, offset, length) {
        const readBuffer = this.s.read(length);
        if (readBuffer) {
          buffer.set(readBuffer, offset);
          return readBuffer.length;
        } else {
          const request = {
            buffer,
            offset,
            length,
            deferred: new Deferred()
          };
          this.deferred = request.deferred;
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
          return request.deferred.promise;
        }
      }
      readDeferred(request) {
        const readBuffer = this.s.read(request.length);
        if (readBuffer) {
          request.buffer.set(readBuffer, request.offset);
          request.deferred.resolve(readBuffer.length);
          this.deferred = null;
        } else {
          this.s.once("readable", () => {
            this.readDeferred(request);
          });
        }
      }
      reject(err) {
        this.endOfStream = true;
        if (this.deferred) {
          this.deferred.reject(err);
          this.deferred = null;
        }
      }
    };
  }
});

// ../../node_modules/peek-readable/lib/index.js
var init_lib = __esm({
  "../../node_modules/peek-readable/lib/index.js"() {
    init_EndOfFileStream();
    init_StreamReader();
  }
});

// ../../node_modules/strtok3/lib/AbstractTokenizer.js
var import_node_buffer, AbstractTokenizer;
var init_AbstractTokenizer = __esm({
  "../../node_modules/strtok3/lib/AbstractTokenizer.js"() {
    init_lib();
    import_node_buffer = require("buffer");
    AbstractTokenizer = class {
      constructor(fileInfo) {
        this.position = 0;
        this.numBuffer = new Uint8Array(8);
        this.fileInfo = fileInfo ? fileInfo : {};
      }
      async readToken(token, position = this.position) {
        const uint8Array = import_node_buffer.Buffer.alloc(token.len);
        const len = await this.readBuffer(uint8Array, { position });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      async peekToken(token, position = this.position) {
        const uint8Array = import_node_buffer.Buffer.alloc(token.len);
        const len = await this.peekBuffer(uint8Array, { position });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(uint8Array, 0);
      }
      async readNumber(token) {
        const len = await this.readBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      async peekNumber(token) {
        const len = await this.peekBuffer(this.numBuffer, { length: token.len });
        if (len < token.len)
          throw new EndOfStreamError();
        return token.get(this.numBuffer, 0);
      }
      async ignore(length) {
        if (this.fileInfo.size !== void 0) {
          const bytesLeft = this.fileInfo.size - this.position;
          if (length > bytesLeft) {
            this.position += bytesLeft;
            return bytesLeft;
          }
        }
        this.position += length;
        return length;
      }
      async close() {
      }
      normalizeOptions(uint8Array, options) {
        if (options && options.position !== void 0 && options.position < this.position) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (options) {
          return {
            mayBeLess: options.mayBeLess === true,
            offset: options.offset ? options.offset : 0,
            length: options.length ? options.length : uint8Array.length - (options.offset ? options.offset : 0),
            position: options.position ? options.position : this.position
          };
        }
        return {
          mayBeLess: false,
          offset: 0,
          length: uint8Array.length,
          position: this.position
        };
      }
    };
  }
});

// ../../node_modules/strtok3/lib/ReadStreamTokenizer.js
var maxBufferSize, ReadStreamTokenizer;
var init_ReadStreamTokenizer = __esm({
  "../../node_modules/strtok3/lib/ReadStreamTokenizer.js"() {
    init_AbstractTokenizer();
    init_lib();
    maxBufferSize = 256e3;
    ReadStreamTokenizer = class extends AbstractTokenizer {
      constructor(stream, fileInfo) {
        super(fileInfo);
        this.streamReader = new StreamReader(stream);
      }
      async getFileInfo() {
        return this.fileInfo;
      }
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const skipBytes = normOptions.position - this.position;
        if (skipBytes > 0) {
          await this.ignore(skipBytes);
          return this.readBuffer(uint8Array, options);
        } else if (skipBytes < 0) {
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        }
        if (normOptions.length === 0) {
          return 0;
        }
        const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length);
        this.position += bytesRead;
        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
        return bytesRead;
      }
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        let bytesRead = 0;
        if (normOptions.position) {
          const skipBytes = normOptions.position - this.position;
          if (skipBytes > 0) {
            const skipBuffer = new Uint8Array(normOptions.length + skipBytes);
            bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });
            uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset);
            return bytesRead - skipBytes;
          } else if (skipBytes < 0) {
            throw new Error("Cannot peek from a negative offset in a stream");
          }
        }
        if (normOptions.length > 0) {
          try {
            bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length);
          } catch (err) {
            if (options && options.mayBeLess && err instanceof EndOfStreamError) {
              return 0;
            }
            throw err;
          }
          if (!normOptions.mayBeLess && bytesRead < normOptions.length) {
            throw new EndOfStreamError();
          }
        }
        return bytesRead;
      }
      async ignore(length) {
        const bufSize = Math.min(maxBufferSize, length);
        const buf = new Uint8Array(bufSize);
        let totBytesRead = 0;
        while (totBytesRead < length) {
          const remaining = length - totBytesRead;
          const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });
          if (bytesRead < 0) {
            return bytesRead;
          }
          totBytesRead += bytesRead;
        }
        return totBytesRead;
      }
    };
  }
});

// ../../node_modules/strtok3/lib/BufferTokenizer.js
var BufferTokenizer;
var init_BufferTokenizer = __esm({
  "../../node_modules/strtok3/lib/BufferTokenizer.js"() {
    init_lib();
    init_AbstractTokenizer();
    BufferTokenizer = class extends AbstractTokenizer {
      constructor(uint8Array, fileInfo) {
        super(fileInfo);
        this.uint8Array = uint8Array;
        this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length;
      }
      async readBuffer(uint8Array, options) {
        if (options && options.position) {
          if (options.position < this.position) {
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          }
          this.position = options.position;
        }
        const bytesRead = await this.peekBuffer(uint8Array, options);
        this.position += bytesRead;
        return bytesRead;
      }
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length);
        if (!normOptions.mayBeLess && bytes2read < normOptions.length) {
          throw new EndOfStreamError();
        } else {
          uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset);
          return bytes2read;
        }
      }
      async close() {
      }
    };
  }
});

// ../../node_modules/strtok3/lib/core.js
function fromStream(stream, fileInfo) {
  fileInfo = fileInfo ? fileInfo : {};
  return new ReadStreamTokenizer(stream, fileInfo);
}
function fromBuffer(uint8Array, fileInfo) {
  return new BufferTokenizer(uint8Array, fileInfo);
}
var init_core = __esm({
  "../../node_modules/strtok3/lib/core.js"() {
    init_ReadStreamTokenizer();
    init_BufferTokenizer();
    init_lib();
  }
});

// ../../node_modules/strtok3/lib/FileTokenizer.js
async function fromFile(sourceFilePath) {
  const stat2 = await stat(sourceFilePath);
  if (!stat2.isFile) {
    throw new Error(`File not a file: ${sourceFilePath}`);
  }
  const fd = await open(sourceFilePath, "r");
  return new FileTokenizer(fd, { path: sourceFilePath, size: stat2.size });
}
var FileTokenizer;
var init_FileTokenizer = __esm({
  "../../node_modules/strtok3/lib/FileTokenizer.js"() {
    init_AbstractTokenizer();
    init_lib();
    init_FsPromise();
    FileTokenizer = class extends AbstractTokenizer {
      constructor(fd, fileInfo) {
        super(fileInfo);
        this.fd = fd;
      }
      async readBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        this.position = normOptions.position;
        const res = await read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        this.position += res.bytesRead;
        if (res.bytesRead < normOptions.length && (!options || !options.mayBeLess)) {
          throw new EndOfStreamError();
        }
        return res.bytesRead;
      }
      async peekBuffer(uint8Array, options) {
        const normOptions = this.normalizeOptions(uint8Array, options);
        const res = await read(this.fd, uint8Array, normOptions.offset, normOptions.length, normOptions.position);
        if (!normOptions.mayBeLess && res.bytesRead < normOptions.length) {
          throw new EndOfStreamError();
        }
        return res.bytesRead;
      }
      async close() {
        return close(this.fd);
      }
    };
  }
});

// ../../node_modules/strtok3/lib/index.js
var init_lib2 = __esm({
  "../../node_modules/strtok3/lib/index.js"() {
    init_FsPromise();
    init_core();
    init_FileTokenizer();
    init_core();
  }
});

// ../../node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/token-types/lib/index.js
function dv(array) {
  return new DataView(array.buffer, array.byteOffset);
}
var ieee754, import_node_buffer2, UINT8, UINT16_LE, UINT16_BE, UINT32_LE, UINT32_BE, INT32_BE, UINT64_LE, StringType, AnsiStringType;
var init_lib3 = __esm({
  "../../node_modules/token-types/lib/index.js"() {
    ieee754 = __toESM(require_ieee754(), 1);
    import_node_buffer2 = require("buffer");
    UINT8 = {
      len: 1,
      get(array, offset) {
        return dv(array).getUint8(offset);
      },
      put(array, offset, value) {
        dv(array).setUint8(offset, value);
        return offset + 1;
      }
    };
    UINT16_LE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value, true);
        return offset + 2;
      }
    };
    UINT16_BE = {
      len: 2,
      get(array, offset) {
        return dv(array).getUint16(offset);
      },
      put(array, offset, value) {
        dv(array).setUint16(offset, value);
        return offset + 2;
      }
    };
    UINT32_LE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset, true);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value, true);
        return offset + 4;
      }
    };
    UINT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getUint32(offset);
      },
      put(array, offset, value) {
        dv(array).setUint32(offset, value);
        return offset + 4;
      }
    };
    INT32_BE = {
      len: 4,
      get(array, offset) {
        return dv(array).getInt32(offset);
      },
      put(array, offset, value) {
        dv(array).setInt32(offset, value);
        return offset + 4;
      }
    };
    UINT64_LE = {
      len: 8,
      get(array, offset) {
        return dv(array).getBigUint64(offset, true);
      },
      put(array, offset, value) {
        dv(array).setBigUint64(offset, value, true);
        return offset + 8;
      }
    };
    StringType = class {
      constructor(len, encoding) {
        this.len = len;
        this.encoding = encoding;
      }
      get(uint8Array, offset) {
        return import_node_buffer2.Buffer.from(uint8Array).toString(this.encoding, offset, offset + this.len);
      }
    };
    AnsiStringType = class {
      constructor(len) {
        this.len = len;
      }
      static decode(buffer, offset, until) {
        let str = "";
        for (let i = offset; i < until; ++i) {
          str += AnsiStringType.codePointToString(AnsiStringType.singleByteDecoder(buffer[i]));
        }
        return str;
      }
      static inRange(a, min, max) {
        return min <= a && a <= max;
      }
      static codePointToString(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        } else {
          cp -= 65536;
          return String.fromCharCode((cp >> 10) + 55296, (cp & 1023) + 56320);
        }
      }
      static singleByteDecoder(bite) {
        if (AnsiStringType.inRange(bite, 0, 127)) {
          return bite;
        }
        const codePoint = AnsiStringType.windows1252[bite - 128];
        if (codePoint === null) {
          throw Error("invaliding encoding");
        }
        return codePoint;
      }
      get(buffer, offset = 0) {
        return AnsiStringType.decode(buffer, offset, offset + this.len);
      }
    };
    AnsiStringType.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255
    ];
  }
});

// ../../node_modules/file-type/util.js
function stringToBytes(string) {
  return [...string].map((character) => character.charCodeAt(0));
}
function tarHeaderChecksumMatches(buffer, offset = 0) {
  const readSum = Number.parseInt(buffer.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(readSum)) {
    return false;
  }
  let sum = 8 * 32;
  for (let index = offset; index < offset + 148; index++) {
    sum += buffer[index];
  }
  for (let index = offset + 156; index < offset + 512; index++) {
    sum += buffer[index];
  }
  return readSum === sum;
}
var uint32SyncSafeToken;
var init_util = __esm({
  "../../node_modules/file-type/util.js"() {
    uint32SyncSafeToken = {
      get: (buffer, offset) => buffer[offset + 3] & 127 | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,
      len: 4
    };
  }
});

// ../../node_modules/file-type/supported.js
var extensions, mimeTypes;
var init_supported = __esm({
  "../../node_modules/file-type/supported.js"() {
    extensions = [
      "jpg",
      "png",
      "apng",
      "gif",
      "webp",
      "flif",
      "xcf",
      "cr2",
      "cr3",
      "orf",
      "arw",
      "dng",
      "nef",
      "rw2",
      "raf",
      "tif",
      "bmp",
      "icns",
      "jxr",
      "psd",
      "indd",
      "zip",
      "tar",
      "rar",
      "gz",
      "bz2",
      "7z",
      "dmg",
      "mp4",
      "mid",
      "mkv",
      "webm",
      "mov",
      "avi",
      "mpg",
      "mp2",
      "mp3",
      "m4a",
      "oga",
      "ogg",
      "ogv",
      "opus",
      "flac",
      "wav",
      "spx",
      "amr",
      "pdf",
      "epub",
      "elf",
      "exe",
      "swf",
      "rtf",
      "wasm",
      "woff",
      "woff2",
      "eot",
      "ttf",
      "otf",
      "ico",
      "flv",
      "ps",
      "xz",
      "sqlite",
      "nes",
      "crx",
      "xpi",
      "cab",
      "deb",
      "ar",
      "rpm",
      "Z",
      "lz",
      "cfb",
      "mxf",
      "mts",
      "blend",
      "bpg",
      "docx",
      "pptx",
      "xlsx",
      "3gp",
      "3g2",
      "jp2",
      "jpm",
      "jpx",
      "mj2",
      "aif",
      "qcp",
      "odt",
      "ods",
      "odp",
      "xml",
      "mobi",
      "heic",
      "cur",
      "ktx",
      "ape",
      "wv",
      "dcm",
      "ics",
      "glb",
      "pcap",
      "dsf",
      "lnk",
      "alias",
      "voc",
      "ac3",
      "m4v",
      "m4p",
      "m4b",
      "f4v",
      "f4p",
      "f4b",
      "f4a",
      "mie",
      "asf",
      "ogm",
      "ogx",
      "mpc",
      "arrow",
      "shp",
      "aac",
      "mp1",
      "it",
      "s3m",
      "xm",
      "ai",
      "skp",
      "avif",
      "eps",
      "lzh",
      "pgp",
      "asar",
      "stl",
      "chm",
      "3mf",
      "zst",
      "jxl",
      "vcf"
    ];
    mimeTypes = [
      "image/jpeg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/flif",
      "image/x-xcf",
      "image/x-canon-cr2",
      "image/x-canon-cr3",
      "image/tiff",
      "image/bmp",
      "image/vnd.ms-photo",
      "image/vnd.adobe.photoshop",
      "application/x-indesign",
      "application/epub+zip",
      "application/x-xpinstall",
      "application/vnd.oasis.opendocument.text",
      "application/vnd.oasis.opendocument.spreadsheet",
      "application/vnd.oasis.opendocument.presentation",
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
      "application/zip",
      "application/x-tar",
      "application/x-rar-compressed",
      "application/gzip",
      "application/x-bzip2",
      "application/x-7z-compressed",
      "application/x-apple-diskimage",
      "application/x-apache-arrow",
      "video/mp4",
      "audio/midi",
      "video/x-matroska",
      "video/webm",
      "video/quicktime",
      "video/vnd.avi",
      "audio/vnd.wave",
      "audio/qcelp",
      "audio/x-ms-asf",
      "video/x-ms-asf",
      "application/vnd.ms-asf",
      "video/mpeg",
      "video/3gpp",
      "audio/mpeg",
      "audio/mp4",
      "audio/opus",
      "video/ogg",
      "audio/ogg",
      "application/ogg",
      "audio/x-flac",
      "audio/ape",
      "audio/wavpack",
      "audio/amr",
      "application/pdf",
      "application/x-elf",
      "application/x-msdownload",
      "application/x-shockwave-flash",
      "application/rtf",
      "application/wasm",
      "font/woff",
      "font/woff2",
      "application/vnd.ms-fontobject",
      "font/ttf",
      "font/otf",
      "image/x-icon",
      "video/x-flv",
      "application/postscript",
      "application/eps",
      "application/x-xz",
      "application/x-sqlite3",
      "application/x-nintendo-nes-rom",
      "application/x-google-chrome-extension",
      "application/vnd.ms-cab-compressed",
      "application/x-deb",
      "application/x-unix-archive",
      "application/x-rpm",
      "application/x-compress",
      "application/x-lzip",
      "application/x-cfb",
      "application/x-mie",
      "application/mxf",
      "video/mp2t",
      "application/x-blender",
      "image/bpg",
      "image/jp2",
      "image/jpx",
      "image/jpm",
      "image/mj2",
      "audio/aiff",
      "application/xml",
      "application/x-mobipocket-ebook",
      "image/heif",
      "image/heif-sequence",
      "image/heic",
      "image/heic-sequence",
      "image/icns",
      "image/ktx",
      "application/dicom",
      "audio/x-musepack",
      "text/calendar",
      "text/vcard",
      "model/gltf-binary",
      "application/vnd.tcpdump.pcap",
      "audio/x-dsf",
      "application/x.ms.shortcut",
      "application/x.apple.alias",
      "audio/x-voc",
      "audio/vnd.dolby.dd-raw",
      "audio/x-m4a",
      "image/apng",
      "image/x-olympus-orf",
      "image/x-sony-arw",
      "image/x-adobe-dng",
      "image/x-nikon-nef",
      "image/x-panasonic-rw2",
      "image/x-fujifilm-raf",
      "video/x-m4v",
      "video/3gpp2",
      "application/x-esri-shape",
      "audio/aac",
      "audio/x-it",
      "audio/x-s3m",
      "audio/x-xm",
      "video/MP1S",
      "video/MP2P",
      "application/vnd.sketchup.skp",
      "image/avif",
      "application/x-lzh-compressed",
      "application/pgp-encrypted",
      "application/x-asar",
      "model/stl",
      "application/vnd.ms-htmlhelp",
      "model/3mf",
      "image/jxl",
      "application/zstd"
    ];
  }
});

// ../../node_modules/file-type/core.js
async function fileTypeFromStream(stream) {
  const tokenizer = await fromStream(stream);
  try {
    return await fileTypeFromTokenizer(tokenizer);
  } finally {
    await tokenizer.close();
  }
}
async function fileTypeFromBuffer(input) {
  if (!(input instanceof Uint8Array || input instanceof ArrayBuffer)) {
    throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
  }
  const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
  if (!((buffer == null ? void 0 : buffer.length) > 1)) {
    return;
  }
  return fileTypeFromTokenizer(fromBuffer(buffer));
}
function _check(buffer, headers, options) {
  options = {
    offset: 0,
    ...options
  };
  for (const [index, header] of headers.entries()) {
    if (options.mask) {
      if (header !== (options.mask[index] & buffer[index + options.offset])) {
        return false;
      }
    } else if (header !== buffer[index + options.offset]) {
      return false;
    }
  }
  return true;
}
async function fileTypeFromTokenizer(tokenizer) {
  try {
    return new FileTypeParser().parse(tokenizer);
  } catch (error) {
    if (!(error instanceof EndOfStreamError)) {
      throw error;
    }
  }
}
async function fileTypeStream(readableStream, { sampleSize = minimumBytes } = {}) {
  const { default: stream } = await import("stream");
  return new Promise((resolve, reject) => {
    readableStream.on("error", reject);
    readableStream.once("readable", () => {
      (async () => {
        try {
          const pass = new stream.PassThrough();
          const outputStream = stream.pipeline ? stream.pipeline(readableStream, pass, () => {
          }) : readableStream.pipe(pass);
          const chunk = readableStream.read(sampleSize) ?? readableStream.read() ?? import_node_buffer3.Buffer.alloc(0);
          try {
            const fileType = await fileTypeFromBuffer(chunk);
            pass.fileType = fileType;
          } catch (error) {
            if (error instanceof EndOfStreamError) {
              pass.fileType = void 0;
            } else {
              reject(error);
            }
          }
          resolve(outputStream);
        } catch (error) {
          reject(error);
        }
      })();
    });
  });
}
var import_node_buffer3, minimumBytes, FileTypeParser, supportedExtensions, supportedMimeTypes;
var init_core2 = __esm({
  "../../node_modules/file-type/core.js"() {
    import_node_buffer3 = require("buffer");
    init_lib3();
    init_core();
    init_util();
    init_supported();
    minimumBytes = 4100;
    FileTypeParser = class {
      check(header, options) {
        return _check(this.buffer, header, options);
      }
      checkString(header, options) {
        return this.check(stringToBytes(header), options);
      }
      async parse(tokenizer) {
        this.buffer = import_node_buffer3.Buffer.alloc(minimumBytes);
        if (tokenizer.fileInfo.size === void 0) {
          tokenizer.fileInfo.size = Number.MAX_SAFE_INTEGER;
        }
        this.tokenizer = tokenizer;
        await tokenizer.peekBuffer(this.buffer, { length: 12, mayBeLess: true });
        if (this.check([66, 77])) {
          return {
            ext: "bmp",
            mime: "image/bmp"
          };
        }
        if (this.check([11, 119])) {
          return {
            ext: "ac3",
            mime: "audio/vnd.dolby.dd-raw"
          };
        }
        if (this.check([120, 1])) {
          return {
            ext: "dmg",
            mime: "application/x-apple-diskimage"
          };
        }
        if (this.check([77, 90])) {
          return {
            ext: "exe",
            mime: "application/x-msdownload"
          };
        }
        if (this.check([37, 33])) {
          await tokenizer.peekBuffer(this.buffer, { length: 24, mayBeLess: true });
          if (this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 })) {
            return {
              ext: "eps",
              mime: "application/eps"
            };
          }
          return {
            ext: "ps",
            mime: "application/postscript"
          };
        }
        if (this.check([31, 160]) || this.check([31, 157])) {
          return {
            ext: "Z",
            mime: "application/x-compress"
          };
        }
        if (this.check([239, 187, 191])) {
          this.tokenizer.ignore(3);
          return this.parse(tokenizer);
        }
        if (this.check([71, 73, 70])) {
          return {
            ext: "gif",
            mime: "image/gif"
          };
        }
        if (this.check([255, 216, 255])) {
          return {
            ext: "jpg",
            mime: "image/jpeg"
          };
        }
        if (this.check([73, 73, 188])) {
          return {
            ext: "jxr",
            mime: "image/vnd.ms-photo"
          };
        }
        if (this.check([31, 139, 8])) {
          return {
            ext: "gz",
            mime: "application/gzip"
          };
        }
        if (this.check([66, 90, 104])) {
          return {
            ext: "bz2",
            mime: "application/x-bzip2"
          };
        }
        if (this.checkString("ID3")) {
          await tokenizer.ignore(6);
          const id3HeaderLength = await tokenizer.readToken(uint32SyncSafeToken);
          if (tokenizer.position + id3HeaderLength > tokenizer.fileInfo.size) {
            return {
              ext: "mp3",
              mime: "audio/mpeg"
            };
          }
          await tokenizer.ignore(id3HeaderLength);
          return fileTypeFromTokenizer(tokenizer);
        }
        if (this.checkString("MP+")) {
          return {
            ext: "mpc",
            mime: "audio/x-musepack"
          };
        }
        if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) {
          return {
            ext: "swf",
            mime: "application/x-shockwave-flash"
          };
        }
        if (this.checkString("FLIF")) {
          return {
            ext: "flif",
            mime: "image/flif"
          };
        }
        if (this.checkString("8BPS")) {
          return {
            ext: "psd",
            mime: "image/vnd.adobe.photoshop"
          };
        }
        if (this.checkString("WEBP", { offset: 8 })) {
          return {
            ext: "webp",
            mime: "image/webp"
          };
        }
        if (this.checkString("MPCK")) {
          return {
            ext: "mpc",
            mime: "audio/x-musepack"
          };
        }
        if (this.checkString("FORM")) {
          return {
            ext: "aif",
            mime: "audio/aiff"
          };
        }
        if (this.checkString("icns", { offset: 0 })) {
          return {
            ext: "icns",
            mime: "image/icns"
          };
        }
        if (this.check([80, 75, 3, 4])) {
          try {
            while (tokenizer.position + 30 < tokenizer.fileInfo.size) {
              await tokenizer.readBuffer(this.buffer, { length: 30 });
              const zipHeader = {
                compressedSize: this.buffer.readUInt32LE(18),
                uncompressedSize: this.buffer.readUInt32LE(22),
                filenameLength: this.buffer.readUInt16LE(26),
                extraFieldLength: this.buffer.readUInt16LE(28)
              };
              zipHeader.filename = await tokenizer.readToken(new StringType(zipHeader.filenameLength, "utf-8"));
              await tokenizer.ignore(zipHeader.extraFieldLength);
              if (zipHeader.filename === "META-INF/mozilla.rsa") {
                return {
                  ext: "xpi",
                  mime: "application/x-xpinstall"
                };
              }
              if (zipHeader.filename.endsWith(".rels") || zipHeader.filename.endsWith(".xml")) {
                const type = zipHeader.filename.split("/")[0];
                switch (type) {
                  case "_rels":
                    break;
                  case "word":
                    return {
                      ext: "docx",
                      mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                    };
                  case "ppt":
                    return {
                      ext: "pptx",
                      mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                    };
                  case "xl":
                    return {
                      ext: "xlsx",
                      mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                    };
                  default:
                    break;
                }
              }
              if (zipHeader.filename.startsWith("xl/")) {
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              }
              if (zipHeader.filename.startsWith("3D/") && zipHeader.filename.endsWith(".model")) {
                return {
                  ext: "3mf",
                  mime: "model/3mf"
                };
              }
              if (zipHeader.filename === "mimetype" && zipHeader.compressedSize === zipHeader.uncompressedSize) {
                let mimeType = await tokenizer.readToken(new StringType(zipHeader.compressedSize, "utf-8"));
                mimeType = mimeType.trim();
                switch (mimeType) {
                  case "application/epub+zip":
                    return {
                      ext: "epub",
                      mime: "application/epub+zip"
                    };
                  case "application/vnd.oasis.opendocument.text":
                    return {
                      ext: "odt",
                      mime: "application/vnd.oasis.opendocument.text"
                    };
                  case "application/vnd.oasis.opendocument.spreadsheet":
                    return {
                      ext: "ods",
                      mime: "application/vnd.oasis.opendocument.spreadsheet"
                    };
                  case "application/vnd.oasis.opendocument.presentation":
                    return {
                      ext: "odp",
                      mime: "application/vnd.oasis.opendocument.presentation"
                    };
                  default:
                }
              }
              if (zipHeader.compressedSize === 0) {
                let nextHeaderIndex = -1;
                while (nextHeaderIndex < 0 && tokenizer.position < tokenizer.fileInfo.size) {
                  await tokenizer.peekBuffer(this.buffer, { mayBeLess: true });
                  nextHeaderIndex = this.buffer.indexOf("504B0304", 0, "hex");
                  await tokenizer.ignore(nextHeaderIndex >= 0 ? nextHeaderIndex : this.buffer.length);
                }
              } else {
                await tokenizer.ignore(zipHeader.compressedSize);
              }
            }
          } catch (error) {
            if (!(error instanceof EndOfStreamError)) {
              throw error;
            }
          }
          return {
            ext: "zip",
            mime: "application/zip"
          };
        }
        if (this.checkString("OggS")) {
          await tokenizer.ignore(28);
          const type = import_node_buffer3.Buffer.alloc(8);
          await tokenizer.readBuffer(type);
          if (_check(type, [79, 112, 117, 115, 72, 101, 97, 100])) {
            return {
              ext: "opus",
              mime: "audio/opus"
            };
          }
          if (_check(type, [128, 116, 104, 101, 111, 114, 97])) {
            return {
              ext: "ogv",
              mime: "video/ogg"
            };
          }
          if (_check(type, [1, 118, 105, 100, 101, 111, 0])) {
            return {
              ext: "ogm",
              mime: "video/ogg"
            };
          }
          if (_check(type, [127, 70, 76, 65, 67])) {
            return {
              ext: "oga",
              mime: "audio/ogg"
            };
          }
          if (_check(type, [83, 112, 101, 101, 120, 32, 32])) {
            return {
              ext: "spx",
              mime: "audio/ogg"
            };
          }
          if (_check(type, [1, 118, 111, 114, 98, 105, 115])) {
            return {
              ext: "ogg",
              mime: "audio/ogg"
            };
          }
          return {
            ext: "ogx",
            mime: "application/ogg"
          };
        }
        if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) {
          return {
            ext: "zip",
            mime: "application/zip"
          };
        }
        if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
          const brandMajor = this.buffer.toString("binary", 8, 12).replace("\0", " ").trim();
          switch (brandMajor) {
            case "avif":
            case "avis":
              return { ext: "avif", mime: "image/avif" };
            case "mif1":
              return { ext: "heic", mime: "image/heif" };
            case "msf1":
              return { ext: "heic", mime: "image/heif-sequence" };
            case "heic":
            case "heix":
              return { ext: "heic", mime: "image/heic" };
            case "hevc":
            case "hevx":
              return { ext: "heic", mime: "image/heic-sequence" };
            case "qt":
              return { ext: "mov", mime: "video/quicktime" };
            case "M4V":
            case "M4VH":
            case "M4VP":
              return { ext: "m4v", mime: "video/x-m4v" };
            case "M4P":
              return { ext: "m4p", mime: "video/mp4" };
            case "M4B":
              return { ext: "m4b", mime: "audio/mp4" };
            case "M4A":
              return { ext: "m4a", mime: "audio/x-m4a" };
            case "F4V":
              return { ext: "f4v", mime: "video/mp4" };
            case "F4P":
              return { ext: "f4p", mime: "video/mp4" };
            case "F4A":
              return { ext: "f4a", mime: "audio/mp4" };
            case "F4B":
              return { ext: "f4b", mime: "audio/mp4" };
            case "crx":
              return { ext: "cr3", mime: "image/x-canon-cr3" };
            default:
              if (brandMajor.startsWith("3g")) {
                if (brandMajor.startsWith("3g2")) {
                  return { ext: "3g2", mime: "video/3gpp2" };
                }
                return { ext: "3gp", mime: "video/3gpp" };
              }
              return { ext: "mp4", mime: "video/mp4" };
          }
        }
        if (this.checkString("MThd")) {
          return {
            ext: "mid",
            mime: "audio/midi"
          };
        }
        if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
          return {
            ext: "woff",
            mime: "font/woff"
          };
        }
        if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) {
          return {
            ext: "woff2",
            mime: "font/woff2"
          };
        }
        if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) {
          return {
            ext: "pcap",
            mime: "application/vnd.tcpdump.pcap"
          };
        }
        if (this.checkString("DSD ")) {
          return {
            ext: "dsf",
            mime: "audio/x-dsf"
          };
        }
        if (this.checkString("LZIP")) {
          return {
            ext: "lz",
            mime: "application/x-lzip"
          };
        }
        if (this.checkString("fLaC")) {
          return {
            ext: "flac",
            mime: "audio/x-flac"
          };
        }
        if (this.check([66, 80, 71, 251])) {
          return {
            ext: "bpg",
            mime: "image/bpg"
          };
        }
        if (this.checkString("wvpk")) {
          return {
            ext: "wv",
            mime: "audio/wavpack"
          };
        }
        if (this.checkString("%PDF")) {
          await tokenizer.ignore(1350);
          const maxBufferSize2 = 10 * 1024 * 1024;
          const buffer = import_node_buffer3.Buffer.alloc(Math.min(maxBufferSize2, tokenizer.fileInfo.size));
          await tokenizer.readBuffer(buffer, { mayBeLess: true });
          if (buffer.includes(import_node_buffer3.Buffer.from("AIPrivateData"))) {
            return {
              ext: "ai",
              mime: "application/postscript"
            };
          }
          return {
            ext: "pdf",
            mime: "application/pdf"
          };
        }
        if (this.check([0, 97, 115, 109])) {
          return {
            ext: "wasm",
            mime: "application/wasm"
          };
        }
        if (this.check([73, 73])) {
          const fileType = await this.readTiffHeader(false);
          if (fileType) {
            return fileType;
          }
        }
        if (this.check([77, 77])) {
          const fileType = await this.readTiffHeader(true);
          if (fileType) {
            return fileType;
          }
        }
        if (this.checkString("MAC ")) {
          return {
            ext: "ape",
            mime: "audio/ape"
          };
        }
        if (this.check([26, 69, 223, 163])) {
          async function readField() {
            const msb = await tokenizer.peekNumber(UINT8);
            let mask = 128;
            let ic = 0;
            while ((msb & mask) === 0 && mask !== 0) {
              ++ic;
              mask >>= 1;
            }
            const id = import_node_buffer3.Buffer.alloc(ic + 1);
            await tokenizer.readBuffer(id);
            return id;
          }
          async function readElement() {
            const id = await readField();
            const lengthField = await readField();
            lengthField[0] ^= 128 >> lengthField.length - 1;
            const nrLength = Math.min(6, lengthField.length);
            return {
              id: id.readUIntBE(0, id.length),
              len: lengthField.readUIntBE(lengthField.length - nrLength, nrLength)
            };
          }
          async function readChildren(children) {
            while (children > 0) {
              const element = await readElement();
              if (element.id === 17026) {
                const rawValue = await tokenizer.readToken(new StringType(element.len, "utf-8"));
                return rawValue.replace(/\00.*$/g, "");
              }
              await tokenizer.ignore(element.len);
              --children;
            }
          }
          const re = await readElement();
          const docType = await readChildren(re.len);
          switch (docType) {
            case "webm":
              return {
                ext: "webm",
                mime: "video/webm"
              };
            case "matroska":
              return {
                ext: "mkv",
                mime: "video/x-matroska"
              };
            default:
              return;
          }
        }
        if (this.check([82, 73, 70, 70])) {
          if (this.check([65, 86, 73], { offset: 8 })) {
            return {
              ext: "avi",
              mime: "video/vnd.avi"
            };
          }
          if (this.check([87, 65, 86, 69], { offset: 8 })) {
            return {
              ext: "wav",
              mime: "audio/vnd.wave"
            };
          }
          if (this.check([81, 76, 67, 77], { offset: 8 })) {
            return {
              ext: "qcp",
              mime: "audio/qcelp"
            };
          }
        }
        if (this.checkString("SQLi")) {
          return {
            ext: "sqlite",
            mime: "application/x-sqlite3"
          };
        }
        if (this.check([78, 69, 83, 26])) {
          return {
            ext: "nes",
            mime: "application/x-nintendo-nes-rom"
          };
        }
        if (this.checkString("Cr24")) {
          return {
            ext: "crx",
            mime: "application/x-google-chrome-extension"
          };
        }
        if (this.checkString("MSCF") || this.checkString("ISc(")) {
          return {
            ext: "cab",
            mime: "application/vnd.ms-cab-compressed"
          };
        }
        if (this.check([237, 171, 238, 219])) {
          return {
            ext: "rpm",
            mime: "application/x-rpm"
          };
        }
        if (this.check([197, 208, 211, 198])) {
          return {
            ext: "eps",
            mime: "application/eps"
          };
        }
        if (this.check([40, 181, 47, 253])) {
          return {
            ext: "zst",
            mime: "application/zstd"
          };
        }
        if (this.check([127, 69, 76, 70])) {
          return {
            ext: "elf",
            mime: "application/x-elf"
          };
        }
        if (this.check([79, 84, 84, 79, 0])) {
          return {
            ext: "otf",
            mime: "font/otf"
          };
        }
        if (this.checkString("#!AMR")) {
          return {
            ext: "amr",
            mime: "audio/amr"
          };
        }
        if (this.checkString("{\\rtf")) {
          return {
            ext: "rtf",
            mime: "application/rtf"
          };
        }
        if (this.check([70, 76, 86, 1])) {
          return {
            ext: "flv",
            mime: "video/x-flv"
          };
        }
        if (this.checkString("IMPM")) {
          return {
            ext: "it",
            mime: "audio/x-it"
          };
        }
        if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) {
          return {
            ext: "lzh",
            mime: "application/x-lzh-compressed"
          };
        }
        if (this.check([0, 0, 1, 186])) {
          if (this.check([33], { offset: 4, mask: [241] })) {
            return {
              ext: "mpg",
              mime: "video/MP1S"
            };
          }
          if (this.check([68], { offset: 4, mask: [196] })) {
            return {
              ext: "mpg",
              mime: "video/MP2P"
            };
          }
        }
        if (this.checkString("ITSF")) {
          return {
            ext: "chm",
            mime: "application/vnd.ms-htmlhelp"
          };
        }
        if (this.check([253, 55, 122, 88, 90, 0])) {
          return {
            ext: "xz",
            mime: "application/x-xz"
          };
        }
        if (this.checkString("<?xml ")) {
          return {
            ext: "xml",
            mime: "application/xml"
          };
        }
        if (this.check([55, 122, 188, 175, 39, 28])) {
          return {
            ext: "7z",
            mime: "application/x-7z-compressed"
          };
        }
        if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) {
          return {
            ext: "rar",
            mime: "application/x-rar-compressed"
          };
        }
        if (this.checkString("solid ")) {
          return {
            ext: "stl",
            mime: "model/stl"
          };
        }
        if (this.checkString("BLENDER")) {
          return {
            ext: "blend",
            mime: "application/x-blender"
          };
        }
        if (this.checkString("!<arch>")) {
          await tokenizer.ignore(8);
          const string = await tokenizer.readToken(new StringType(13, "ascii"));
          if (string === "debian-binary") {
            return {
              ext: "deb",
              mime: "application/x-deb"
            };
          }
          return {
            ext: "ar",
            mime: "application/x-unix-archive"
          };
        }
        if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
          await tokenizer.ignore(8);
          async function readChunkHeader() {
            return {
              length: await tokenizer.readToken(INT32_BE),
              type: await tokenizer.readToken(new StringType(4, "binary"))
            };
          }
          do {
            const chunk = await readChunkHeader();
            if (chunk.length < 0) {
              return;
            }
            switch (chunk.type) {
              case "IDAT":
                return {
                  ext: "png",
                  mime: "image/png"
                };
              case "acTL":
                return {
                  ext: "apng",
                  mime: "image/apng"
                };
              default:
                await tokenizer.ignore(chunk.length + 4);
            }
          } while (tokenizer.position + 8 < tokenizer.fileInfo.size);
          return {
            ext: "png",
            mime: "image/png"
          };
        }
        if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) {
          return {
            ext: "arrow",
            mime: "application/x-apache-arrow"
          };
        }
        if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) {
          return {
            ext: "glb",
            mime: "model/gltf-binary"
          };
        }
        if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) {
          return {
            ext: "mov",
            mime: "video/quicktime"
          };
        }
        if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
          return {
            ext: "orf",
            mime: "image/x-olympus-orf"
          };
        }
        if (this.checkString("gimp xcf ")) {
          return {
            ext: "xcf",
            mime: "image/x-xcf"
          };
        }
        if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) {
          return {
            ext: "rw2",
            mime: "image/x-panasonic-rw2"
          };
        }
        if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
          async function readHeader() {
            const guid = import_node_buffer3.Buffer.alloc(16);
            await tokenizer.readBuffer(guid);
            return {
              id: guid,
              size: Number(await tokenizer.readToken(UINT64_LE))
            };
          }
          await tokenizer.ignore(30);
          while (tokenizer.position + 24 < tokenizer.fileInfo.size) {
            const header = await readHeader();
            let payload = header.size - 24;
            if (_check(header.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
              const typeId = import_node_buffer3.Buffer.alloc(16);
              payload -= await tokenizer.readBuffer(typeId);
              if (_check(typeId, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                return {
                  ext: "asf",
                  mime: "audio/x-ms-asf"
                };
              }
              if (_check(typeId, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) {
                return {
                  ext: "asf",
                  mime: "video/x-ms-asf"
                };
              }
              break;
            }
            await tokenizer.ignore(payload);
          }
          return {
            ext: "asf",
            mime: "application/vnd.ms-asf"
          };
        }
        if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
          return {
            ext: "ktx",
            mime: "image/ktx"
          };
        }
        if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) {
          return {
            ext: "mie",
            mime: "application/x-mie"
          };
        }
        if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) {
          return {
            ext: "shp",
            mime: "application/x-esri-shape"
          };
        }
        if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
          await tokenizer.ignore(20);
          const type = await tokenizer.readToken(new StringType(4, "ascii"));
          switch (type) {
            case "jp2 ":
              return {
                ext: "jp2",
                mime: "image/jp2"
              };
            case "jpx ":
              return {
                ext: "jpx",
                mime: "image/jpx"
              };
            case "jpm ":
              return {
                ext: "jpm",
                mime: "image/jpm"
              };
            case "mjp2":
              return {
                ext: "mj2",
                mime: "image/mj2"
              };
            default:
              return;
          }
        }
        if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) {
          return {
            ext: "jxl",
            mime: "image/jxl"
          };
        }
        if (this.check([254, 255])) {
          if (this.check([0, 60, 0, 63, 0, 120, 0, 109, 0, 108], { offset: 2 })) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          return void 0;
        }
        if (this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) {
          return {
            ext: "mpg",
            mime: "video/mpeg"
          };
        }
        if (this.check([0, 1, 0, 0, 0])) {
          return {
            ext: "ttf",
            mime: "font/ttf"
          };
        }
        if (this.check([0, 0, 1, 0])) {
          return {
            ext: "ico",
            mime: "image/x-icon"
          };
        }
        if (this.check([0, 0, 2, 0])) {
          return {
            ext: "cur",
            mime: "image/x-icon"
          };
        }
        if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) {
          return {
            ext: "cfb",
            mime: "application/x-cfb"
          };
        }
        await tokenizer.peekBuffer(this.buffer, { length: Math.min(256, tokenizer.fileInfo.size), mayBeLess: true });
        if (this.checkString("BEGIN:")) {
          if (this.checkString("VCARD", { offset: 6 })) {
            return {
              ext: "vcf",
              mime: "text/vcard"
            };
          }
          if (this.checkString("VCALENDAR", { offset: 6 })) {
            return {
              ext: "ics",
              mime: "text/calendar"
            };
          }
        }
        if (this.checkString("FUJIFILMCCD-RAW")) {
          return {
            ext: "raf",
            mime: "image/x-fujifilm-raf"
          };
        }
        if (this.checkString("Extended Module:")) {
          return {
            ext: "xm",
            mime: "audio/x-xm"
          };
        }
        if (this.checkString("Creative Voice File")) {
          return {
            ext: "voc",
            mime: "audio/x-voc"
          };
        }
        if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
          const jsonSize = this.buffer.readUInt32LE(12);
          if (jsonSize > 12 && this.buffer.length >= jsonSize + 16) {
            try {
              const header = this.buffer.slice(16, jsonSize + 16).toString();
              const json = JSON.parse(header);
              if (json.files) {
                return {
                  ext: "asar",
                  mime: "application/x-asar"
                };
              }
            } catch {
            }
          }
        }
        if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
          return {
            ext: "mxf",
            mime: "application/mxf"
          };
        }
        if (this.checkString("SCRM", { offset: 44 })) {
          return {
            ext: "s3m",
            mime: "audio/x-s3m"
          };
        }
        if (this.check([71]) && this.check([71], { offset: 188 })) {
          return {
            ext: "mts",
            mime: "video/mp2t"
          };
        }
        if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) {
          return {
            ext: "mts",
            mime: "video/mp2t"
          };
        }
        if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
          return {
            ext: "mobi",
            mime: "application/x-mobipocket-ebook"
          };
        }
        if (this.check([68, 73, 67, 77], { offset: 128 })) {
          return {
            ext: "dcm",
            mime: "application/dicom"
          };
        }
        if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
          return {
            ext: "lnk",
            mime: "application/x.ms.shortcut"
          };
        }
        if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
          return {
            ext: "alias",
            mime: "application/x.apple.alias"
          };
        }
        if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) {
          return {
            ext: "eot",
            mime: "application/vnd.ms-fontobject"
          };
        }
        if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) {
          return {
            ext: "indd",
            mime: "application/x-indesign"
          };
        }
        await tokenizer.peekBuffer(this.buffer, { length: Math.min(512, tokenizer.fileInfo.size), mayBeLess: true });
        if (tarHeaderChecksumMatches(this.buffer)) {
          return {
            ext: "tar",
            mime: "application/x-tar"
          };
        }
        if (this.check([255, 254])) {
          if (this.check([60, 0, 63, 0, 120, 0, 109, 0, 108, 0], { offset: 2 })) {
            return {
              ext: "xml",
              mime: "application/xml"
            };
          }
          if (this.check([255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0], { offset: 2 })) {
            return {
              ext: "skp",
              mime: "application/vnd.sketchup.skp"
            };
          }
          return void 0;
        }
        if (this.checkString("-----BEGIN PGP MESSAGE-----")) {
          return {
            ext: "pgp",
            mime: "application/pgp-encrypted"
          };
        }
        if (this.buffer.length >= 2 && this.check([255, 224], { offset: 0, mask: [255, 224] })) {
          if (this.check([16], { offset: 1, mask: [22] })) {
            if (this.check([8], { offset: 1, mask: [8] })) {
              return {
                ext: "aac",
                mime: "audio/aac"
              };
            }
            return {
              ext: "aac",
              mime: "audio/aac"
            };
          }
          if (this.check([2], { offset: 1, mask: [6] })) {
            return {
              ext: "mp3",
              mime: "audio/mpeg"
            };
          }
          if (this.check([4], { offset: 1, mask: [6] })) {
            return {
              ext: "mp2",
              mime: "audio/mpeg"
            };
          }
          if (this.check([6], { offset: 1, mask: [6] })) {
            return {
              ext: "mp1",
              mime: "audio/mpeg"
            };
          }
        }
      }
      async readTiffTag(bigEndian) {
        const tagId = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
        this.tokenizer.ignore(10);
        switch (tagId) {
          case 50341:
            return {
              ext: "arw",
              mime: "image/x-sony-arw"
            };
          case 50706:
            return {
              ext: "dng",
              mime: "image/x-adobe-dng"
            };
          default:
        }
      }
      async readTiffIFD(bigEndian) {
        const numberOfTags = await this.tokenizer.readToken(bigEndian ? UINT16_BE : UINT16_LE);
        for (let n = 0; n < numberOfTags; ++n) {
          const fileType = await this.readTiffTag(bigEndian);
          if (fileType) {
            return fileType;
          }
        }
      }
      async readTiffHeader(bigEndian) {
        const version2 = (bigEndian ? UINT16_BE : UINT16_LE).get(this.buffer, 2);
        const ifdOffset = (bigEndian ? UINT32_BE : UINT32_LE).get(this.buffer, 4);
        if (version2 === 42) {
          if (ifdOffset >= 6) {
            if (this.checkString("CR", { offset: 8 })) {
              return {
                ext: "cr2",
                mime: "image/x-canon-cr2"
              };
            }
            if (ifdOffset >= 8 && (this.check([28, 0, 254, 0], { offset: 8 }) || this.check([31, 0, 11, 0], { offset: 8 }))) {
              return {
                ext: "nef",
                mime: "image/x-nikon-nef"
              };
            }
          }
          await this.tokenizer.ignore(ifdOffset);
          const fileType = await this.readTiffIFD(false);
          return fileType ? fileType : {
            ext: "tif",
            mime: "image/tiff"
          };
        }
        if (version2 === 43) {
          return {
            ext: "tif",
            mime: "image/tiff"
          };
        }
      }
    };
    supportedExtensions = new Set(extensions);
    supportedMimeTypes = new Set(mimeTypes);
  }
});

// ../../node_modules/file-type/index.js
var file_type_exports = {};
__export(file_type_exports, {
  fileTypeFromBuffer: () => fileTypeFromBuffer,
  fileTypeFromFile: () => fileTypeFromFile,
  fileTypeFromStream: () => fileTypeFromStream,
  fileTypeFromTokenizer: () => fileTypeFromTokenizer,
  fileTypeStream: () => fileTypeStream,
  supportedExtensions: () => supportedExtensions,
  supportedMimeTypes: () => supportedMimeTypes
});
async function fileTypeFromFile(path) {
  const tokenizer = await fromFile(path);
  try {
    return await fileTypeFromTokenizer(tokenizer);
  } finally {
    await tokenizer.close();
  }
}
var init_file_type = __esm({
  "../../node_modules/file-type/index.js"() {
    init_lib2();
    init_core2();
    init_core2();
  }
});

// ../../node_modules/@discordjs/rest/dist/index.js
var require_dist5 = __commonJS({
  "../../node_modules/@discordjs/rest/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports2 = {};
    __export2(src_exports2, {
      ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
      ALLOWED_SIZES: () => ALLOWED_SIZES,
      ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
      CDN: () => CDN,
      DefaultRestOptions: () => DefaultRestOptions,
      DefaultUserAgent: () => DefaultUserAgent,
      DiscordAPIError: () => DiscordAPIError,
      HTTPError: () => HTTPError,
      REST: () => REST2,
      RESTEvents: () => RESTEvents,
      RateLimitError: () => RateLimitError,
      RequestManager: () => RequestManager,
      RequestMethod: () => RequestMethod,
      makeURLSearchParams: () => makeURLSearchParams2,
      parseResponse: () => parseResponse,
      version: () => version2
    });
    module2.exports = __toCommonJS2(src_exports2);
    var import_node_url = require("url");
    var import_node_process2 = __toESM2(require("process"));
    var import_v10 = require_v106();
    var import_undici = require_undici();
    var DefaultUserAgent = `DiscordBot (https://discord.js.org, 1.3.0)`;
    var DefaultRestOptions = {
      get agent() {
        return new import_undici.Agent({
          connect: {
            timeout: 3e4
          }
        });
      },
      api: "https://discord.com/api",
      authPrefix: "Bot",
      cdn: "https://cdn.discordapp.com",
      headers: {},
      invalidRequestWarningInterval: 0,
      globalRequestsPerSecond: 50,
      offset: 50,
      rejectOnRateLimit: null,
      retries: 3,
      timeout: 15e3,
      userAgentAppendix: `Node.js ${import_node_process2.default.version}`,
      version: import_v10.APIVersion,
      hashSweepInterval: 144e5,
      hashLifetime: 864e5,
      handlerSweepInterval: 36e5
    };
    var RESTEvents = /* @__PURE__ */ ((RESTEvents2) => {
      RESTEvents2["Debug"] = "restDebug";
      RESTEvents2["HandlerSweep"] = "handlerSweep";
      RESTEvents2["HashSweep"] = "hashSweep";
      RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
      RESTEvents2["RateLimited"] = "rateLimited";
      RESTEvents2["Response"] = "response";
      return RESTEvents2;
    })(RESTEvents || {});
    var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
    var ALLOWED_STICKER_EXTENSIONS = ["png", "json"];
    var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
    var CDN = class {
      constructor(base = DefaultRestOptions.cdn) {
        this.base = base;
      }
      appAsset(clientId, assetHash, options) {
        return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
      }
      appIcon(clientId, iconHash, options) {
        return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
      }
      avatar(id, avatarHash, options) {
        return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
      }
      banner(id, bannerHash, options) {
        return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
      }
      channelIcon(channelId, iconHash, options) {
        return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
      }
      defaultAvatar(discriminator) {
        return this.makeURL(`/embed/avatars/${discriminator}`, { extension: "png" });
      }
      discoverySplash(guildId, splashHash, options) {
        return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
      }
      emoji(emojiId, extension) {
        return this.makeURL(`/emojis/${emojiId}`, { extension });
      }
      guildMemberAvatar(guildId, userId, avatarHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
      }
      guildMemberBanner(guildId, userId, bannerHash, options) {
        return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
      }
      icon(id, iconHash, options) {
        return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
      }
      roleIcon(roleId, roleIconHash, options) {
        return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
      }
      splash(guildId, splashHash, options) {
        return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
      }
      sticker(stickerId, extension) {
        return this.makeURL(`/stickers/${stickerId}`, {
          allowedExtensions: ALLOWED_STICKER_EXTENSIONS,
          extension: extension ?? "png"
        });
      }
      stickerPackBanner(bannerId, options) {
        return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
      }
      teamIcon(teamId, iconHash, options) {
        return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
      }
      guildScheduledEventCover(scheduledEventId, coverHash, options) {
        return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
      }
      dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
        return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
      }
      makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
        extension = String(extension).toLowerCase();
        if (!allowedExtensions.includes(extension)) {
          throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
        }
        if (size && !ALLOWED_SIZES.includes(size)) {
          throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
        }
        const url = new import_node_url.URL(`${this.base}${route}.${extension}`);
        if (size) {
          url.searchParams.set("size", String(size));
        }
        return url.toString();
      }
    };
    __name(CDN, "CDN");
    function isErrorGroupWrapper(error) {
      return Reflect.has(error, "_errors");
    }
    __name(isErrorGroupWrapper, "isErrorGroupWrapper");
    function isErrorResponse(error) {
      return typeof Reflect.get(error, "message") === "string";
    }
    __name(isErrorResponse, "isErrorResponse");
    var DiscordAPIError = class extends Error {
      constructor(rawError, code, status, method, url, bodyData) {
        super(DiscordAPIError.getMessage(rawError));
        this.rawError = rawError;
        this.code = code;
        this.status = status;
        this.method = method;
        this.url = url;
        this.requestBody = { files: bodyData.files, json: bodyData.body };
      }
      requestBody;
      get name() {
        return `${DiscordAPIError.name}[${this.code}]`;
      }
      static getMessage(error) {
        let flattened = "";
        if ("code" in error) {
          if (error.errors) {
            flattened = [...this.flattenDiscordError(error.errors)].join("\n");
          }
          return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
        }
        return error.error_description ?? "No Description";
      }
      static *flattenDiscordError(obj, key = "") {
        if (isErrorResponse(obj)) {
          return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
        }
        for (const [otherKey, val] of Object.entries(obj)) {
          const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
          if (typeof val === "string") {
            yield val;
          } else if (isErrorGroupWrapper(val)) {
            for (const error of val._errors) {
              yield* this.flattenDiscordError(error, nextKey);
            }
          } else {
            yield* this.flattenDiscordError(val, nextKey);
          }
        }
      }
    };
    __name(DiscordAPIError, "DiscordAPIError");
    var import_node_http = require("http");
    var HTTPError = class extends Error {
      constructor(status, method, url, bodyData) {
        super(import_node_http.STATUS_CODES[status]);
        this.status = status;
        this.method = method;
        this.url = url;
        this.requestBody = { files: bodyData.files, json: bodyData.body };
      }
      requestBody;
      name = HTTPError.name;
    };
    __name(HTTPError, "HTTPError");
    var RateLimitError = class extends Error {
      timeToReset;
      limit;
      method;
      hash;
      url;
      route;
      majorParameter;
      global;
      constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global: global2 }) {
        super();
        this.timeToReset = timeToReset;
        this.limit = limit;
        this.method = method;
        this.hash = hash;
        this.url = url;
        this.route = route;
        this.majorParameter = majorParameter;
        this.global = global2;
      }
      get name() {
        return `${RateLimitError.name}[${this.route}]`;
      }
    };
    __name(RateLimitError, "RateLimitError");
    var import_node_buffer22 = require("buffer");
    var import_node_events = require("events");
    var import_node_timers2 = require("timers");
    var import_collection = require_dist();
    var import_util2 = require_dist2();
    var import_snowflake = require_dist3();
    var import_undici4 = require_undici();
    var import_node_timers = require("timers");
    var import_promises = require("timers/promises");
    var import_async_queue = require_dist4();
    var import_undici3 = require_undici();
    var import_node_buffer4 = require("buffer");
    var import_node_url2 = require("url");
    var import_node_util = require("util");
    var import_undici2 = require_undici();
    function parseHeader(header) {
      if (header === void 0 || typeof header === "string") {
        return header;
      }
      return header.join(";");
    }
    __name(parseHeader, "parseHeader");
    function serializeSearchParam(value) {
      switch (typeof value) {
        case "string":
          return value;
        case "number":
        case "bigint":
        case "boolean":
          return value.toString();
        case "object":
          if (value === null)
            return null;
          if (value instanceof Date) {
            return Number.isNaN(value.getTime()) ? null : value.toISOString();
          }
          if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
            return value.toString();
          return null;
        default:
          return null;
      }
    }
    __name(serializeSearchParam, "serializeSearchParam");
    function makeURLSearchParams2(options) {
      const params = new import_node_url2.URLSearchParams();
      if (!options)
        return params;
      for (const [key, value] of Object.entries(options)) {
        const serialized = serializeSearchParam(value);
        if (serialized !== null)
          params.append(key, serialized);
      }
      return params;
    }
    __name(makeURLSearchParams2, "makeURLSearchParams");
    async function parseResponse(res) {
      const header = parseHeader(res.headers["content-type"]);
      if (header == null ? void 0 : header.startsWith("application/json")) {
        return res.body.json();
      }
      return res.body.arrayBuffer();
    }
    __name(parseResponse, "parseResponse");
    function hasSublimit(bucketRoute, body, method) {
      if (bucketRoute === "/channels/:id") {
        if (typeof body !== "object" || body === null)
          return false;
        if (method !== "PATCH")
          return false;
        const castedBody = body;
        return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
      }
      return true;
    }
    __name(hasSublimit, "hasSublimit");
    async function resolveBody(body) {
      if (body == null) {
        return null;
      } else if (typeof body === "string") {
        return body;
      } else if (import_node_util.types.isUint8Array(body)) {
        return body;
      } else if (import_node_util.types.isArrayBuffer(body)) {
        return new Uint8Array(body);
      } else if (body instanceof import_node_url2.URLSearchParams) {
        return body.toString();
      } else if (body instanceof DataView) {
        return new Uint8Array(body.buffer);
      } else if (body instanceof import_node_buffer4.Blob) {
        return new Uint8Array(await body.arrayBuffer());
      } else if (body instanceof import_undici2.FormData) {
        return body;
      } else if (body[Symbol.iterator]) {
        const chunks = [...body];
        const length = chunks.reduce((a, b) => a + b.length, 0);
        const uint8 = new Uint8Array(length);
        let lengthUsed = 0;
        return chunks.reduce((a, b) => {
          a.set(b, lengthUsed);
          lengthUsed += b.length;
          return a;
        }, uint8);
      } else if (body[Symbol.asyncIterator]) {
        const chunks = [];
        for await (const chunk of body) {
          chunks.push(chunk);
        }
        return import_node_buffer4.Buffer.concat(chunks);
      }
      throw new TypeError(`Unable to resolve body.`);
    }
    __name(resolveBody, "resolveBody");
    var invalidCount = 0;
    var invalidCountResetTime = null;
    var _asyncQueue, _sublimitedQueue, _sublimitPromise, _shiftSublimit, _a;
    var SequentialHandler = (_a = class {
      constructor(manager, hash, majorParameter) {
        __publicField(this, "id");
        __publicField(this, "reset", -1);
        __publicField(this, "remaining", 1);
        __publicField(this, "limit", Number.POSITIVE_INFINITY);
        __privateAdd(this, _asyncQueue, new import_async_queue.AsyncQueue());
        __privateAdd(this, _sublimitedQueue, null);
        __privateAdd(this, _sublimitPromise, null);
        __privateAdd(this, _shiftSublimit, false);
        this.manager = manager;
        this.hash = hash;
        this.majorParameter = majorParameter;
        this.id = `${hash}:${majorParameter}`;
      }
      get inactive() {
        return __privateGet(this, _asyncQueue).remaining === 0 && (__privateGet(this, _sublimitedQueue) === null || __privateGet(this, _sublimitedQueue).remaining === 0) && !this.limited;
      }
      get globalLimited() {
        return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
      }
      get localLimited() {
        return this.remaining <= 0 && Date.now() < this.reset;
      }
      get limited() {
        return this.globalLimited || this.localLimited;
      }
      get timeToReset() {
        return this.reset + this.manager.options.offset - Date.now();
      }
      debug(message) {
        this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
      }
      async globalDelayFor(time) {
        await (0, import_promises.setTimeout)(time, void 0, { ref: false });
        this.manager.globalDelay = null;
      }
      async onRateLimit(rateLimitData) {
        const { options } = this.manager;
        if (!options.rejectOnRateLimit)
          return;
        const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
        if (shouldThrow) {
          throw new RateLimitError(rateLimitData);
        }
      }
      async queueRequest(routeId, url, options, requestData) {
        var _a3, _b, _c;
        let queue = __privateGet(this, _asyncQueue);
        let queueType = 0;
        if (__privateGet(this, _sublimitedQueue) && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = __privateGet(this, _sublimitedQueue);
          queueType = 1;
        }
        await queue.wait({ signal: requestData.signal });
        if (queueType === 0) {
          if (__privateGet(this, _sublimitedQueue) && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
            queue = __privateGet(this, _sublimitedQueue);
            const wait = queue.wait();
            __privateGet(this, _asyncQueue).shift();
            await wait;
          } else if (__privateGet(this, _sublimitPromise)) {
            await __privateGet(this, _sublimitPromise).promise;
          }
        }
        try {
          return await this.runRequest(routeId, url, options, requestData);
        } finally {
          queue.shift();
          if (__privateGet(this, _shiftSublimit)) {
            __privateSet(this, _shiftSublimit, false);
            (_a3 = __privateGet(this, _sublimitedQueue)) == null ? void 0 : _a3.shift();
          }
          if (((_b = __privateGet(this, _sublimitedQueue)) == null ? void 0 : _b.remaining) === 0) {
            (_c = __privateGet(this, _sublimitPromise)) == null ? void 0 : _c.resolve();
            __privateSet(this, _sublimitedQueue, null);
          }
        }
      }
      async runRequest(routeId, url, options, requestData, retries = 0) {
        var _a3;
        while (this.limited) {
          const isGlobal = this.globalLimited;
          let limit2;
          let timeout2;
          let delay;
          if (isGlobal) {
            limit2 = this.manager.options.globalRequestsPerSecond;
            timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();
            if (!this.manager.globalDelay) {
              this.manager.globalDelay = this.globalDelayFor(timeout2);
            }
            delay = this.manager.globalDelay;
          } else {
            limit2 = this.limit;
            timeout2 = this.timeToReset;
            delay = (0, import_promises.setTimeout)(timeout2);
          }
          const rateLimitData = {
            timeToReset: timeout2,
            limit: limit2,
            method: options.method ?? "get",
            hash: this.hash,
            url,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            global: isGlobal
          };
          this.manager.emit("rateLimited", rateLimitData);
          await this.onRateLimit(rateLimitData);
          if (isGlobal) {
            this.debug(`Global rate limit hit, blocking all requests for ${timeout2}ms`);
          } else {
            this.debug(`Waiting ${timeout2}ms for rate limit to pass`);
          }
          await delay;
        }
        if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
          this.manager.globalReset = Date.now() + 1e3;
          this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
        }
        this.manager.globalRemaining--;
        const method = options.method ?? "get";
        const controller = new AbortController();
        const timeout = (0, import_node_timers.setTimeout)(() => controller.abort(), this.manager.options.timeout).unref();
        if (requestData.signal) {
          const signal = requestData.signal;
          if (signal.aborted)
            controller.abort();
          else
            signal.addEventListener("abort", () => controller.abort());
        }
        let res;
        try {
          res = await (0, import_undici3.request)(url, { ...options, signal: controller.signal });
        } catch (error) {
          if (error instanceof Error && error.name === "AbortError" && retries !== this.manager.options.retries) {
            return await this.runRequest(routeId, url, options, requestData, ++retries);
          }
          throw error;
        } finally {
          (0, import_node_timers.clearTimeout)(timeout);
        }
        if (this.manager.listenerCount("response")) {
          this.manager.emit(
            "response",
            {
              method,
              path: routeId.original,
              route: routeId.bucketRoute,
              options,
              data: requestData,
              retries
            },
            { ...res }
          );
        }
        const status = res.statusCode;
        let retryAfter = 0;
        const limit = parseHeader(res.headers["x-ratelimit-limit"]);
        const remaining = parseHeader(res.headers["x-ratelimit-remaining"]);
        const reset = parseHeader(res.headers["x-ratelimit-reset-after"]);
        const hash = parseHeader(res.headers["x-ratelimit-bucket"]);
        const retry = parseHeader(res.headers["retry-after"]);
        this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
        this.remaining = remaining ? Number(remaining) : 1;
        this.reset = reset ? Number(reset) * 1e3 + Date.now() + this.manager.options.offset : Date.now();
        if (retry)
          retryAfter = Number(retry) * 1e3 + this.manager.options.offset;
        if (hash && hash !== this.hash) {
          this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
          this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
        } else if (hash) {
          const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
          if (hashData) {
            hashData.lastAccess = Date.now();
          }
        }
        let sublimitTimeout = null;
        if (retryAfter > 0) {
          if (res.headers["x-ratelimit-global"] !== void 0) {
            this.manager.globalRemaining = 0;
            this.manager.globalReset = Date.now() + retryAfter;
          } else if (!this.localLimited) {
            sublimitTimeout = retryAfter;
          }
        }
        if (status === 401 || status === 403 || status === 429) {
          if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
            invalidCountResetTime = Date.now() + 1e3 * 60 * 10;
            invalidCount = 0;
          }
          invalidCount++;
          const emitInvalid = this.manager.options.invalidRequestWarningInterval > 0 && invalidCount % this.manager.options.invalidRequestWarningInterval === 0;
          if (emitInvalid) {
            this.manager.emit("invalidRequestWarning", {
              count: invalidCount,
              remainingTime: invalidCountResetTime - Date.now()
            });
          }
        }
        if (status >= 200 && status < 300) {
          return res;
        } else if (status === 429) {
          const isGlobal = this.globalLimited;
          let limit2;
          let timeout2;
          if (isGlobal) {
            limit2 = this.manager.options.globalRequestsPerSecond;
            timeout2 = this.manager.globalReset + this.manager.options.offset - Date.now();
          } else {
            limit2 = this.limit;
            timeout2 = this.timeToReset;
          }
          await this.onRateLimit({
            timeToReset: timeout2,
            limit: limit2,
            method,
            hash: this.hash,
            url,
            route: routeId.bucketRoute,
            majorParameter: this.majorParameter,
            global: isGlobal
          });
          this.debug(
            [
              "Encountered unexpected 429 rate limit",
              `  Global         : ${isGlobal.toString()}`,
              `  Method         : ${method}`,
              `  URL            : ${url}`,
              `  Bucket         : ${routeId.bucketRoute}`,
              `  Major parameter: ${routeId.majorParameter}`,
              `  Hash           : ${this.hash}`,
              `  Limit          : ${limit2}`,
              `  Retry After    : ${retryAfter}ms`,
              `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`
            ].join("\n")
          );
          if (sublimitTimeout) {
            const firstSublimit = !__privateGet(this, _sublimitedQueue);
            if (firstSublimit) {
              __privateSet(this, _sublimitedQueue, new import_async_queue.AsyncQueue());
              void __privateGet(this, _sublimitedQueue).wait();
              __privateGet(this, _asyncQueue).shift();
            }
            (_a3 = __privateGet(this, _sublimitPromise)) == null ? void 0 : _a3.resolve();
            __privateSet(this, _sublimitPromise, null);
            await (0, import_promises.setTimeout)(sublimitTimeout, void 0, { ref: false });
            let resolve;
            const promise = new Promise((res2) => resolve = res2);
            __privateSet(this, _sublimitPromise, { promise, resolve });
            if (firstSublimit) {
              await __privateGet(this, _asyncQueue).wait();
              __privateSet(this, _shiftSublimit, true);
            }
          }
          return this.runRequest(routeId, url, options, requestData, retries);
        } else if (status >= 500 && status < 600) {
          if (retries !== this.manager.options.retries) {
            return this.runRequest(routeId, url, options, requestData, ++retries);
          }
          throw new HTTPError(status, method, url, requestData);
        } else {
          if (status >= 400 && status < 500) {
            if (status === 401 && requestData.auth) {
              this.manager.setToken(null);
            }
            const data = await parseResponse(res);
            throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
          }
          return res;
        }
      }
    }, _asyncQueue = new WeakMap(), _sublimitedQueue = new WeakMap(), _sublimitPromise = new WeakMap(), _shiftSublimit = new WeakMap(), _a);
    __name(SequentialHandler, "SequentialHandler");
    var getFileType = (0, import_util2.lazy)(async () => Promise.resolve().then(() => (init_file_type(), file_type_exports)));
    var RequestMethod = /* @__PURE__ */ ((RequestMethod2) => {
      RequestMethod2["Delete"] = "DELETE";
      RequestMethod2["Get"] = "GET";
      RequestMethod2["Patch"] = "PATCH";
      RequestMethod2["Post"] = "POST";
      RequestMethod2["Put"] = "PUT";
      return RequestMethod2;
    })(RequestMethod || {});
    var _token, _a2;
    var RequestManager = (_a2 = class extends import_node_events.EventEmitter {
      constructor(options) {
        super();
        __publicField(this, "agent", null);
        __publicField(this, "globalRemaining");
        __publicField(this, "globalDelay", null);
        __publicField(this, "globalReset", -1);
        __publicField(this, "hashes", new import_collection.Collection());
        __publicField(this, "handlers", new import_collection.Collection());
        __privateAdd(this, _token, null);
        __publicField(this, "hashTimer");
        __publicField(this, "handlerTimer");
        __publicField(this, "options");
        this.options = { ...DefaultRestOptions, ...options };
        this.options.offset = Math.max(0, this.options.offset);
        this.globalRemaining = this.options.globalRequestsPerSecond;
        this.agent = options.agent ?? null;
        this.setupSweepers();
      }
      setupSweepers() {
        const validateMaxInterval = /* @__PURE__ */ __name((interval) => {
          if (interval > 144e5) {
            throw new Error("Cannot set an interval greater than 4 hours");
          }
        }, "validateMaxInterval");
        if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
          validateMaxInterval(this.options.hashSweepInterval);
          this.hashTimer = (0, import_node_timers2.setInterval)(() => {
            const sweptHashes = new import_collection.Collection();
            const currentDate = Date.now();
            this.hashes.sweep((val, key) => {
              if (val.lastAccess === -1)
                return false;
              const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
              if (shouldSweep) {
                sweptHashes.set(key, val);
              }
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
              return shouldSweep;
            });
            this.emit("hashSweep", sweptHashes);
          }, this.options.hashSweepInterval).unref();
        }
        if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
          validateMaxInterval(this.options.handlerSweepInterval);
          this.handlerTimer = (0, import_node_timers2.setInterval)(() => {
            const sweptHandlers = new import_collection.Collection();
            this.handlers.sweep((val, key) => {
              const { inactive } = val;
              if (inactive) {
                sweptHandlers.set(key, val);
              }
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
              return inactive;
            });
            this.emit("handlerSweep", sweptHandlers);
          }, this.options.handlerSweepInterval).unref();
        }
      }
      setAgent(agent) {
        this.agent = agent;
        return this;
      }
      setToken(token) {
        __privateSet(this, _token, token);
        return this;
      }
      async queueRequest(request2) {
        const routeId = RequestManager.generateRouteData(request2.fullRoute, request2.method);
        const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
          value: `Global(${request2.method}:${routeId.bucketRoute})`,
          lastAccess: -1
        };
        const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
        const { url, fetchOptions } = await this.resolveRequest(request2);
        return handler.queueRequest(routeId, url, fetchOptions, {
          body: request2.body,
          files: request2.files,
          auth: request2.auth !== false,
          signal: request2.signal
        });
      }
      createHandler(hash, majorParameter) {
        const queue = new SequentialHandler(this, hash, majorParameter);
        this.handlers.set(queue.id, queue);
        return queue;
      }
      async resolveRequest(request2) {
        var _a3, _b, _c;
        const { options } = this;
        let query = "";
        if (request2.query) {
          const resolvedQuery = request2.query.toString();
          if (resolvedQuery !== "") {
            query = `?${resolvedQuery}`;
          }
        }
        const headers = {
          ...this.options.headers,
          "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
        };
        if (request2.auth !== false) {
          if (!__privateGet(this, _token)) {
            throw new Error("Expected token to be set for this request, but none was present");
          }
          headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${__privateGet(this, _token)}`;
        }
        if ((_a3 = request2.reason) == null ? void 0 : _a3.length) {
          headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
        }
        const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
        let finalBody;
        let additionalHeaders = {};
        if ((_b = request2.files) == null ? void 0 : _b.length) {
          const formData = new import_undici4.FormData();
          for (const [index, file] of request2.files.entries()) {
            const fileKey = file.key ?? `files[${index}]`;
            if (import_node_buffer22.Buffer.isBuffer(file.data)) {
              const { fileTypeFromBuffer: fileTypeFromBuffer2 } = await getFileType();
              const contentType = file.contentType ?? ((_c = await fileTypeFromBuffer2(file.data)) == null ? void 0 : _c.mime);
              formData.append(fileKey, new import_node_buffer22.Blob([file.data], { type: contentType }), file.name);
            } else {
              formData.append(fileKey, new import_node_buffer22.Blob([`${file.data}`], { type: file.contentType }), file.name);
            }
          }
          if (request2.body != null) {
            if (request2.appendToFormData) {
              for (const [key, value] of Object.entries(request2.body)) {
                formData.append(key, value);
              }
            } else {
              formData.append("payload_json", JSON.stringify(request2.body));
            }
          }
          finalBody = formData;
        } else if (request2.body != null) {
          if (request2.passThroughBody) {
            finalBody = request2.body;
          } else {
            finalBody = JSON.stringify(request2.body);
            additionalHeaders = { "Content-Type": "application/json" };
          }
        }
        finalBody = await resolveBody(finalBody);
        const fetchOptions = {
          headers: { ...request2.headers, ...additionalHeaders, ...headers },
          method: request2.method.toUpperCase()
        };
        if (finalBody !== void 0) {
          fetchOptions.body = finalBody;
        }
        fetchOptions.dispatcher = request2.dispatcher ?? this.agent ?? void 0;
        return { url, fetchOptions };
      }
      clearHashSweeper() {
        (0, import_node_timers2.clearInterval)(this.hashTimer);
      }
      clearHandlerSweeper() {
        (0, import_node_timers2.clearInterval)(this.handlerTimer);
      }
      static generateRouteData(endpoint, method) {
        const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{16,19})/.exec(endpoint);
        const majorId = (majorIdMatch == null ? void 0 : majorIdMatch[1]) ?? "global";
        const baseRoute = endpoint.replace(/\d{16,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
        let exceptions = "";
        if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
          const id = /\d{16,19}$/.exec(endpoint)[0];
          const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
          if (Date.now() - timestamp > 1e3 * 60 * 60 * 24 * 14) {
            exceptions += "/Delete Old Message";
          }
        }
        return {
          majorParameter: majorId,
          bucketRoute: baseRoute + exceptions,
          original: endpoint
        };
      }
    }, _token = new WeakMap(), _a2);
    __name(RequestManager, "RequestManager");
    var import_node_events2 = require("events");
    var REST2 = class extends import_node_events2.EventEmitter {
      cdn;
      requestManager;
      constructor(options = {}) {
        super();
        this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
        this.requestManager = new RequestManager(options).on("restDebug", this.emit.bind(this, "restDebug")).on("rateLimited", this.emit.bind(this, "rateLimited")).on("invalidRequestWarning", this.emit.bind(this, "invalidRequestWarning")).on("hashSweep", this.emit.bind(this, "hashSweep"));
        this.on("newListener", (name, listener) => {
          if (name === "response")
            this.requestManager.on(name, listener);
        });
        this.on("removeListener", (name, listener) => {
          if (name === "response")
            this.requestManager.off(name, listener);
        });
      }
      getAgent() {
        return this.requestManager.agent;
      }
      setAgent(agent) {
        this.requestManager.setAgent(agent);
        return this;
      }
      setToken(token) {
        this.requestManager.setToken(token);
        return this;
      }
      async get(fullRoute, options = {}) {
        return this.request({ ...options, fullRoute, method: "GET" });
      }
      async delete(fullRoute, options = {}) {
        return this.request({ ...options, fullRoute, method: "DELETE" });
      }
      async post(fullRoute, options = {}) {
        return this.request({ ...options, fullRoute, method: "POST" });
      }
      async put(fullRoute, options = {}) {
        return this.request({ ...options, fullRoute, method: "PUT" });
      }
      async patch(fullRoute, options = {}) {
        return this.request({ ...options, fullRoute, method: "PATCH" });
      }
      async request(options) {
        const response = await this.raw(options);
        return parseResponse(response);
      }
      async raw(options) {
        return this.requestManager.queueRequest(options);
      }
    };
    __name(REST2, "REST");
    var version2 = "1.3.0";
  }
});

// ../../node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS({
  "../../node_modules/discord.js/src/errors/ErrorCodes.js"(exports2, module2) {
    "use strict";
    var keys = [
      "ClientInvalidOption",
      "ClientInvalidProvidedShards",
      "ClientMissingIntents",
      "ClientNotReady",
      "TokenInvalid",
      "TokenMissing",
      "ApplicationCommandPermissionsTokenMissing",
      "WSCloseRequested",
      "WSConnectionExists",
      "WSNotOpen",
      "ManagerDestroyed",
      "BitFieldInvalid",
      "ShardingInvalid",
      "ShardingRequired",
      "InvalidIntents",
      "DisallowedIntents",
      "ShardingNoShards",
      "ShardingInProcess",
      "ShardingInvalidEvalBroadcast",
      "ShardingShardNotFound",
      "ShardingAlreadySpawned",
      "ShardingProcessExists",
      "ShardingWorkerExists",
      "ShardingReadyTimeout",
      "ShardingReadyDisconnected",
      "ShardingReadyDied",
      "ShardingNoChildExists",
      "ShardingShardMiscalculation",
      "ColorRange",
      "ColorConvert",
      "InviteOptionsMissingChannel",
      "ButtonLabel",
      "ButtonURL",
      "ButtonCustomId",
      "SelectMenuCustomId",
      "SelectMenuPlaceholder",
      "SelectOptionLabel",
      "SelectOptionValue",
      "SelectOptionDescription",
      "InteractionCollectorError",
      "FileNotFound",
      "UserBannerNotFetched",
      "UserNoDMChannel",
      "VoiceNotStageChannel",
      "VoiceStateNotOwn",
      "VoiceStateInvalidType",
      "ReqResourceType",
      "ImageFormat",
      "ImageSize",
      "MessageBulkDeleteType",
      "MessageNonceType",
      "MessageContentType",
      "SplitMaxLen",
      "BanResolveId",
      "FetchBanResolveId",
      "PruneDaysType",
      "GuildChannelResolve",
      "GuildVoiceChannelResolve",
      "GuildChannelOrphan",
      "GuildChannelUnowned",
      "GuildOwned",
      "GuildMembersTimeout",
      "GuildUncachedMe",
      "ChannelNotCached",
      "StageChannelResolve",
      "GuildScheduledEventResolve",
      "FetchOwnerId",
      "InvalidType",
      "InvalidElement",
      "MessageThreadParent",
      "MessageExistingThread",
      "ThreadInvitableType",
      "WebhookMessage",
      "WebhookTokenUnavailable",
      "WebhookURLInvalid",
      "WebhookApplication",
      "MessageReferenceMissing",
      "EmojiType",
      "EmojiManaged",
      "MissingManageEmojisAndStickersPermission",
      "NotGuildSticker",
      "ReactionResolveUser",
      "VanityURL",
      "InviteResolveCode",
      "InviteNotFound",
      "DeleteGroupDMChannel",
      "FetchGroupDMChannel",
      "MemberFetchNonceLength",
      "GlobalCommandPermissions",
      "GuildUncachedEntityResolve",
      "InteractionAlreadyReplied",
      "InteractionNotReplied",
      "InteractionEphemeralReplied",
      "CommandInteractionOptionNotFound",
      "CommandInteractionOptionType",
      "CommandInteractionOptionEmpty",
      "CommandInteractionOptionNoSubcommand",
      "CommandInteractionOptionNoSubcommandGroup",
      "AutocompleteInteractionOptionNoFocusedOption",
      "ModalSubmitInteractionFieldNotFound",
      "ModalSubmitInteractionFieldType",
      "InvalidMissingScopes",
      "NotImplemented",
      "SweepFilterReturn",
      "GuildForumMessageRequired"
    ];
    module2.exports = Object.fromEntries(keys.map((key) => [key, key]));
  }
});

// ../../node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS({
  "../../node_modules/discord.js/src/errors/Messages.js"(exports2, module2) {
    "use strict";
    var DjsErrorCodes = require_ErrorCodes();
    var Messages = {
      [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
      [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
      [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
      [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
      [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
      [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
      [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
      [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
      [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
      [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
      [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
      [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
      [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
      [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
      [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
      [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
      [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
      [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
      [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
      [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
      [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
      [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
      [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
      [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
      [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
      [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
      [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
      [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
      [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
      [DjsErrorCodes.ColorConvert]: "Unable to convert color to a number.",
      [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
      [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
      [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
      [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
      [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
      [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
      [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
      [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
      [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
      [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
      [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
      [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
      [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
      [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
      [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
      [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
      [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
      [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
      [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
      [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
      [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
      [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
      [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
      [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
      [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
      [DjsErrorCodes.PruneDaysType]: "Days must be a number",
      [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
      [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
      [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
      [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
      [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
      [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
      [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
      [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
      [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
      [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
      [DjsErrorCodes.FetchOwnerId]: "Couldn't resolve the guild ownerId to fetch the member.",
      [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
      [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
      [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
      [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
      [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
      [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
      [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
      [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
      [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
      [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
      [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
      [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
      [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
      [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
      [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
      [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
      [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
      [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
      [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
      [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
      [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
      [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable or from a guild's application command manager.",
      [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
      [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
      [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
      [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
      [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
      [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
      [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
      [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
      [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
      [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
      [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
      [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
      [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
      [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
      [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
      [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread"
    };
    module2.exports = Messages;
  }
});

// ../../node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS({
  "../../node_modules/discord.js/src/errors/DJSError.js"(exports2, module2) {
    "use strict";
    var ErrorCodes2 = require_ErrorCodes();
    var Messages = require_Messages();
    function makeDiscordjsError(Base) {
      return class DiscordjsError2 extends Base {
        constructor(code, ...args) {
          var _a;
          super(message(code, args));
          this.code = code;
          (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, this, DiscordjsError2);
        }
        get name() {
          return `${super.name} [${this.code}]`;
        }
      };
    }
    function message(code, args) {
      if (!(code in ErrorCodes2))
        throw new Error("Error code must be a valid DiscordjsErrorCodes");
      const msg = Messages[code];
      if (!msg)
        throw new Error(`No message associated with error code: ${code}.`);
      if (typeof msg === "function")
        return msg(...args);
      if (!(args == null ? void 0 : args.length))
        return msg;
      args.unshift(msg);
      return String(...args);
    }
    module2.exports = {
      DiscordjsError: makeDiscordjsError(Error),
      DiscordjsTypeError: makeDiscordjsError(TypeError),
      DiscordjsRangeError: makeDiscordjsError(RangeError)
    };
  }
});

// ../../node_modules/discord.js/src/errors/index.js
var require_errors2 = __commonJS({
  "../../node_modules/discord.js/src/errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_DJSError();
    module2.exports.ErrorCodes = require_ErrorCodes();
    module2.exports.Messages = require_Messages();
  }
});

// ../../node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS({
  "../../node_modules/lodash.snakecase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? "_" : "") + word.toLowerCase();
    });
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = snakeCase;
  }
});

// ../../node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS({
  "../../node_modules/discord.js/src/util/Transformers.js"(exports2, module2) {
    "use strict";
    var snakeCase = require_lodash();
    function toSnakeCase(obj) {
      if (typeof obj !== "object" || !obj)
        return obj;
      if (obj instanceof Date)
        return obj;
      if (Array.isArray(obj))
        return obj.map(toSnakeCase);
      return Object.fromEntries(Object.entries(obj).map(([key, value]) => [snakeCase(key), toSnakeCase(value)]));
    }
    module2.exports = { toSnakeCase };
  }
});

// ../../node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS({
  "../../node_modules/discord.js/src/util/LimitedCollection.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var LimitedCollection = class extends Collection2 {
      constructor(options = {}, iterable) {
        if (typeof options !== "object" || options === null) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        }
        const { maxSize = Infinity, keepOverLimit = null } = options;
        if (typeof maxSize !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "maxSize", "number");
        }
        if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "keepOverLimit", "function");
        }
        super(iterable);
        this.maxSize = maxSize;
        this.keepOverLimit = keepOverLimit;
      }
      set(key, value) {
        var _a;
        if (this.maxSize === 0)
          return this;
        if (this.size >= this.maxSize && !this.has(key)) {
          for (const [k, v] of this.entries()) {
            const keep = ((_a = this.keepOverLimit) == null ? void 0 : _a.call(this, v, k, this)) ?? false;
            if (!keep) {
              this.delete(k);
              break;
            }
          }
        }
        return super.set(key, value);
      }
      static get [Symbol.species]() {
        return Collection2;
      }
    };
    module2.exports = LimitedCollection;
  }
});

// ../../node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS({
  "../../node_modules/discord.js/src/util/Options.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { DefaultRestOptions } = require_dist5();
    var { toSnakeCase } = require_Transformers();
    var Options2 = class extends null {
      static createDefault() {
        return {
          closeTimeout: 5e3,
          waitGuildTimeout: 15e3,
          shardCount: 1,
          makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
          partials: [],
          failIfNotExists: true,
          presence: {},
          sweepers: this.DefaultSweeperSettings,
          ws: {
            large_threshold: 50,
            compress: false,
            properties: {
              os: process3.platform,
              browser: "discord.js",
              device: "discord.js"
            },
            version: 10
          },
          rest: DefaultRestOptions,
          jsonTransformer: toSnakeCase
        };
      }
      static cacheWithLimits(settings2 = {}) {
        const { Collection: Collection2 } = require_dist();
        const LimitedCollection = require_LimitedCollection();
        return (manager) => {
          const setting = settings2[manager.name];
          if (setting == null) {
            return new Collection2();
          }
          if (typeof setting === "number") {
            if (setting === Infinity) {
              return new Collection2();
            }
            return new LimitedCollection({ maxSize: setting });
          }
          const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
          if (noLimit) {
            return new Collection2();
          }
          return new LimitedCollection(setting);
        };
      }
      static cacheEverything() {
        const { Collection: Collection2 } = require_dist();
        return () => new Collection2();
      }
      static get DefaultMakeCacheSettings() {
        return {
          MessageManager: 200
        };
      }
      static get DefaultSweeperSettings() {
        return {
          threads: {
            interval: 3600,
            lifetime: 14400
          }
        };
      }
    };
    module2.exports = Options2;
  }
});

// ../../node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS({
  "../../node_modules/discord.js/src/util/Colors.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Default: 0,
      White: 16777215,
      Aqua: 1752220,
      Green: 5763719,
      Blue: 3447003,
      Yellow: 16705372,
      Purple: 10181046,
      LuminousVividPink: 15277667,
      Fuchsia: 15418782,
      Gold: 15844367,
      Orange: 15105570,
      Red: 15548997,
      Grey: 9807270,
      Navy: 3426654,
      DarkAqua: 1146986,
      DarkGreen: 2067276,
      DarkBlue: 2123412,
      DarkPurple: 7419530,
      DarkVividPink: 11342935,
      DarkGold: 12745742,
      DarkOrange: 11027200,
      DarkRed: 10038562,
      DarkGrey: 9936031,
      DarkerGrey: 8359053,
      LightGrey: 12370112,
      DarkNavy: 2899536,
      Blurple: 5793266,
      Greyple: 10070709,
      DarkButNotBlack: 2895667,
      NotQuiteBlack: 2303786
    };
  }
});

// ../../node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS({
  "../../node_modules/fast-deep-equal/es6/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a instanceof Map && b instanceof Map) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          for (i of a.entries())
            if (!equal(i[1], b.get(i[0])))
              return false;
          return true;
        }
        if (a instanceof Set && b instanceof Set) {
          if (a.size !== b.size)
            return false;
          for (i of a.entries())
            if (!b.has(i[0]))
              return false;
          return true;
        }
        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b[i])
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/lodash.uniqwith/index.js
var require_lodash2 = __commonJS({
  "../../node_modules/lodash.uniqwith/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var splice = arrayProto.splice;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function uniqWith(array, comparator) {
      return array && array.length ? baseUniq(array, void 0, comparator) : [];
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function noop() {
    }
    module2.exports = uniqWith;
  }
});

// ../../node_modules/@sapphire/shapeshift/dist/index.js
var require_dist6 = __commonJS({
  "../../node_modules/@sapphire/shapeshift/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util = require("util");
    var fastDeepEqual = require_es6();
    var uniqWith = require_lodash2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var fastDeepEqual__default = /* @__PURE__ */ _interopDefaultLegacy(fastDeepEqual);
    var uniqWith__default = /* @__PURE__ */ _interopDefaultLegacy(uniqWith);
    var __defProp2 = Object.defineProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var validationEnabled = true;
    function setGlobalValidationEnabled(enabled) {
      validationEnabled = enabled;
    }
    __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
    function getGlobalValidationEnabled() {
      return validationEnabled;
    }
    __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
    var Result = class {
      constructor(success, value, error) {
        this.success = success;
        if (success) {
          this.value = value;
        } else {
          this.error = error;
        }
      }
      isOk() {
        return this.success;
      }
      isErr() {
        return !this.success;
      }
      unwrap() {
        if (this.isOk())
          return this.value;
        throw this.error;
      }
      static ok(value) {
        return new Result(true, value);
      }
      static err(error) {
        return new Result(false, void 0, error);
      }
    };
    __name(Result, "Result");
    function getValue(valueOrFn) {
      return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
    }
    __name(getValue, "getValue");
    var BaseValidator = class {
      constructor(constraints = []) {
        this.constraints = [];
        this.isValidationEnabled = null;
        this.constraints = constraints;
      }
      get optional() {
        return new UnionValidator([new LiteralValidator(void 0), this.clone()]);
      }
      get nullable() {
        return new UnionValidator([new LiteralValidator(null), this.clone()]);
      }
      get nullish() {
        return new UnionValidator([new NullishValidator(), this.clone()]);
      }
      get array() {
        return new ArrayValidator(this.clone());
      }
      get set() {
        return new SetValidator(this.clone());
      }
      or(...predicates) {
        return new UnionValidator([this.clone(), ...predicates]);
      }
      transform(cb) {
        return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
      }
      reshape(cb) {
        return this.addConstraint({ run: cb });
      }
      default(value) {
        return new DefaultValidator(this.clone(), value);
      }
      run(value) {
        let result = this.handle(value);
        if (result.isErr())
          return result;
        for (const constraint of this.constraints) {
          result = constraint.run(result.value);
          if (result.isErr())
            break;
        }
        return result;
      }
      parse(value) {
        if (!this.shouldRunConstraints) {
          return this.handle(value).unwrap();
        }
        return this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());
      }
      is(value) {
        return this.run(value).isOk();
      }
      setValidationEnabled(isValidationEnabled) {
        const clone = this.clone();
        clone.isValidationEnabled = isValidationEnabled;
        return clone;
      }
      getValidationEnabled() {
        return getValue(this.isValidationEnabled);
      }
      get shouldRunConstraints() {
        return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
      }
      clone() {
        const clone = Reflect.construct(this.constructor, [this.constraints]);
        clone.isValidationEnabled = this.isValidationEnabled;
        return clone;
      }
      addConstraint(constraint) {
        const clone = this.clone();
        clone.constraints = clone.constraints.concat(constraint);
        return clone;
      }
    };
    __name(BaseValidator, "BaseValidator");
    var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
    var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
    var BaseError = class extends Error {
      [customInspectSymbol](depth, options) {
        return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
      }
    };
    __name(BaseError, "BaseError");
    var BaseConstraintError = class extends BaseError {
      constructor(constraint, message, given) {
        super(message);
        this.constraint = constraint;
        this.given = given;
      }
    };
    __name(BaseConstraintError, "BaseConstraintError");
    var ExpectedConstraintError = class extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(ExpectedConstraintError, "ExpectedConstraintError");
    function isUnique(input) {
      if (input.length < 2)
        return true;
      const uniqueArray2 = uniqWith__default["default"](input, fastDeepEqual__default["default"]);
      return uniqueArray2.length === input.length;
    }
    __name(isUnique, "isUnique");
    function lessThan(a, b) {
      return a < b;
    }
    __name(lessThan, "lessThan");
    function lessThanOrEqual(a, b) {
      return a <= b;
    }
    __name(lessThanOrEqual, "lessThanOrEqual");
    function greaterThan(a, b) {
      return a > b;
    }
    __name(greaterThan, "greaterThan");
    function greaterThanOrEqual(a, b) {
      return a >= b;
    }
    __name(greaterThanOrEqual, "greaterThanOrEqual");
    function equal(a, b) {
      return a === b;
    }
    __name(equal, "equal");
    function notEqual(a, b) {
      return a !== b;
    }
    __name(notEqual, "notEqual");
    function arrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthComparator, "arrayLengthComparator");
    function arrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
    }
    __name(arrayLengthLessThan, "arrayLengthLessThan");
    function arrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
    }
    __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
    function arrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
    }
    __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
    function arrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
    function arrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
    }
    __name(arrayLengthEqual, "arrayLengthEqual");
    function arrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
    }
    __name(arrayLengthNotEqual, "arrayLengthNotEqual");
    function arrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRange, "arrayLengthRange");
    function arrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
    function arrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
        }
      };
    }
    __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
    var uniqueArray = {
      run(input) {
        return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique", "Array values are not unique", input, "Expected all values to be unique"));
      }
    };
    var CombinedPropertyError = class extends BaseError {
      constructor(errors) {
        super("Received one or more errors");
        this.errors = errors;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedPropertyError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors = this.errors.map(([key, error]) => {
          const property = CombinedPropertyError.formatProperty(key, options);
          const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  input${property}${padding}${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors}`;
      }
      static formatProperty(key, options) {
        if (typeof key === "string")
          return options.stylize(`.${key}`, "symbol");
        if (typeof key === "number")
          return `[${options.stylize(key.toString(), "number")}]`;
        return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
      }
    };
    __name(CombinedPropertyError, "CombinedPropertyError");
    var ValidationError = class extends BaseError {
      constructor(validator, message, given) {
        super(message);
        this.validator = validator;
        this.given = given;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(ValidationError, "ValidationError");
    var ArrayValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      lengthLessThan(length) {
        return this.addConstraint(arrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(arrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(arrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(arrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(arrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(arrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
      }
      get unique() {
        return this.addConstraint(uniqueArray);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = [];
        for (let i = 0; i < values.length; i++) {
          const result = this.validator.run(values[i]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors.push([i, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(ArrayValidator, "ArrayValidator");
    function bigintComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
        }
      };
    }
    __name(bigintComparator, "bigintComparator");
    function bigintLessThan(value) {
      const expected = `expected < ${value}n`;
      return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
    }
    __name(bigintLessThan, "bigintLessThan");
    function bigintLessThanOrEqual(value) {
      const expected = `expected <= ${value}n`;
      return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
    }
    __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
    function bigintGreaterThan(value) {
      const expected = `expected > ${value}n`;
      return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
    }
    __name(bigintGreaterThan, "bigintGreaterThan");
    function bigintGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}n`;
      return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
    }
    __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
    function bigintEqual(value) {
      const expected = `expected === ${value}n`;
      return bigintComparator(equal, "s.bigint.equal", expected, value);
    }
    __name(bigintEqual, "bigintEqual");
    function bigintNotEqual(value) {
      const expected = `expected !== ${value}n`;
      return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
    }
    __name(bigintNotEqual, "bigintNotEqual");
    function bigintDivisibleBy(divider) {
      const expected = `expected % ${divider}n === 0n`;
      return {
        run(input) {
          return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
        }
      };
    }
    __name(bigintDivisibleBy, "bigintDivisibleBy");
    var BigIntValidator = class extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(bigintLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(bigintLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(bigintGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(bigintGreaterThanOrEqual(number));
      }
      equal(number) {
        return this.addConstraint(bigintEqual(number));
      }
      notEqual(number) {
        return this.addConstraint(bigintNotEqual(number));
      }
      get positive() {
        return this.greaterThanOrEqual(0n);
      }
      get negative() {
        return this.lessThan(0n);
      }
      divisibleBy(number) {
        return this.addConstraint(bigintDivisibleBy(number));
      }
      get abs() {
        return this.transform((value) => value < 0 ? -value : value);
      }
      intN(bits) {
        return this.transform((value) => BigInt.asIntN(bits, value));
      }
      uintN(bits) {
        return this.transform((value) => BigInt.asUintN(bits, value));
      }
      handle(value) {
        return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
      }
    };
    __name(BigIntValidator, "BigIntValidator");
    var booleanTrue = {
      run(input) {
        return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
      }
    };
    var booleanFalse = {
      run(input) {
        return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
      }
    };
    var BooleanValidator = class extends BaseValidator {
      get true() {
        return this.addConstraint(booleanTrue);
      }
      get false() {
        return this.addConstraint(booleanFalse);
      }
      equal(value) {
        return value ? this.true : this.false;
      }
      notEqual(value) {
        return value ? this.false : this.true;
      }
      handle(value) {
        return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
      }
    };
    __name(BooleanValidator, "BooleanValidator");
    function dateComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
        }
      };
    }
    __name(dateComparator, "dateComparator");
    function dateLessThan(value) {
      const expected = `expected < ${value.toISOString()}`;
      return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
    }
    __name(dateLessThan, "dateLessThan");
    function dateLessThanOrEqual(value) {
      const expected = `expected <= ${value.toISOString()}`;
      return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
    }
    __name(dateLessThanOrEqual, "dateLessThanOrEqual");
    function dateGreaterThan(value) {
      const expected = `expected > ${value.toISOString()}`;
      return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
    }
    __name(dateGreaterThan, "dateGreaterThan");
    function dateGreaterThanOrEqual(value) {
      const expected = `expected >= ${value.toISOString()}`;
      return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
    }
    __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
    function dateEqual(value) {
      const expected = `expected === ${value.toISOString()}`;
      return dateComparator(equal, "s.date.equal", expected, value.getTime());
    }
    __name(dateEqual, "dateEqual");
    function dateNotEqual(value) {
      const expected = `expected !== ${value.toISOString()}`;
      return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
    }
    __name(dateNotEqual, "dateNotEqual");
    var dateInvalid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
      }
    };
    var dateValid = {
      run(input) {
        return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    var DateValidator = class extends BaseValidator {
      lessThan(date) {
        return this.addConstraint(dateLessThan(new Date(date)));
      }
      lessThanOrEqual(date) {
        return this.addConstraint(dateLessThanOrEqual(new Date(date)));
      }
      greaterThan(date) {
        return this.addConstraint(dateGreaterThan(new Date(date)));
      }
      greaterThanOrEqual(date) {
        return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
      }
      equal(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
      }
      notEqual(date) {
        const resolved = new Date(date);
        return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
      }
      get valid() {
        return this.addConstraint(dateValid);
      }
      get invalid() {
        return this.addConstraint(dateInvalid);
      }
      handle(value) {
        return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
      }
    };
    __name(DateValidator, "DateValidator");
    var ExpectedValidationError = class extends ValidationError {
      constructor(validator, message, given, expected) {
        super(validator, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          validator: this.validator,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const validator = options.stylize(this.validator, "string");
        if (depth < 0) {
          return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const expected = util.inspect(this.expected, newOptions).replace(/\n/g, padding);
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
        const message = options.stylize(this.message, "regexp");
        const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(ExpectedValidationError, "ExpectedValidationError");
    var InstanceValidator = class extends BaseValidator {
      constructor(expected, constraints = []) {
        super(constraints);
        this.expected = expected;
      }
      handle(value) {
        return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(InstanceValidator, "InstanceValidator");
    var LiteralValidator = class extends BaseValidator {
      constructor(literal, constraints = []) {
        super(constraints);
        this.expected = literal;
      }
      handle(value) {
        return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.expected, this.constraints]);
      }
    };
    __name(LiteralValidator, "LiteralValidator");
    var NeverValidator = class extends BaseValidator {
      handle(value) {
        return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
      }
    };
    __name(NeverValidator, "NeverValidator");
    var NullishValidator = class extends BaseValidator {
      handle(value) {
        return value === void 0 || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
      }
    };
    __name(NullishValidator, "NullishValidator");
    function numberComparator(comparator, name, expected, number) {
      return {
        run(input) {
          return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
        }
      };
    }
    __name(numberComparator, "numberComparator");
    function numberLessThan(value) {
      const expected = `expected < ${value}`;
      return numberComparator(lessThan, "s.number.lessThan", expected, value);
    }
    __name(numberLessThan, "numberLessThan");
    function numberLessThanOrEqual(value) {
      const expected = `expected <= ${value}`;
      return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
    }
    __name(numberLessThanOrEqual, "numberLessThanOrEqual");
    function numberGreaterThan(value) {
      const expected = `expected > ${value}`;
      return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
    }
    __name(numberGreaterThan, "numberGreaterThan");
    function numberGreaterThanOrEqual(value) {
      const expected = `expected >= ${value}`;
      return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
    }
    __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
    function numberEqual(value) {
      const expected = `expected === ${value}`;
      return numberComparator(equal, "s.number.equal", expected, value);
    }
    __name(numberEqual, "numberEqual");
    function numberNotEqual(value) {
      const expected = `expected !== ${value}`;
      return numberComparator(notEqual, "s.number.notEqual", expected, value);
    }
    __name(numberNotEqual, "numberNotEqual");
    var numberInt = {
      run(input) {
        return Number.isInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true")
        );
      }
    };
    var numberSafeInt = {
      run(input) {
        return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(
          new ExpectedConstraintError(
            "s.number.safeInt",
            "Given value is not a safe integer",
            input,
            "Number.isSafeInteger(expected) to be true"
          )
        );
      }
    };
    var numberFinite = {
      run(input) {
        return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
      }
    };
    var numberNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
      }
    };
    var numberNotNaN = {
      run(input) {
        return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
      }
    };
    function numberDivisibleBy(divider) {
      const expected = `expected % ${divider} === 0`;
      return {
        run(input) {
          return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
        }
      };
    }
    __name(numberDivisibleBy, "numberDivisibleBy");
    var NumberValidator = class extends BaseValidator {
      lessThan(number) {
        return this.addConstraint(numberLessThan(number));
      }
      lessThanOrEqual(number) {
        return this.addConstraint(numberLessThanOrEqual(number));
      }
      greaterThan(number) {
        return this.addConstraint(numberGreaterThan(number));
      }
      greaterThanOrEqual(number) {
        return this.addConstraint(numberGreaterThanOrEqual(number));
      }
      equal(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
      }
      notEqual(number) {
        return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
      }
      get int() {
        return this.addConstraint(numberInt);
      }
      get safeInt() {
        return this.addConstraint(numberSafeInt);
      }
      get finite() {
        return this.addConstraint(numberFinite);
      }
      get positive() {
        return this.greaterThanOrEqual(0);
      }
      get negative() {
        return this.lessThan(0);
      }
      divisibleBy(divider) {
        return this.addConstraint(numberDivisibleBy(divider));
      }
      get abs() {
        return this.transform(Math.abs);
      }
      get sign() {
        return this.transform(Math.sign);
      }
      get trunc() {
        return this.transform(Math.trunc);
      }
      get floor() {
        return this.transform(Math.floor);
      }
      get fround() {
        return this.transform(Math.fround);
      }
      get round() {
        return this.transform(Math.round);
      }
      get ceil() {
        return this.transform(Math.ceil);
      }
      handle(value) {
        return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
      }
    };
    __name(NumberValidator, "NumberValidator");
    var MissingPropertyError = class extends BaseError {
      constructor(property) {
        super("A required property is missing");
        this.property = property;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[MissingPropertyError: ${property}]`, "special");
        }
        const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        return `${header}
  ${message}`;
      }
    };
    __name(MissingPropertyError, "MissingPropertyError");
    var UnknownPropertyError = class extends BaseError {
      constructor(property, value) {
        super("Received unexpected property");
        this.property = property;
        this.value = value;
      }
      toJSON() {
        return {
          name: this.name,
          property: this.property,
          value: this.value
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const property = options.stylize(this.property.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const given = util.inspect(this.value, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
        const message = options.stylize(this.message, "regexp");
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${givenBlock}`;
      }
    };
    __name(UnknownPropertyError, "UnknownPropertyError");
    var DefaultValidator = class extends BaseValidator {
      constructor(validator, value, constraints = []) {
        super(constraints);
        this.validator = validator;
        this.defaultValue = value;
      }
      default(value) {
        const clone = this.clone();
        clone.defaultValue = value;
        return clone;
      }
      handle(value) {
        return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);
      }
    };
    __name(DefaultValidator, "DefaultValidator");
    var CombinedError = class extends BaseError {
      constructor(errors) {
        super("Received one or more errors");
        this.errors = errors;
      }
      [customInspectSymbolStackLess](depth, options) {
        if (depth < 0) {
          return options.stylize("[CombinedError]", "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
        const message = options.stylize(this.message, "regexp");
        const errors = this.errors.map((error, i) => {
          const index = options.stylize((i + 1).toString(), "number");
          const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
          return `  ${index} ${body}`;
        }).join("\n\n");
        return `${header}
  ${message}

${errors}`;
      }
    };
    __name(CombinedError, "CombinedError");
    var UnionValidator = class extends BaseValidator {
      constructor(validators, constraints = []) {
        super(constraints);
        this.validators = validators;
      }
      get optional() {
        if (this.validators.length === 0)
          return new UnionValidator([new LiteralValidator(void 0)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return this.clone();
          if (validator.expected === null) {
            return new UnionValidator(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new UnionValidator([new LiteralValidator(void 0), ...this.validators]);
      }
      get required() {
        if (this.validators.length === 0)
          return this.clone();
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === void 0)
            return new UnionValidator(this.validators.slice(1), this.constraints);
        } else if (validator instanceof NullishValidator) {
          return new UnionValidator([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);
        }
        return this.clone();
      }
      get nullable() {
        if (this.validators.length === 0)
          return new UnionValidator([new LiteralValidator(null)], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null)
            return this.clone();
          if (validator.expected === void 0) {
            return new UnionValidator(
              [new NullishValidator(), ...this.validators.slice(1)],
              this.constraints
            );
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new UnionValidator([new LiteralValidator(null), ...this.validators]);
      }
      get nullish() {
        if (this.validators.length === 0)
          return new UnionValidator([new NullishValidator()], this.constraints);
        const [validator] = this.validators;
        if (validator instanceof LiteralValidator) {
          if (validator.expected === null || validator.expected === void 0) {
            return new UnionValidator([new NullishValidator(), ...this.validators.slice(1)], this.constraints);
          }
        } else if (validator instanceof NullishValidator) {
          return this.clone();
        }
        return new UnionValidator([new NullishValidator(), ...this.validators]);
      }
      or(...predicates) {
        return new UnionValidator([...this.validators, ...predicates]);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(value) {
        const errors = [];
        for (const validator of this.validators) {
          const result = validator.run(value);
          if (result.isOk())
            return result;
          errors.push(result.error);
        }
        return Result.err(new CombinedError(errors));
      }
    };
    __name(UnionValidator, "UnionValidator");
    var ObjectValidator = class extends BaseValidator {
      constructor(shape, strategy = ObjectValidatorStrategy.Ignore, constraints = []) {
        super(constraints);
        this.keys = [];
        this.requiredKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeys = /* @__PURE__ */ new Map();
        this.possiblyUndefinedKeysWithDefaults = /* @__PURE__ */ new Map();
        this.shape = shape;
        this.strategy = strategy;
        switch (this.strategy) {
          case ObjectValidatorStrategy.Ignore:
            this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
            break;
          case ObjectValidatorStrategy.Strict: {
            this.handleStrategy = (value) => this.handleStrictStrategy(value);
            break;
          }
          case ObjectValidatorStrategy.Passthrough:
            this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
            break;
        }
        const shapeEntries = Object.entries(shape);
        this.keys = shapeEntries.map(([key]) => key);
        for (const [key, validator] of shapeEntries) {
          if (validator instanceof UnionValidator) {
            const [possiblyLiteralOrNullishPredicate] = validator["validators"];
            if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
              if (possiblyLiteralOrNullishPredicate.expected === void 0) {
                this.possiblyUndefinedKeys.set(key, validator);
              } else {
                this.requiredKeys.set(key, validator);
              }
            } else if (validator instanceof DefaultValidator) {
              this.possiblyUndefinedKeysWithDefaults.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (validator instanceof LiteralValidator) {
            if (validator.expected === void 0) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        }
      }
      get strict() {
        return Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Strict, this.constraints]);
      }
      get ignore() {
        return Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Ignore, this.constraints]);
      }
      get passthrough() {
        return Reflect.construct(this.constructor, [this.shape, ObjectValidatorStrategy.Passthrough, this.constraints]);
      }
      get partial() {
        const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      get required() {
        const shape = Object.fromEntries(
          this.keys.map((key) => {
            let validator = this.shape[key];
            if (validator instanceof UnionValidator)
              validator = validator.required;
            return [key, validator];
          })
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      extend(schema) {
        const shape = { ...this.shape, ...schema instanceof ObjectValidator ? schema.shape : schema };
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      pick(keys) {
        const shape = Object.fromEntries(
          keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      omit(keys) {
        const shape = Object.fromEntries(
          this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]])
        );
        return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue !== "object") {
          return Result.err(new ValidationError("s.object(T)", `Expected the value to be an object, but received ${typeOfValue} instead`, value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.object(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        return this.handleStrategy(value);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);
      }
      handleIgnoreStrategy(value) {
        const errors = [];
        const finalObject = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalObject[key] = result.value;
          } else {
            const error = result.error;
            errors.push([key, error]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        if (inputEntries.size === 0) {
          return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
        }
        const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
        if (checkInputEntriesInsteadOfSchemaKeys) {
          for (const [key] of inputEntries) {
            const predicate = this.possiblyUndefinedKeys.get(key);
            if (predicate) {
              runPredicate(key, predicate);
            }
          }
        } else {
          for (const [key, predicate] of this.possiblyUndefinedKeys) {
            if (inputEntries.delete(key)) {
              runPredicate(key, predicate);
            }
          }
        }
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
      }
      handleStrictStrategy(value) {
        const errors = [];
        const finalResult = {};
        const inputEntries = new Map(Object.entries(value));
        const runPredicate = /* @__PURE__ */ __name((key, predicate) => {
          const result = predicate.run(value[key]);
          if (result.isOk()) {
            finalResult[key] = result.value;
          } else {
            const error = result.error;
            errors.push([key, error]);
          }
        }, "runPredicate");
        for (const [key, predicate] of this.requiredKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          } else {
            errors.push([key, new MissingPropertyError(key)]);
          }
        }
        for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
          inputEntries.delete(key);
          runPredicate(key, validator);
        }
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.size === 0) {
            break;
          }
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
        if (inputEntries.size !== 0) {
          for (const [key, value2] of inputEntries.entries()) {
            errors.push([key, new UnknownPropertyError(key, value2)]);
          }
        }
        return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors));
      }
      handlePassthroughStrategy(value) {
        const result = this.handleIgnoreStrategy(value);
        return result.isErr() ? result : Result.ok({ ...value, ...result.value });
      }
    };
    __name(ObjectValidator, "ObjectValidator");
    var ObjectValidatorStrategy = /* @__PURE__ */ ((ObjectValidatorStrategy2) => {
      ObjectValidatorStrategy2[ObjectValidatorStrategy2["Ignore"] = 0] = "Ignore";
      ObjectValidatorStrategy2[ObjectValidatorStrategy2["Strict"] = 1] = "Strict";
      ObjectValidatorStrategy2[ObjectValidatorStrategy2["Passthrough"] = 2] = "Passthrough";
      return ObjectValidatorStrategy2;
    })(ObjectValidatorStrategy || {});
    var PassthroughValidator = class extends BaseValidator {
      handle(value) {
        return Result.ok(value);
      }
    };
    __name(PassthroughValidator, "PassthroughValidator");
    var RecordValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(value) {
        if (typeof value !== "object") {
          return Result.err(new ValidationError("s.record(T)", "Expected an object", value));
        }
        if (value === null) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be null", value));
        }
        if (Array.isArray(value)) {
          return Result.err(new ValidationError("s.record(T)", "Expected the value to not be an array", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors = [];
        const transformed = {};
        for (const [key, val] of Object.entries(value)) {
          const result = this.validator.run(val);
          if (result.isOk())
            transformed[key] = result.value;
          else
            errors.push([key, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(RecordValidator, "RecordValidator");
    var SetValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        if (!(values instanceof Set)) {
          return Result.err(new ValidationError("s.set(T)", "Expected a set", values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = /* @__PURE__ */ new Set();
        for (const value of values) {
          const result = this.validator.run(value);
          if (result.isOk())
            transformed.add(result.value);
          else
            errors.push(result.error);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors));
      }
    };
    __name(SetValidator, "SetValidator");
    var accountRegex = /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")$/;
    function validateEmail(email) {
      if (!email)
        return false;
      const atIndex = email.indexOf("@");
      if (atIndex === -1)
        return false;
      if (atIndex > 64)
        return false;
      const domainIndex = atIndex + 1;
      if (email.includes("@", domainIndex))
        return false;
      if (email.length - domainIndex > 255)
        return false;
      let dotIndex = email.indexOf(".", domainIndex);
      if (dotIndex === -1)
        return false;
      let lastDotIndex = domainIndex;
      do {
        if (dotIndex - lastDotIndex > 63)
          return false;
        lastDotIndex = dotIndex + 1;
      } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
      if (email.length - lastDotIndex > 63)
        return false;
      return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
    }
    __name(validateEmail, "validateEmail");
    function validateEmailDomain(domain) {
      try {
        return new URL(`http://${domain}`).hostname === domain;
      } catch {
        return false;
      }
    }
    __name(validateEmailDomain, "validateEmailDomain");
    var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    var IPv4Reg = new RegExp(`^${v4Str}$`);
    var v6Seg = "(?:[0-9a-fA-F]{1,4})";
    var IPv6Reg = new RegExp(
      `^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`
    );
    function isIPv4(s2) {
      return IPv4Reg.test(s2);
    }
    __name(isIPv4, "isIPv4");
    function isIPv6(s2) {
      return IPv6Reg.test(s2);
    }
    __name(isIPv6, "isIPv6");
    function isIP(s2) {
      if (isIPv4(s2))
        return 4;
      if (isIPv6(s2))
        return 6;
      return 0;
    }
    __name(isIP, "isIP");
    var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
    function validatePhoneNumber(input) {
      return phoneNumberRegex.test(input);
    }
    __name(validatePhoneNumber, "validatePhoneNumber");
    var MultiplePossibilitiesConstraintError = class extends BaseConstraintError {
      constructor(constraint, message, given, expected) {
        super(constraint, message, given);
        this.expected = expected;
      }
      toJSON() {
        return {
          name: this.name,
          constraint: this.constraint,
          given: this.given,
          expected: this.expected
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const constraint = options.stylize(this.constraint, "string");
        if (depth < 0) {
          return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
        }
        const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
        const verticalLine = options.stylize("|", "undefined");
        const padding = `
  ${verticalLine} `;
        const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
        const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
        const message = options.stylize(this.message, "regexp");
        const expectedPadding = `
  ${verticalLine} - `;
        const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
        const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
        return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
      }
    };
    __name(MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
    function combinedErrorFn(...fns) {
      switch (fns.length) {
        case 0:
          return () => null;
        case 1:
          return fns[0];
        case 2: {
          const [fn0, fn1] = fns;
          return (...params) => fn0(...params) || fn1(...params);
        }
        default: {
          return (...params) => {
            for (const fn of fns) {
              const result = fn(...params);
              if (result)
                return result;
            }
            return null;
          };
        }
      }
    }
    __name(combinedErrorFn, "combinedErrorFn");
    function createUrlValidators(options) {
      var _a, _b;
      const fns = [];
      if ((_a = options == null ? void 0 : options.allowedProtocols) == null ? void 0 : _a.length)
        fns.push(allowedProtocolsFn(options.allowedProtocols));
      if ((_b = options == null ? void 0 : options.allowedDomains) == null ? void 0 : _b.length)
        fns.push(allowedDomainsFn(options.allowedDomains));
      return combinedErrorFn(...fns);
    }
    __name(createUrlValidators, "createUrlValidators");
    function allowedProtocolsFn(allowedProtocols) {
      return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL protocol", input, allowedProtocols);
    }
    __name(allowedProtocolsFn, "allowedProtocolsFn");
    function allowedDomainsFn(allowedDomains) {
      return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL domain", input, allowedDomains);
    }
    __name(allowedDomainsFn, "allowedDomainsFn");
    function stringLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid string length", input, expected));
        }
      };
    }
    __name(stringLengthComparator, "stringLengthComparator");
    function stringLengthLessThan(length) {
      const expected = `expected.length < ${length}`;
      return stringLengthComparator(lessThan, "s.string.lengthLessThan", expected, length);
    }
    __name(stringLengthLessThan, "stringLengthLessThan");
    function stringLengthLessThanOrEqual(length) {
      const expected = `expected.length <= ${length}`;
      return stringLengthComparator(lessThanOrEqual, "s.string.lengthLessThanOrEqual", expected, length);
    }
    __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
    function stringLengthGreaterThan(length) {
      const expected = `expected.length > ${length}`;
      return stringLengthComparator(greaterThan, "s.string.lengthGreaterThan", expected, length);
    }
    __name(stringLengthGreaterThan, "stringLengthGreaterThan");
    function stringLengthGreaterThanOrEqual(length) {
      const expected = `expected.length >= ${length}`;
      return stringLengthComparator(greaterThanOrEqual, "s.string.lengthGreaterThanOrEqual", expected, length);
    }
    __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
    function stringLengthEqual(length) {
      const expected = `expected.length === ${length}`;
      return stringLengthComparator(equal, "s.string.lengthEqual", expected, length);
    }
    __name(stringLengthEqual, "stringLengthEqual");
    function stringLengthNotEqual(length) {
      const expected = `expected.length !== ${length}`;
      return stringLengthComparator(notEqual, "s.string.lengthNotEqual", expected, length);
    }
    __name(stringLengthNotEqual, "stringLengthNotEqual");
    function stringEmail() {
      return {
        run(input) {
          return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.email", "Invalid email address", input, "expected to be an email address"));
        }
      };
    }
    __name(stringEmail, "stringEmail");
    function stringRegexValidator(type, expected, regex) {
      return {
        run(input) {
          return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, "Invalid string format", input, expected));
        }
      };
    }
    __name(stringRegexValidator, "stringRegexValidator");
    function stringUrl(options) {
      const validatorFn = createUrlValidators(options);
      return {
        run(input) {
          let url;
          try {
            url = new URL(input);
          } catch {
            return Result.err(new ExpectedConstraintError("s.string.url", "Invalid URL", input, "expected to match an URL"));
          }
          const validatorFnResult = validatorFn(input, url);
          if (validatorFnResult === null)
            return Result.ok(input);
          return Result.err(validatorFnResult);
        }
      };
    }
    __name(stringUrl, "stringUrl");
    function stringIp(version2) {
      const ipVersion = version2 ? `v${version2}` : "";
      const validatorFn = version2 === 4 ? isIPv4 : version2 === 6 ? isIPv6 : isIP;
      const name = `s.string.ip${ipVersion}`;
      const message = `Invalid IP${ipVersion} address`;
      const expected = `expected to be an IP${ipVersion} address`;
      return {
        run(input) {
          return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));
        }
      };
    }
    __name(stringIp, "stringIp");
    function stringRegex(regex) {
      return stringRegexValidator("s.string.regex", `expected ${regex}.test(expected) to be true`, regex);
    }
    __name(stringRegex, "stringRegex");
    function stringUuid({ version: version2 = 4, nullable = false } = {}) {
      version2 ?? (version2 = "1-5");
      const regex = new RegExp(
        `^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version2}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})$`,
        "i"
      );
      const expected = `expected to match UUID${typeof version2 === "number" ? `v${version2}` : ` in range of ${version2}`}`;
      return stringRegexValidator("s.string.uuid", expected, regex);
    }
    __name(stringUuid, "stringUuid");
    function stringDate() {
      return {
        run(input) {
          const time = Date.parse(input);
          return Number.isNaN(time) ? Result.err(
            new ExpectedConstraintError(
              "s.string.date",
              "Invalid date string",
              input,
              "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)"
            )
          ) : Result.ok(input);
        }
      };
    }
    __name(stringDate, "stringDate");
    function stringPhone() {
      return {
        run(input) {
          return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.phone", "Invalid phone number", input, "expected to be a phone number"));
        }
      };
    }
    __name(stringPhone, "stringPhone");
    var StringValidator = class extends BaseValidator {
      lengthLessThan(length) {
        return this.addConstraint(stringLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(stringLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(stringLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(stringLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(stringLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(stringLengthNotEqual(length));
      }
      get email() {
        return this.addConstraint(stringEmail());
      }
      url(options) {
        return this.addConstraint(stringUrl(options));
      }
      uuid(options) {
        return this.addConstraint(stringUuid(options));
      }
      regex(regex) {
        return this.addConstraint(stringRegex(regex));
      }
      get date() {
        return this.addConstraint(stringDate());
      }
      get ipv4() {
        return this.ip(4);
      }
      get ipv6() {
        return this.ip(6);
      }
      ip(version2) {
        return this.addConstraint(stringIp(version2));
      }
      phone() {
        return this.addConstraint(stringPhone());
      }
      handle(value) {
        return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string", "Expected a string primitive", value));
      }
    };
    __name(StringValidator, "StringValidator");
    var TupleValidator = class extends BaseValidator {
      constructor(validators, constraints = []) {
        super(constraints);
        this.validators = [];
        this.validators = validators;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validators, this.constraints]);
      }
      handle(values) {
        if (!Array.isArray(values)) {
          return Result.err(new ValidationError("s.tuple(T)", "Expected an array", values));
        }
        if (values.length !== this.validators.length) {
          return Result.err(new ValidationError("s.tuple(T)", `Expected an array of length ${this.validators.length}`, values));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(values);
        }
        const errors = [];
        const transformed = [];
        for (let i = 0; i < values.length; i++) {
          const result = this.validators[i].run(values[i]);
          if (result.isOk())
            transformed.push(result.value);
          else
            errors.push([i, result.error]);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(TupleValidator, "TupleValidator");
    var MapValidator = class extends BaseValidator {
      constructor(keyValidator, valueValidator, constraints = []) {
        super(constraints);
        this.keyValidator = keyValidator;
        this.valueValidator = valueValidator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);
      }
      handle(value) {
        if (!(value instanceof Map)) {
          return Result.err(new ValidationError("s.map(K, V)", "Expected a map", value));
        }
        if (!this.shouldRunConstraints) {
          return Result.ok(value);
        }
        const errors = [];
        const transformed = /* @__PURE__ */ new Map();
        for (const [key, val] of value.entries()) {
          const keyResult = this.keyValidator.run(key);
          const valueResult = this.valueValidator.run(val);
          const { length } = errors;
          if (keyResult.isErr())
            errors.push([key, keyResult.error]);
          if (valueResult.isErr())
            errors.push([key, valueResult.error]);
          if (errors.length === length)
            transformed.set(keyResult.value, valueResult.value);
        }
        return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
      }
    };
    __name(MapValidator, "MapValidator");
    var LazyValidator = class extends BaseValidator {
      constructor(validator, constraints = []) {
        super(constraints);
        this.validator = validator;
      }
      clone() {
        return Reflect.construct(this.constructor, [this.validator, this.constraints]);
      }
      handle(values) {
        return this.validator(values).run(values);
      }
    };
    __name(LazyValidator, "LazyValidator");
    var UnknownEnumValueError = class extends BaseError {
      constructor(value, keys, enumMappings) {
        super("Expected the value to be one of the following enum values:");
        this.value = value;
        this.enumKeys = keys;
        this.enumMappings = enumMappings;
      }
      toJSON() {
        return {
          name: this.name,
          value: this.value,
          enumKeys: this.enumKeys,
          enumMappings: [...this.enumMappings.entries()]
        };
      }
      [customInspectSymbolStackLess](depth, options) {
        const value = options.stylize(this.value.toString(), "string");
        if (depth < 0) {
          return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
        }
        const padding = `
  ${options.stylize("|", "undefined")} `;
        const pairs = this.enumKeys.map((key) => {
          const enumValue = this.enumMappings.get(key);
          return `${options.stylize(key, "string")} or ${options.stylize(
            enumValue.toString(),
            typeof enumValue === "number" ? "number" : "string"
          )}`;
        }).join(padding);
        const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
        const message = options.stylize(this.message, "regexp");
        const pairsBlock = `${padding}${pairs}`;
        return `${header}
  ${message}
${pairsBlock}`;
      }
    };
    __name(UnknownEnumValueError, "UnknownEnumValueError");
    var NativeEnumValidator = class extends BaseValidator {
      constructor(enumShape) {
        super();
        this.hasNumericElements = false;
        this.enumMapping = /* @__PURE__ */ new Map();
        this.enumShape = enumShape;
        this.enumKeys = Object.keys(enumShape).filter((key) => {
          return typeof enumShape[enumShape[key]] !== "number";
        });
        for (const key of this.enumKeys) {
          const enumValue = enumShape[key];
          this.enumMapping.set(key, enumValue);
          this.enumMapping.set(enumValue, enumValue);
          if (typeof enumValue === "number") {
            this.hasNumericElements = true;
            this.enumMapping.set(`${enumValue}`, enumValue);
          }
        }
      }
      handle(value) {
        const typeOfValue = typeof value;
        if (typeOfValue === "number") {
          if (!this.hasNumericElements) {
            return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string", value));
          }
        } else if (typeOfValue !== "string") {
          return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string or number", value));
        }
        const casted = value;
        const possibleEnumValue = this.enumMapping.get(casted);
        return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);
      }
      clone() {
        return Reflect.construct(this.constructor, [this.enumShape]);
      }
    };
    __name(NativeEnumValidator, "NativeEnumValidator");
    function typedArrayByteLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
    function typedArrayByteLengthLessThan(value) {
      const expected = `expected.byteLength < ${value}`;
      return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan", expected, value);
    }
    __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
    function typedArrayByteLengthLessThanOrEqual(value) {
      const expected = `expected.byteLength <= ${value}`;
      return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
    function typedArrayByteLengthGreaterThan(value) {
      const expected = `expected.byteLength > ${value}`;
      return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan", expected, value);
    }
    __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
    function typedArrayByteLengthGreaterThanOrEqual(value) {
      const expected = `expected.byteLength >= ${value}`;
      return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
    function typedArrayByteLengthEqual(value) {
      const expected = `expected.byteLength === ${value}`;
      return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual", expected, value);
    }
    __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
    function typedArrayByteLengthNotEqual(value) {
      const expected = `expected.byteLength !== ${value}`;
      return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual", expected, value);
    }
    __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
    function typedArrayByteLengthRange(start, endBefore) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange", "Invalid Typed Array byte length", input, expected));
        }
      };
    }
    __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
    function typedArrayByteLengthRangeInclusive(start, end) {
      const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
      return {
        run(input) {
          return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
    function typedArrayByteLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
      return {
        run(input) {
          return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(
            new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive", "Invalid Typed Array byte length", input, expected)
          );
        }
      };
    }
    __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
    function typedArrayLengthComparator(comparator, name, expected, length) {
      return {
        run(input) {
          return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthComparator, "typedArrayLengthComparator");
    function typedArrayLengthLessThan(value) {
      const expected = `expected.length < ${value}`;
      return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan", expected, value);
    }
    __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
    function typedArrayLengthLessThanOrEqual(value) {
      const expected = `expected.length <= ${value}`;
      return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual", expected, value);
    }
    __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
    function typedArrayLengthGreaterThan(value) {
      const expected = `expected.length > ${value}`;
      return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan", expected, value);
    }
    __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
    function typedArrayLengthGreaterThanOrEqual(value) {
      const expected = `expected.length >= ${value}`;
      return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual", expected, value);
    }
    __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
    function typedArrayLengthEqual(value) {
      const expected = `expected.length === ${value}`;
      return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual", expected, value);
    }
    __name(typedArrayLengthEqual, "typedArrayLengthEqual");
    function typedArrayLengthNotEqual(value) {
      const expected = `expected.length !== ${value}`;
      return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual", expected, value);
    }
    __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
    function typedArrayLengthRange(start, endBefore) {
      const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRange, "typedArrayLengthRange");
    function typedArrayLengthRangeInclusive(start, end) {
      const expected = `expected.length >= ${start} && expected.length <= ${end}`;
      return {
        run(input) {
          return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
    function typedArrayLengthRangeExclusive(startAfter, endBefore) {
      const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
      return {
        run(input) {
          return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive", "Invalid Typed Array length", input, expected));
        }
      };
    }
    __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
    var vowels = ["a", "e", "i", "o", "u"];
    var aOrAn = /* @__PURE__ */ __name((word) => {
      return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
    }, "aOrAn");
    var TypedArrays = {
      Int8Array: (x) => x instanceof Int8Array,
      Uint8Array: (x) => x instanceof Uint8Array,
      Uint8ClampedArray: (x) => x instanceof Uint8ClampedArray,
      Int16Array: (x) => x instanceof Int16Array,
      Uint16Array: (x) => x instanceof Uint16Array,
      Int32Array: (x) => x instanceof Int32Array,
      Uint32Array: (x) => x instanceof Uint32Array,
      Float32Array: (x) => x instanceof Float32Array,
      Float64Array: (x) => x instanceof Float64Array,
      BigInt64Array: (x) => x instanceof BigInt64Array,
      BigUint64Array: (x) => x instanceof BigUint64Array,
      TypedArray: (x) => ArrayBuffer.isView(x) && !(x instanceof DataView)
    };
    var TypedArrayValidator = class extends BaseValidator {
      constructor(type, constraints = []) {
        super(constraints);
        this.type = type;
      }
      byteLengthLessThan(length) {
        return this.addConstraint(typedArrayByteLengthLessThan(length));
      }
      byteLengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));
      }
      byteLengthGreaterThan(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThan(length));
      }
      byteLengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));
      }
      byteLengthEqual(length) {
        return this.addConstraint(typedArrayByteLengthEqual(length));
      }
      byteLengthNotEqual(length) {
        return this.addConstraint(typedArrayByteLengthNotEqual(length));
      }
      byteLengthRange(start, endBefore) {
        return this.addConstraint(typedArrayByteLengthRange(start, endBefore));
      }
      byteLengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));
      }
      byteLengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));
      }
      lengthLessThan(length) {
        return this.addConstraint(typedArrayLengthLessThan(length));
      }
      lengthLessThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthLessThanOrEqual(length));
      }
      lengthGreaterThan(length) {
        return this.addConstraint(typedArrayLengthGreaterThan(length));
      }
      lengthGreaterThanOrEqual(length) {
        return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));
      }
      lengthEqual(length) {
        return this.addConstraint(typedArrayLengthEqual(length));
      }
      lengthNotEqual(length) {
        return this.addConstraint(typedArrayLengthNotEqual(length));
      }
      lengthRange(start, endBefore) {
        return this.addConstraint(typedArrayLengthRange(start, endBefore));
      }
      lengthRangeInclusive(startAt, endAt) {
        return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));
      }
      lengthRangeExclusive(startAfter, endBefore) {
        return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));
      }
      clone() {
        return Reflect.construct(this.constructor, [this.type, this.constraints]);
      }
      handle(value) {
        return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray", `Expected ${aOrAn(this.type)}`, value));
      }
    };
    __name(TypedArrayValidator, "TypedArrayValidator");
    var Shapes = class {
      get string() {
        return new StringValidator();
      }
      get number() {
        return new NumberValidator();
      }
      get bigint() {
        return new BigIntValidator();
      }
      get boolean() {
        return new BooleanValidator();
      }
      get date() {
        return new DateValidator();
      }
      object(shape) {
        return new ObjectValidator(shape);
      }
      get undefined() {
        return this.literal(void 0);
      }
      get null() {
        return this.literal(null);
      }
      get nullish() {
        return new NullishValidator();
      }
      get any() {
        return new PassthroughValidator();
      }
      get unknown() {
        return new PassthroughValidator();
      }
      get never() {
        return new NeverValidator();
      }
      enum(...values) {
        return this.union(...values.map((value) => this.literal(value)));
      }
      nativeEnum(enumShape) {
        return new NativeEnumValidator(enumShape);
      }
      literal(value) {
        if (value instanceof Date)
          return this.date.equal(value);
        return new LiteralValidator(value);
      }
      instance(expected) {
        return new InstanceValidator(expected);
      }
      union(...validators) {
        return new UnionValidator(validators);
      }
      array(validator) {
        return new ArrayValidator(validator);
      }
      typedArray(type = "TypedArray") {
        return new TypedArrayValidator(type);
      }
      get int8Array() {
        return this.typedArray("Int8Array");
      }
      get uint8Array() {
        return this.typedArray("Uint8Array");
      }
      get uint8ClampedArray() {
        return this.typedArray("Uint8ClampedArray");
      }
      get int16Array() {
        return this.typedArray("Int16Array");
      }
      get uint16Array() {
        return this.typedArray("Uint16Array");
      }
      get int32Array() {
        return this.typedArray("Int32Array");
      }
      get uint32Array() {
        return this.typedArray("Uint32Array");
      }
      get float32Array() {
        return this.typedArray("Float32Array");
      }
      get float64Array() {
        return this.typedArray("Float64Array");
      }
      get bigInt64Array() {
        return this.typedArray("BigInt64Array");
      }
      get bigUint64Array() {
        return this.typedArray("BigUint64Array");
      }
      tuple(validators) {
        return new TupleValidator(validators);
      }
      set(validator) {
        return new SetValidator(validator);
      }
      record(validator) {
        return new RecordValidator(validator);
      }
      map(keyValidator, valueValidator) {
        return new MapValidator(keyValidator, valueValidator);
      }
      lazy(validator) {
        return new LazyValidator(validator);
      }
    };
    __name(Shapes, "Shapes");
    var s = new Shapes();
    exports2.BaseError = BaseError;
    exports2.CombinedError = CombinedError;
    exports2.CombinedPropertyError = CombinedPropertyError;
    exports2.ExpectedConstraintError = ExpectedConstraintError;
    exports2.ExpectedValidationError = ExpectedValidationError;
    exports2.MissingPropertyError = MissingPropertyError;
    exports2.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
    exports2.Result = Result;
    exports2.UnknownEnumValueError = UnknownEnumValueError;
    exports2.UnknownPropertyError = UnknownPropertyError;
    exports2.ValidationError = ValidationError;
    exports2.customInspectSymbol = customInspectSymbol;
    exports2.customInspectSymbolStackLess = customInspectSymbolStackLess;
    exports2.getGlobalValidationEnabled = getGlobalValidationEnabled;
    exports2.s = s;
    exports2.setGlobalValidationEnabled = setGlobalValidationEnabled;
  }
});

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/ts-mixer/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Mixin: () => Mixin,
  decorate: () => decorate,
  hasMixin: () => hasMixin,
  mix: () => mix,
  settings: () => settings
});
function Mixin(...constructors) {
  var _a, _b, _c;
  const prototypes = constructors.map((constructor) => constructor.prototype);
  const initFunctionName = settings.initFunction;
  if (initFunctionName !== null) {
    const initFunctions = prototypes.map((proto2) => proto2[initFunctionName]).filter((func) => typeof func === "function");
    const combinedInitFunction = function(...args) {
      for (let initFunction of initFunctions)
        initFunction.apply(this, args);
    };
    const extraProto = { [initFunctionName]: combinedInitFunction };
    prototypes.push(extraProto);
  }
  function MixedClass(...args) {
    for (const constructor of constructors)
      copyProps(this, new constructor(...args));
    if (initFunctionName !== null && typeof this[initFunctionName] === "function")
      this[initFunctionName].apply(this, args);
  }
  MixedClass.prototype = settings.prototypeStrategy === "copy" ? hardMixProtos(prototypes, MixedClass) : softMixProtos(prototypes, MixedClass);
  Object.setPrototypeOf(MixedClass, settings.staticsStrategy === "copy" ? hardMixProtos(constructors, null, ["prototype"]) : proxyMix(constructors, Function.prototype));
  let DecoratedMixedClass = MixedClass;
  if (settings.decoratorInheritance !== "none") {
    const classDecorators = settings.decoratorInheritance === "deep" ? deepDecoratorSearch(...constructors) : directDecoratorSearch(...constructors);
    for (let decorator of (_a = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.class) !== null && _a !== void 0 ? _a : [])
      DecoratedMixedClass = decorator(DecoratedMixedClass);
    applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.static) !== null && _b !== void 0 ? _b : {}, DecoratedMixedClass);
    applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === void 0 ? void 0 : classDecorators.instance) !== null && _c !== void 0 ? _c : {}, DecoratedMixedClass.prototype);
  }
  registerMixins(DecoratedMixedClass, constructors);
  return DecoratedMixedClass;
}
var copyProps, protoChain, nearestCommonProto, hardMixProtos, unique, getIngredientWithProp, proxyMix, softMixProtos, settings, mixins, getMixinsForClass, registerMixins, hasMixin, mergeObjectsOfDecorators, mergePropertyAndMethodDecorators, mergeDecorators, decorators, findAllConstituentClasses, deepDecoratorSearch, directDecoratorSearch, getDecoratorsForClass, decorateClass, decorateMember, decorate, applyPropAndMethodDecorators, mix;
var init_esm = __esm({
  "../../node_modules/ts-mixer/dist/esm/index.js"() {
    copyProps = (dest, src, exclude = []) => {
      const props = Object.getOwnPropertyDescriptors(src);
      for (let prop of exclude)
        delete props[prop];
      Object.defineProperties(dest, props);
    };
    protoChain = (obj, currentChain = [obj]) => {
      const proto2 = Object.getPrototypeOf(obj);
      if (proto2 === null)
        return currentChain;
      return protoChain(proto2, [...currentChain, proto2]);
    };
    nearestCommonProto = (...objs) => {
      if (objs.length === 0)
        return void 0;
      let commonProto = void 0;
      const protoChains = objs.map((obj) => protoChain(obj));
      while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
        const protos = protoChains.map((protoChain2) => protoChain2.pop());
        const potentialCommonProto = protos[0];
        if (protos.every((proto2) => proto2 === potentialCommonProto))
          commonProto = potentialCommonProto;
        else
          break;
      }
      return commonProto;
    };
    hardMixProtos = (ingredients, constructor, exclude = []) => {
      var _a;
      const base = (_a = nearestCommonProto(...ingredients)) !== null && _a !== void 0 ? _a : Object.prototype;
      const mixedProto = Object.create(base);
      const visitedProtos = protoChain(base);
      for (let prototype of ingredients) {
        let protos = protoChain(prototype);
        for (let i = protos.length - 1; i >= 0; i--) {
          let newProto = protos[i];
          if (visitedProtos.indexOf(newProto) === -1) {
            copyProps(mixedProto, newProto, ["constructor", ...exclude]);
            visitedProtos.push(newProto);
          }
        }
      }
      mixedProto.constructor = constructor;
      return mixedProto;
    };
    unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
    getIngredientWithProp = (prop, ingredients) => {
      const protoChains = ingredients.map((ingredient) => protoChain(ingredient));
      let protoDepth = 0;
      let protosAreLeftToSearch = true;
      while (protosAreLeftToSearch) {
        protosAreLeftToSearch = false;
        for (let i = ingredients.length - 1; i >= 0; i--) {
          const searchTarget = protoChains[i][protoDepth];
          if (searchTarget !== void 0 && searchTarget !== null) {
            protosAreLeftToSearch = true;
            if (Object.getOwnPropertyDescriptor(searchTarget, prop) != void 0) {
              return protoChains[i][0];
            }
          }
        }
        protoDepth++;
      }
      return void 0;
    };
    proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
      getPrototypeOf() {
        return prototype;
      },
      setPrototypeOf() {
        throw Error("Cannot set prototype of Proxies created by ts-mixer");
      },
      getOwnPropertyDescriptor(_, prop) {
        return Object.getOwnPropertyDescriptor(getIngredientWithProp(prop, ingredients) || {}, prop);
      },
      defineProperty() {
        throw new Error("Cannot define new properties on Proxies created by ts-mixer");
      },
      has(_, prop) {
        return getIngredientWithProp(prop, ingredients) !== void 0 || prototype[prop] !== void 0;
      },
      get(_, prop) {
        return (getIngredientWithProp(prop, ingredients) || prototype)[prop];
      },
      set(_, prop, val) {
        const ingredientWithProp = getIngredientWithProp(prop, ingredients);
        if (ingredientWithProp === void 0)
          throw new Error("Cannot set new properties on Proxies created by ts-mixer");
        ingredientWithProp[prop] = val;
        return true;
      },
      deleteProperty() {
        throw new Error("Cannot delete properties on Proxies created by ts-mixer");
      },
      ownKeys() {
        return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
      }
    });
    softMixProtos = (ingredients, constructor) => proxyMix([...ingredients, { constructor }]);
    settings = {
      initFunction: null,
      staticsStrategy: "copy",
      prototypeStrategy: "copy",
      decoratorInheritance: "deep"
    };
    mixins = /* @__PURE__ */ new Map();
    getMixinsForClass = (clazz) => mixins.get(clazz);
    registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
    hasMixin = (instance, mixin) => {
      if (instance instanceof mixin)
        return true;
      const constructor = instance.constructor;
      const visited = /* @__PURE__ */ new Set();
      let frontier = /* @__PURE__ */ new Set();
      frontier.add(constructor);
      while (frontier.size > 0) {
        if (frontier.has(mixin))
          return true;
        frontier.forEach((item) => visited.add(item));
        const newFrontier = /* @__PURE__ */ new Set();
        frontier.forEach((item) => {
          var _a;
          const itemConstituents = (_a = mixins.get(item)) !== null && _a !== void 0 ? _a : protoChain(item.prototype).map((proto2) => proto2.constructor).filter((item2) => item2 !== null);
          if (itemConstituents)
            itemConstituents.forEach((constituent) => {
              if (!visited.has(constituent) && !frontier.has(constituent))
                newFrontier.add(constituent);
            });
        });
        frontier = newFrontier;
      }
      return false;
    };
    mergeObjectsOfDecorators = (o1, o2) => {
      var _a, _b;
      const allKeys = unique([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
      const mergedObject = {};
      for (let key of allKeys)
        mergedObject[key] = unique([...(_a = o1 === null || o1 === void 0 ? void 0 : o1[key]) !== null && _a !== void 0 ? _a : [], ...(_b = o2 === null || o2 === void 0 ? void 0 : o2[key]) !== null && _b !== void 0 ? _b : []]);
      return mergedObject;
    };
    mergePropertyAndMethodDecorators = (d1, d2) => {
      var _a, _b, _c, _d;
      return {
        property: mergeObjectsOfDecorators((_a = d1 === null || d1 === void 0 ? void 0 : d1.property) !== null && _a !== void 0 ? _a : {}, (_b = d2 === null || d2 === void 0 ? void 0 : d2.property) !== null && _b !== void 0 ? _b : {}),
        method: mergeObjectsOfDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.method) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.method) !== null && _d !== void 0 ? _d : {})
      };
    };
    mergeDecorators = (d1, d2) => {
      var _a, _b, _c, _d, _e, _f;
      return {
        class: unique([...(_a = d1 === null || d1 === void 0 ? void 0 : d1.class) !== null && _a !== void 0 ? _a : [], ...(_b = d2 === null || d2 === void 0 ? void 0 : d2.class) !== null && _b !== void 0 ? _b : []]),
        static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === void 0 ? void 0 : d1.static) !== null && _c !== void 0 ? _c : {}, (_d = d2 === null || d2 === void 0 ? void 0 : d2.static) !== null && _d !== void 0 ? _d : {}),
        instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === void 0 ? void 0 : d1.instance) !== null && _e !== void 0 ? _e : {}, (_f = d2 === null || d2 === void 0 ? void 0 : d2.instance) !== null && _f !== void 0 ? _f : {})
      };
    };
    decorators = /* @__PURE__ */ new Map();
    findAllConstituentClasses = (...classes) => {
      var _a;
      const allClasses = /* @__PURE__ */ new Set();
      const frontier = /* @__PURE__ */ new Set([...classes]);
      while (frontier.size > 0) {
        for (let clazz of frontier) {
          const protoChainClasses = protoChain(clazz.prototype).map((proto2) => proto2.constructor);
          const mixinClasses = (_a = getMixinsForClass(clazz)) !== null && _a !== void 0 ? _a : [];
          const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
          const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
          for (let newClass of newClasses)
            frontier.add(newClass);
          allClasses.add(clazz);
          frontier.delete(clazz);
        }
      }
      return [...allClasses];
    };
    deepDecoratorSearch = (...classes) => {
      const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
      if (decoratorsForClassChain.length == 0)
        return {};
      if (decoratorsForClassChain.length == 1)
        return decoratorsForClassChain[0];
      return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    directDecoratorSearch = (...classes) => {
      const classDecorators = classes.map((clazz) => getDecoratorsForClass(clazz));
      if (classDecorators.length === 0)
        return {};
      if (classDecorators.length === 1)
        return classDecorators[0];
      return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
    };
    getDecoratorsForClass = (clazz) => {
      let decoratorsForClass = decorators.get(clazz);
      if (!decoratorsForClass) {
        decoratorsForClass = {};
        decorators.set(clazz, decoratorsForClass);
      }
      return decoratorsForClass;
    };
    decorateClass = (decorator) => (clazz) => {
      const decoratorsForClass = getDecoratorsForClass(clazz);
      let classDecorators = decoratorsForClass.class;
      if (!classDecorators) {
        classDecorators = [];
        decoratorsForClass.class = classDecorators;
      }
      classDecorators.push(decorator);
      return decorator(clazz);
    };
    decorateMember = (decorator) => (object, key, ...otherArgs) => {
      const decoratorTargetType = typeof object === "function" ? "static" : "instance";
      const decoratorType = typeof object[key] === "function" ? "method" : "property";
      const clazz = decoratorTargetType === "static" ? object : object.constructor;
      const decoratorsForClass = getDecoratorsForClass(clazz);
      let decoratorsForTargetType = decoratorsForClass === null || decoratorsForClass === void 0 ? void 0 : decoratorsForClass[decoratorTargetType];
      if (!decoratorsForTargetType) {
        decoratorsForTargetType = {};
        decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
      }
      let decoratorsForType = decoratorsForTargetType === null || decoratorsForTargetType === void 0 ? void 0 : decoratorsForTargetType[decoratorType];
      if (!decoratorsForType) {
        decoratorsForType = {};
        decoratorsForTargetType[decoratorType] = decoratorsForType;
      }
      let decoratorsForKey = decoratorsForType === null || decoratorsForType === void 0 ? void 0 : decoratorsForType[key];
      if (!decoratorsForKey) {
        decoratorsForKey = [];
        decoratorsForType[key] = decoratorsForKey;
      }
      decoratorsForKey.push(decorator);
      return decorator(object, key, ...otherArgs);
    };
    decorate = (decorator) => (...args) => {
      if (args.length === 1)
        return decorateClass(decorator)(args[0]);
      return decorateMember(decorator)(...args);
    };
    applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
      const propDecorators = propAndMethodDecorators.property;
      const methodDecorators = propAndMethodDecorators.method;
      if (propDecorators)
        for (let key in propDecorators)
          for (let decorator of propDecorators[key])
            decorator(target, key);
      if (methodDecorators)
        for (let key in methodDecorators)
          for (let decorator of methodDecorators[key])
            decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
    };
    mix = (...ingredients) => (decoratedClass) => {
      const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
      Object.defineProperty(mixedClass, "name", {
        value: decoratedClass.name,
        writable: false
      });
      return mixedClass;
    };
  }
});

// ../../node_modules/@discordjs/builders/dist/index.js
var require_dist7 = __commonJS({
  "../../node_modules/@discordjs/builders/dist/index.js"(exports2, module2) {
    "use strict";
    var __create2 = Object.create;
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getProtoOf2 = Object.getPrototypeOf;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod, secondTarget) => (__copyProps2(target, mod, "default"), secondTarget && __copyProps2(secondTarget, mod, "default"));
    var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
      isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var __decorateClass = (decorators2, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc2(target, key) : target;
      for (var i = decorators2.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators2[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp2(target, key, result);
      return result;
    };
    var src_exports2 = {};
    __export2(src_exports2, {
      ActionRowBuilder: () => ActionRowBuilder,
      ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
      ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
      ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
      ApplicationCommandOptionWithChoicesAndAutocompleteMixin: () => ApplicationCommandOptionWithChoicesAndAutocompleteMixin,
      ButtonBuilder: () => ButtonBuilder,
      ComponentAssertions: () => Assertions_exports2,
      ComponentBuilder: () => ComponentBuilder,
      ContextMenuCommandAssertions: () => Assertions_exports6,
      ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
      EmbedAssertions: () => Assertions_exports,
      EmbedBuilder: () => EmbedBuilder,
      Faces: () => Faces,
      ModalAssertions: () => Assertions_exports4,
      ModalBuilder: () => ModalBuilder,
      SelectMenuBuilder: () => SelectMenuBuilder,
      SelectMenuOptionBuilder: () => SelectMenuOptionBuilder,
      SharedNameAndDescription: () => SharedNameAndDescription,
      SharedSlashCommandOptions: () => SharedSlashCommandOptions,
      SlashCommandAssertions: () => Assertions_exports5,
      SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
      SlashCommandBooleanOption: () => SlashCommandBooleanOption,
      SlashCommandBuilder: () => SlashCommandBuilder2,
      SlashCommandChannelOption: () => SlashCommandChannelOption,
      SlashCommandIntegerOption: () => SlashCommandIntegerOption,
      SlashCommandMentionableOption: () => SlashCommandMentionableOption,
      SlashCommandNumberOption: () => SlashCommandNumberOption,
      SlashCommandRoleOption: () => SlashCommandRoleOption,
      SlashCommandStringOption: () => SlashCommandStringOption,
      SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
      SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
      SlashCommandUserOption: () => SlashCommandUserOption,
      TextInputAssertions: () => Assertions_exports3,
      TextInputBuilder: () => TextInputBuilder,
      TimestampStyles: () => TimestampStyles,
      blockQuote: () => blockQuote,
      bold: () => bold,
      channelLink: () => channelLink,
      channelMention: () => channelMention,
      chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
      codeBlock: () => codeBlock,
      createComponentBuilder: () => createComponentBuilder,
      disableValidators: () => disableValidators,
      embedLength: () => embedLength,
      enableValidators: () => enableValidators,
      formatEmoji: () => formatEmoji,
      hideLinkEmbed: () => hideLinkEmbed,
      hyperlink: () => hyperlink,
      inlineCode: () => inlineCode,
      isValidationEnabled: () => isValidationEnabled,
      italic: () => italic,
      messageLink: () => messageLink,
      normalizeArray: () => normalizeArray,
      quote: () => quote,
      roleMention: () => roleMention,
      spoiler: () => spoiler,
      strikethrough: () => strikethrough,
      time: () => time,
      underscore: () => underscore,
      userMention: () => userMention,
      version: () => version2
    });
    module2.exports = __toCommonJS2(src_exports2);
    var Assertions_exports = {};
    __export2(Assertions_exports, {
      RGBPredicate: () => RGBPredicate,
      authorNamePredicate: () => authorNamePredicate,
      colorPredicate: () => colorPredicate,
      descriptionPredicate: () => descriptionPredicate,
      embedAuthorPredicate: () => embedAuthorPredicate,
      embedFieldPredicate: () => embedFieldPredicate,
      embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
      embedFooterPredicate: () => embedFooterPredicate,
      fieldInlinePredicate: () => fieldInlinePredicate,
      fieldLengthPredicate: () => fieldLengthPredicate,
      fieldNamePredicate: () => fieldNamePredicate,
      fieldValuePredicate: () => fieldValuePredicate,
      footerTextPredicate: () => footerTextPredicate,
      imageURLPredicate: () => imageURLPredicate,
      timestampPredicate: () => timestampPredicate,
      titlePredicate: () => titlePredicate,
      urlPredicate: () => urlPredicate,
      validateFieldLength: () => validateFieldLength
    });
    var import_shapeshift = require_dist6();
    var validate2 = true;
    var enableValidators = /* @__PURE__ */ __name(() => validate2 = true, "enableValidators");
    var disableValidators = /* @__PURE__ */ __name(() => validate2 = false, "disableValidators");
    var isValidationEnabled = /* @__PURE__ */ __name(() => validate2, "isValidationEnabled");
    var fieldNamePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
    var fieldValuePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
    var fieldInlinePredicate = import_shapeshift.s.boolean.optional;
    var embedFieldPredicate = import_shapeshift.s.object({
      name: fieldNamePredicate,
      value: fieldValuePredicate,
      inline: fieldInlinePredicate
    }).setValidationEnabled(isValidationEnabled);
    var embedFieldsArrayPredicate = embedFieldPredicate.array.setValidationEnabled(isValidationEnabled);
    var fieldLengthPredicate = import_shapeshift.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateFieldLength(amountAdding, fields) {
      fieldLengthPredicate.parse(((fields == null ? void 0 : fields.length) ?? 0) + amountAdding);
    }
    __name(validateFieldLength, "validateFieldLength");
    var authorNamePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
    var imageURLPredicate = import_shapeshift.s.string.url({
      allowedProtocols: ["http:", "https:", "attachment:"]
    }).nullish.setValidationEnabled(isValidationEnabled);
    var urlPredicate = import_shapeshift.s.string.url({
      allowedProtocols: ["http:", "https:"]
    }).nullish.setValidationEnabled(isValidationEnabled);
    var embedAuthorPredicate = import_shapeshift.s.object({
      name: authorNamePredicate,
      iconURL: imageURLPredicate,
      url: urlPredicate
    }).setValidationEnabled(isValidationEnabled);
    var RGBPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
    var colorPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable.setValidationEnabled(isValidationEnabled);
    var descriptionPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable.setValidationEnabled(isValidationEnabled);
    var footerTextPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable.setValidationEnabled(isValidationEnabled);
    var embedFooterPredicate = import_shapeshift.s.object({
      text: footerTextPredicate,
      iconURL: imageURLPredicate
    }).setValidationEnabled(isValidationEnabled);
    var timestampPredicate = import_shapeshift.s.union(import_shapeshift.s.number, import_shapeshift.s.date).nullable.setValidationEnabled(isValidationEnabled);
    var titlePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
    function normalizeArray(arr) {
      if (Array.isArray(arr[0]))
        return arr[0];
      return arr;
    }
    __name(normalizeArray, "normalizeArray");
    var EmbedBuilder = class {
      data;
      constructor(data = {}) {
        this.data = { ...data };
        if (data.timestamp)
          this.data.timestamp = new Date(data.timestamp).toISOString();
      }
      addFields(...fields) {
        fields = normalizeArray(fields);
        validateFieldLength(fields.length, this.data.fields);
        embedFieldsArrayPredicate.parse(fields);
        if (this.data.fields)
          this.data.fields.push(...fields);
        else
          this.data.fields = fields;
        return this;
      }
      spliceFields(index, deleteCount, ...fields) {
        validateFieldLength(fields.length - deleteCount, this.data.fields);
        embedFieldsArrayPredicate.parse(fields);
        if (this.data.fields)
          this.data.fields.splice(index, deleteCount, ...fields);
        else
          this.data.fields = fields;
        return this;
      }
      setFields(...fields) {
        var _a;
        this.spliceFields(0, ((_a = this.data.fields) == null ? void 0 : _a.length) ?? 0, ...normalizeArray(fields));
        return this;
      }
      setAuthor(options) {
        if (options === null) {
          this.data.author = void 0;
          return this;
        }
        embedAuthorPredicate.parse(options);
        this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
        return this;
      }
      setColor(color) {
        colorPredicate.parse(color);
        if (Array.isArray(color)) {
          const [red, green, blue] = color;
          this.data.color = (red << 16) + (green << 8) + blue;
          return this;
        }
        this.data.color = color ?? void 0;
        return this;
      }
      setDescription(description) {
        descriptionPredicate.parse(description);
        this.data.description = description ?? void 0;
        return this;
      }
      setFooter(options) {
        if (options === null) {
          this.data.footer = void 0;
          return this;
        }
        embedFooterPredicate.parse(options);
        this.data.footer = { text: options.text, icon_url: options.iconURL };
        return this;
      }
      setImage(url) {
        imageURLPredicate.parse(url);
        this.data.image = url ? { url } : void 0;
        return this;
      }
      setThumbnail(url) {
        imageURLPredicate.parse(url);
        this.data.thumbnail = url ? { url } : void 0;
        return this;
      }
      setTimestamp(timestamp = Date.now()) {
        timestampPredicate.parse(timestamp);
        this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : void 0;
        return this;
      }
      setTitle(title) {
        titlePredicate.parse(title);
        this.data.title = title ?? void 0;
        return this;
      }
      setURL(url) {
        urlPredicate.parse(url);
        this.data.url = url ?? void 0;
        return this;
      }
      toJSON() {
        return { ...this.data };
      }
    };
    __name(EmbedBuilder, "EmbedBuilder");
    function codeBlock(language, content) {
      return typeof content === "undefined" ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
    }
    __name(codeBlock, "codeBlock");
    function inlineCode(content) {
      return `\`${content}\``;
    }
    __name(inlineCode, "inlineCode");
    function italic(content) {
      return `_${content}_`;
    }
    __name(italic, "italic");
    function bold(content) {
      return `**${content}**`;
    }
    __name(bold, "bold");
    function underscore(content) {
      return `__${content}__`;
    }
    __name(underscore, "underscore");
    function strikethrough(content) {
      return `~~${content}~~`;
    }
    __name(strikethrough, "strikethrough");
    function quote(content) {
      return `> ${content}`;
    }
    __name(quote, "quote");
    function blockQuote(content) {
      return `>>> ${content}`;
    }
    __name(blockQuote, "blockQuote");
    function hideLinkEmbed(url) {
      return `<${url}>`;
    }
    __name(hideLinkEmbed, "hideLinkEmbed");
    function hyperlink(content, url, title) {
      return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
    }
    __name(hyperlink, "hyperlink");
    function spoiler(content) {
      return `||${content}||`;
    }
    __name(spoiler, "spoiler");
    function userMention(userId) {
      return `<@${userId}>`;
    }
    __name(userMention, "userMention");
    function channelMention(channelId) {
      return `<#${channelId}>`;
    }
    __name(channelMention, "channelMention");
    function roleMention(roleId) {
      return `<@&${roleId}>`;
    }
    __name(roleMention, "roleMention");
    function chatInputApplicationCommandMention(commandName, subcommandGroupName, subcommandName, commandId) {
      if (typeof commandId !== "undefined") {
        return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
      }
      if (typeof subcommandName !== "undefined") {
        return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
      }
      return `</${commandName}:${subcommandGroupName}>`;
    }
    __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
    function formatEmoji(emojiId, animated = false) {
      return `<${animated ? "a" : ""}:_:${emojiId}>`;
    }
    __name(formatEmoji, "formatEmoji");
    function channelLink(channelId, guildId) {
      return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
    }
    __name(channelLink, "channelLink");
    function messageLink(channelId, messageId, guildId) {
      return `${typeof guildId === "undefined" ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
    }
    __name(messageLink, "messageLink");
    function time(timeOrSeconds, style) {
      if (typeof timeOrSeconds !== "number") {
        timeOrSeconds = Math.floor(((timeOrSeconds == null ? void 0 : timeOrSeconds.getTime()) ?? Date.now()) / 1e3);
      }
      return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
    }
    __name(time, "time");
    var TimestampStyles = {
      ShortTime: "t",
      LongTime: "T",
      ShortDate: "d",
      LongDate: "D",
      ShortDateTime: "f",
      LongDateTime: "F",
      RelativeTime: "R"
    };
    var Faces = /* @__PURE__ */ ((Faces2) => {
      Faces2["Shrug"] = "\xAF\\_(\u30C4)\\_/\xAF";
      Faces2["Tableflip"] = "(\u256F\xB0\u25A1\xB0\uFF09\u256F\uFE35 \u253B\u2501\u253B";
      Faces2["Unflip"] = "\u252C\u2500\u252C \u30CE( \u309C-\u309C\u30CE)";
      return Faces2;
    })(Faces || {});
    var Assertions_exports2 = {};
    __export2(Assertions_exports2, {
      buttonLabelValidator: () => buttonLabelValidator,
      buttonStyleValidator: () => buttonStyleValidator,
      customIdValidator: () => customIdValidator,
      defaultValidator: () => defaultValidator,
      disabledValidator: () => disabledValidator,
      emojiValidator: () => emojiValidator,
      jsonOptionValidator: () => jsonOptionValidator,
      labelValueDescriptionValidator: () => labelValueDescriptionValidator,
      minMaxValidator: () => minMaxValidator,
      optionValidator: () => optionValidator,
      optionsLengthValidator: () => optionsLengthValidator,
      optionsValidator: () => optionsValidator,
      placeholderValidator: () => placeholderValidator,
      urlValidator: () => urlValidator,
      validateRequiredButtonParameters: () => validateRequiredButtonParameters,
      validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
      validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
    });
    var import_shapeshift2 = require_dist6();
    var import_v10 = require_v106();
    var SelectMenuOptionBuilder = class {
      constructor(data = {}) {
        this.data = data;
      }
      setLabel(label) {
        this.data.label = labelValueDescriptionValidator.parse(label);
        return this;
      }
      setValue(value) {
        this.data.value = labelValueDescriptionValidator.parse(value);
        return this;
      }
      setDescription(description) {
        this.data.description = labelValueDescriptionValidator.parse(description);
        return this;
      }
      setDefault(isDefault = true) {
        this.data.default = defaultValidator.parse(isDefault);
        return this;
      }
      setEmoji(emoji) {
        this.data.emoji = emojiValidator.parse(emoji);
        return this;
      }
      toJSON() {
        validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
        return {
          ...this.data
        };
      }
    };
    __name(SelectMenuOptionBuilder, "SelectMenuOptionBuilder");
    var customIdValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var emojiValidator = import_shapeshift2.s.object({
      id: import_shapeshift2.s.string,
      name: import_shapeshift2.s.string,
      animated: import_shapeshift2.s.boolean
    }).partial.strict.setValidationEnabled(isValidationEnabled);
    var disabledValidator = import_shapeshift2.s.boolean;
    var buttonLabelValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
    var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
    var placeholderValidator = import_shapeshift2.s.string.lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
    var minMaxValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    var labelValueDescriptionValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var jsonOptionValidator = import_shapeshift2.s.object({
      label: labelValueDescriptionValidator,
      value: labelValueDescriptionValidator,
      description: labelValueDescriptionValidator.optional,
      emoji: emojiValidator.optional,
      default: import_shapeshift2.s.boolean.optional
    }).setValidationEnabled(isValidationEnabled);
    var optionValidator = import_shapeshift2.s.instance(SelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
    var optionsValidator = optionValidator.array.lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
    var optionsLengthValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateRequiredSelectMenuParameters(options, customId) {
      customIdValidator.parse(customId);
      optionsValidator.parse(options);
    }
    __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
    var defaultValidator = import_shapeshift2.s.boolean;
    function validateRequiredSelectMenuOptionParameters(label, value) {
      labelValueDescriptionValidator.parse(label);
      labelValueDescriptionValidator.parse(value);
    }
    __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
    var urlValidator = import_shapeshift2.s.string.url({
      allowedProtocols: ["http:", "https:", "discord:"]
    }).setValidationEnabled(isValidationEnabled);
    function validateRequiredButtonParameters(style, label, emoji, customId, url) {
      if (url && customId) {
        throw new RangeError("URL and custom id are mutually exclusive");
      }
      if (!label && !emoji) {
        throw new RangeError("Buttons must have a label and/or an emoji");
      }
      if (style === import_v10.ButtonStyle.Link) {
        if (!url) {
          throw new RangeError("Link buttons must have a url");
        }
      } else if (url) {
        throw new RangeError("Non-link buttons cannot have a url");
      }
    }
    __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
    var import_v107 = require_v106();
    var ComponentBuilder = class {
      data;
      constructor(data) {
        this.data = data;
      }
    };
    __name(ComponentBuilder, "ComponentBuilder");
    var import_v106 = require_v106();
    var import_v102 = require_v106();
    var ButtonBuilder = class extends ComponentBuilder {
      constructor(data) {
        super({ type: import_v102.ComponentType.Button, ...data });
      }
      setStyle(style) {
        this.data.style = buttonStyleValidator.parse(style);
        return this;
      }
      setURL(url) {
        this.data.url = urlValidator.parse(url);
        return this;
      }
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      setEmoji(emoji) {
        this.data.emoji = emojiValidator.parse(emoji);
        return this;
      }
      setDisabled(disabled = true) {
        this.data.disabled = disabledValidator.parse(disabled);
        return this;
      }
      setLabel(label) {
        this.data.label = buttonLabelValidator.parse(label);
        return this;
      }
      toJSON() {
        validateRequiredButtonParameters(
          this.data.style,
          this.data.label,
          this.data.emoji,
          this.data.custom_id,
          this.data.url
        );
        return {
          ...this.data
        };
      }
    };
    __name(ButtonBuilder, "ButtonBuilder");
    var import_v103 = require_v106();
    var SelectMenuBuilder = class extends ComponentBuilder {
      options;
      constructor(data) {
        const { options, ...initData } = data ?? {};
        super({ type: import_v103.ComponentType.SelectMenu, ...initData });
        this.options = (options == null ? void 0 : options.map((option) => new SelectMenuOptionBuilder(option))) ?? [];
      }
      setPlaceholder(placeholder) {
        this.data.placeholder = placeholderValidator.parse(placeholder);
        return this;
      }
      setMinValues(minValues) {
        this.data.min_values = minMaxValidator.parse(minValues);
        return this;
      }
      setMaxValues(maxValues) {
        this.data.max_values = minMaxValidator.parse(maxValues);
        return this;
      }
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      setDisabled(disabled = true) {
        this.data.disabled = disabledValidator.parse(disabled);
        return this;
      }
      addOptions(...options) {
        options = normalizeArray(options);
        optionsLengthValidator.parse(this.options.length + options.length);
        this.options.push(
          ...options.map(
            (option) => option instanceof SelectMenuOptionBuilder ? option : new SelectMenuOptionBuilder(jsonOptionValidator.parse(option))
          )
        );
        return this;
      }
      setOptions(...options) {
        options = normalizeArray(options);
        optionsLengthValidator.parse(options.length);
        this.options.splice(
          0,
          this.options.length,
          ...options.map(
            (option) => option instanceof SelectMenuOptionBuilder ? option : new SelectMenuOptionBuilder(jsonOptionValidator.parse(option))
          )
        );
        return this;
      }
      toJSON() {
        validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
        return {
          ...this.data,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(SelectMenuBuilder, "SelectMenuBuilder");
    var import_util2 = require_dist2();
    var import_v105 = require_v106();
    var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
    var Assertions_exports3 = {};
    __export2(Assertions_exports3, {
      labelValidator: () => labelValidator,
      maxLengthValidator: () => maxLengthValidator,
      minLengthValidator: () => minLengthValidator,
      placeholderValidator: () => placeholderValidator2,
      requiredValidator: () => requiredValidator,
      textInputStyleValidator: () => textInputStyleValidator,
      validateRequiredParameters: () => validateRequiredParameters,
      valueValidator: () => valueValidator
    });
    var import_shapeshift3 = require_dist6();
    var import_v104 = require_v106();
    var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v104.TextInputStyle);
    var minLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var maxLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(1).lessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var requiredValidator = import_shapeshift3.s.boolean;
    var valueValidator = import_shapeshift3.s.string.lengthLessThanOrEqual(4e3).setValidationEnabled(isValidationEnabled);
    var placeholderValidator2 = import_shapeshift3.s.string.lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var labelValidator = import_shapeshift3.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
    function validateRequiredParameters(customId, style, label) {
      customIdValidator.parse(customId);
      textInputStyleValidator.parse(style);
      labelValidator.parse(label);
    }
    __name(validateRequiredParameters, "validateRequiredParameters");
    var TextInputBuilder = class extends ComponentBuilder {
      constructor(data) {
        super({ type: import_v105.ComponentType.TextInput, ...data });
      }
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      setLabel(label) {
        this.data.label = labelValidator.parse(label);
        return this;
      }
      setStyle(style) {
        this.data.style = textInputStyleValidator.parse(style);
        return this;
      }
      setMinLength(minLength) {
        this.data.min_length = minLengthValidator.parse(minLength);
        return this;
      }
      setMaxLength(maxLength) {
        this.data.max_length = maxLengthValidator.parse(maxLength);
        return this;
      }
      setPlaceholder(placeholder) {
        this.data.placeholder = placeholderValidator2.parse(placeholder);
        return this;
      }
      setValue(value) {
        this.data.value = valueValidator.parse(value);
        return this;
      }
      setRequired(required = true) {
        this.data.required = requiredValidator.parse(required);
        return this;
      }
      toJSON() {
        validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
        return {
          ...this.data
        };
      }
      equals(other) {
        if ((0, import_util2.isJSONEncodable)(other)) {
          return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
        }
        return (0, import_fast_deep_equal.default)(other, this.data);
      }
    };
    __name(TextInputBuilder, "TextInputBuilder");
    function createComponentBuilder(data) {
      if (data instanceof ComponentBuilder) {
        return data;
      }
      switch (data.type) {
        case import_v106.ComponentType.ActionRow:
          return new ActionRowBuilder(data);
        case import_v106.ComponentType.Button:
          return new ButtonBuilder(data);
        case import_v106.ComponentType.SelectMenu:
          return new SelectMenuBuilder(data);
        case import_v106.ComponentType.TextInput:
          return new TextInputBuilder(data);
        default:
          throw new Error(`Cannot properly serialize component type: ${data.type}`);
      }
    }
    __name(createComponentBuilder, "createComponentBuilder");
    var ActionRowBuilder = class extends ComponentBuilder {
      components;
      constructor({ components, ...data } = {}) {
        super({ type: import_v107.ComponentType.ActionRow, ...data });
        this.components = (components == null ? void 0 : components.map((component) => createComponentBuilder(component))) ?? [];
      }
      addComponents(...components) {
        this.components.push(...normalizeArray(components));
        return this;
      }
      setComponents(...components) {
        this.components.splice(0, this.components.length, ...normalizeArray(components));
        return this;
      }
      toJSON() {
        return {
          ...this.data,
          components: this.components.map((component) => component.toJSON())
        };
      }
    };
    __name(ActionRowBuilder, "ActionRowBuilder");
    var Assertions_exports4 = {};
    __export2(Assertions_exports4, {
      componentsValidator: () => componentsValidator,
      titleValidator: () => titleValidator,
      validateRequiredParameters: () => validateRequiredParameters2
    });
    var import_shapeshift4 = require_dist6();
    var titleValidator = import_shapeshift4.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
    var componentsValidator = import_shapeshift4.s.instance(ActionRowBuilder).array.lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
    function validateRequiredParameters2(customId, title, components) {
      customIdValidator.parse(customId);
      titleValidator.parse(title);
      componentsValidator.parse(components);
    }
    __name(validateRequiredParameters2, "validateRequiredParameters");
    var ModalBuilder = class {
      data;
      components = [];
      constructor({ components, ...data } = {}) {
        this.data = { ...data };
        this.components = (components == null ? void 0 : components.map((component) => createComponentBuilder(component))) ?? [];
      }
      setTitle(title) {
        this.data.title = titleValidator.parse(title);
        return this;
      }
      setCustomId(customId) {
        this.data.custom_id = customIdValidator.parse(customId);
        return this;
      }
      addComponents(...components) {
        this.components.push(
          ...normalizeArray(components).map(
            (component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)
          )
        );
        return this;
      }
      setComponents(...components) {
        this.components.splice(0, this.components.length, ...normalizeArray(components));
        return this;
      }
      toJSON() {
        validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
        return {
          ...this.data,
          components: this.components.map((component) => component.toJSON())
        };
      }
    };
    __name(ModalBuilder, "ModalBuilder");
    var Assertions_exports5 = {};
    __export2(Assertions_exports5, {
      assertReturnOfBuilder: () => assertReturnOfBuilder,
      localizationMapPredicate: () => localizationMapPredicate,
      validateChoicesLength: () => validateChoicesLength,
      validateDMPermission: () => validateDMPermission,
      validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
      validateDefaultPermission: () => validateDefaultPermission,
      validateDescription: () => validateDescription,
      validateLocale: () => validateLocale,
      validateLocalizationMap: () => validateLocalizationMap,
      validateMaxOptionsLength: () => validateMaxOptionsLength,
      validateName: () => validateName,
      validateRequired: () => validateRequired,
      validateRequiredParameters: () => validateRequiredParameters3
    });
    var import_shapeshift5 = require_dist6();
    var import_v108 = require_v106();
    var namePredicate = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
    function validateName(name) {
      namePredicate.parse(name);
    }
    __name(validateName, "validateName");
    var descriptionPredicate2 = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
    var localePredicate = import_shapeshift5.s.nativeEnum(import_v108.Locale);
    function validateDescription(description) {
      descriptionPredicate2.parse(description);
    }
    __name(validateDescription, "validateDescription");
    var maxArrayLengthPredicate = import_shapeshift5.s.unknown.array.lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateLocale(locale) {
      return localePredicate.parse(locale);
    }
    __name(validateLocale, "validateLocale");
    function validateMaxOptionsLength(options) {
      maxArrayLengthPredicate.parse(options);
    }
    __name(validateMaxOptionsLength, "validateMaxOptionsLength");
    function validateRequiredParameters3(name, description, options) {
      validateName(name);
      validateDescription(description);
      validateMaxOptionsLength(options);
    }
    __name(validateRequiredParameters3, "validateRequiredParameters");
    var booleanPredicate = import_shapeshift5.s.boolean;
    function validateDefaultPermission(value) {
      booleanPredicate.parse(value);
    }
    __name(validateDefaultPermission, "validateDefaultPermission");
    function validateRequired(required) {
      booleanPredicate.parse(required);
    }
    __name(validateRequired, "validateRequired");
    var choicesLengthPredicate = import_shapeshift5.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
    function validateChoicesLength(amountAdding, choices) {
      choicesLengthPredicate.parse(((choices == null ? void 0 : choices.length) ?? 0) + amountAdding);
    }
    __name(validateChoicesLength, "validateChoicesLength");
    function assertReturnOfBuilder(input, ExpectedInstanceOf) {
      import_shapeshift5.s.instance(ExpectedInstanceOf).parse(input);
    }
    __name(assertReturnOfBuilder, "assertReturnOfBuilder");
    var localizationMapPredicate = import_shapeshift5.s.object(Object.fromEntries(Object.values(import_v108.Locale).map((locale) => [locale, import_shapeshift5.s.string.nullish]))).strict.nullish.setValidationEnabled(isValidationEnabled);
    function validateLocalizationMap(value) {
      localizationMapPredicate.parse(value);
    }
    __name(validateLocalizationMap, "validateLocalizationMap");
    var dmPermissionPredicate = import_shapeshift5.s.boolean.nullish;
    function validateDMPermission(value) {
      dmPermissionPredicate.parse(value);
    }
    __name(validateDMPermission, "validateDMPermission");
    var memberPermissionPredicate = import_shapeshift5.s.union(
      import_shapeshift5.s.bigint.transform((value) => value.toString()),
      import_shapeshift5.s.number.safeInt.transform((value) => value.toString()),
      import_shapeshift5.s.string.regex(/^\d+$/)
    ).nullish;
    function validateDefaultMemberPermissions(permissions2) {
      return memberPermissionPredicate.parse(permissions2);
    }
    __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
    var import_ts_mixer6 = (init_esm(), __toCommonJS(esm_exports));
    var import_v1020 = require_v106();
    var import_ts_mixer5 = (init_esm(), __toCommonJS(esm_exports));
    var SharedNameAndDescription = class {
      name;
      name_localizations;
      description;
      description_localizations;
      setName(name) {
        validateName(name);
        Reflect.set(this, "name", name);
        return this;
      }
      setDescription(description) {
        validateDescription(description);
        Reflect.set(this, "description", description);
        return this;
      }
      setNameLocalization(locale, localizedName) {
        if (!this.name_localizations) {
          Reflect.set(this, "name_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedName === null) {
          this.name_localizations[parsedLocale] = null;
          return this;
        }
        validateName(localizedName);
        this.name_localizations[parsedLocale] = localizedName;
        return this;
      }
      setNameLocalizations(localizedNames) {
        if (localizedNames === null) {
          Reflect.set(this, "name_localizations", null);
          return this;
        }
        Reflect.set(this, "name_localizations", {});
        for (const args of Object.entries(localizedNames)) {
          this.setNameLocalization(...args);
        }
        return this;
      }
      setDescriptionLocalization(locale, localizedDescription) {
        if (!this.description_localizations) {
          Reflect.set(this, "description_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedDescription === null) {
          this.description_localizations[parsedLocale] = null;
          return this;
        }
        validateDescription(localizedDescription);
        this.description_localizations[parsedLocale] = localizedDescription;
        return this;
      }
      setDescriptionLocalizations(localizedDescriptions) {
        if (localizedDescriptions === null) {
          Reflect.set(this, "description_localizations", null);
          return this;
        }
        Reflect.set(this, "description_localizations", {});
        for (const args of Object.entries(localizedDescriptions)) {
          this.setDescriptionLocalization(...args);
        }
        return this;
      }
    };
    __name(SharedNameAndDescription, "SharedNameAndDescription");
    var import_v109 = require_v106();
    var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
      required = false;
      setRequired(required) {
        validateRequired(required);
        Reflect.set(this, "required", required);
        return this;
      }
      runRequiredValidations() {
        validateRequiredParameters3(this.name, this.description, []);
        validateLocalizationMap(this.name_localizations);
        validateLocalizationMap(this.description_localizations);
        validateRequired(this.required);
      }
    };
    __name(ApplicationCommandOptionBase, "ApplicationCommandOptionBase");
    var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
      type = import_v109.ApplicationCommandOptionType.Attachment;
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandAttachmentOption, "SlashCommandAttachmentOption");
    var import_v1010 = require_v106();
    var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
      type = import_v1010.ApplicationCommandOptionType.Boolean;
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandBooleanOption, "SlashCommandBooleanOption");
    var import_v1012 = require_v106();
    var import_ts_mixer = (init_esm(), __toCommonJS(esm_exports));
    var import_shapeshift6 = require_dist6();
    var import_v1011 = require_v106();
    var allowedChannelTypes = [
      import_v1011.ChannelType.GuildText,
      import_v1011.ChannelType.GuildVoice,
      import_v1011.ChannelType.GuildCategory,
      import_v1011.ChannelType.GuildAnnouncement,
      import_v1011.ChannelType.AnnouncementThread,
      import_v1011.ChannelType.PublicThread,
      import_v1011.ChannelType.PrivateThread,
      import_v1011.ChannelType.GuildStageVoice,
      import_v1011.ChannelType.GuildForum
    ];
    var channelTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.union(...allowedChannelTypes.map((type) => import_shapeshift6.s.literal(type))));
    var ApplicationCommandOptionChannelTypesMixin = class {
      channel_types;
      addChannelTypes(...channelTypes) {
        if (this.channel_types === void 0) {
          Reflect.set(this, "channel_types", []);
        }
        this.channel_types.push(...channelTypesPredicate.parse(channelTypes));
        return this;
      }
    };
    __name(ApplicationCommandOptionChannelTypesMixin, "ApplicationCommandOptionChannelTypesMixin");
    var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
      type = import_v1012.ApplicationCommandOptionType.Channel;
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandChannelOption, "SlashCommandChannelOption");
    SlashCommandChannelOption = __decorateClass([
      (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
    ], SlashCommandChannelOption);
    var import_shapeshift8 = require_dist6();
    var import_v1014 = require_v106();
    var import_ts_mixer2 = (init_esm(), __toCommonJS(esm_exports));
    var ApplicationCommandNumericOptionMinMaxValueMixin = class {
      max_value;
      min_value;
    };
    __name(ApplicationCommandNumericOptionMinMaxValueMixin, "ApplicationCommandNumericOptionMinMaxValueMixin");
    var import_shapeshift7 = require_dist6();
    var import_v1013 = require_v106();
    var stringPredicate = import_shapeshift7.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
    var numberPredicate = import_shapeshift7.s.number.greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
    var choicesPredicate = import_shapeshift7.s.object({
      name: stringPredicate,
      name_localizations: localizationMapPredicate,
      value: import_shapeshift7.s.union(stringPredicate, numberPredicate)
    }).array;
    var booleanPredicate2 = import_shapeshift7.s.boolean;
    var ApplicationCommandOptionWithChoicesAndAutocompleteMixin = class {
      choices;
      autocomplete;
      type;
      addChoices(...choices) {
        if (choices.length > 0 && this.autocomplete) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        choicesPredicate.parse(choices);
        if (this.choices === void 0) {
          Reflect.set(this, "choices", []);
        }
        validateChoicesLength(choices.length, this.choices);
        for (const { name, name_localizations, value } of choices) {
          if (this.type === import_v1013.ApplicationCommandOptionType.String) {
            stringPredicate.parse(value);
          } else {
            numberPredicate.parse(value);
          }
          this.choices.push({ name, name_localizations, value });
        }
        return this;
      }
      setChoices(...choices) {
        if (choices.length > 0 && this.autocomplete) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        choicesPredicate.parse(choices);
        Reflect.set(this, "choices", []);
        this.addChoices(...choices);
        return this;
      }
      setAutocomplete(autocomplete) {
        booleanPredicate2.parse(autocomplete);
        if (autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        Reflect.set(this, "autocomplete", autocomplete);
        return this;
      }
    };
    __name(ApplicationCommandOptionWithChoicesAndAutocompleteMixin, "ApplicationCommandOptionWithChoicesAndAutocompleteMixin");
    var numberValidator = import_shapeshift8.s.number.int;
    var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
      type = import_v1014.ApplicationCommandOptionType.Integer;
      setMaxValue(max) {
        numberValidator.parse(max);
        Reflect.set(this, "max_value", max);
        return this;
      }
      setMinValue(min) {
        numberValidator.parse(min);
        Reflect.set(this, "min_value", min);
        return this;
      }
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return { ...this };
      }
    };
    __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
    SlashCommandIntegerOption = __decorateClass([
      (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandIntegerOption);
    var import_v1015 = require_v106();
    var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
      type = import_v1015.ApplicationCommandOptionType.Mentionable;
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandMentionableOption, "SlashCommandMentionableOption");
    var import_shapeshift9 = require_dist6();
    var import_v1016 = require_v106();
    var import_ts_mixer3 = (init_esm(), __toCommonJS(esm_exports));
    var numberValidator2 = import_shapeshift9.s.number;
    var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
      type = import_v1016.ApplicationCommandOptionType.Number;
      setMaxValue(max) {
        numberValidator2.parse(max);
        Reflect.set(this, "max_value", max);
        return this;
      }
      setMinValue(min) {
        numberValidator2.parse(min);
        Reflect.set(this, "min_value", min);
        return this;
      }
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return { ...this };
      }
    };
    __name(SlashCommandNumberOption, "SlashCommandNumberOption");
    SlashCommandNumberOption = __decorateClass([
      (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandNumberOption);
    var import_v1017 = require_v106();
    var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
      type = import_v1017.ApplicationCommandOptionType.Role;
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandRoleOption, "SlashCommandRoleOption");
    var import_shapeshift10 = require_dist6();
    var import_v1018 = require_v106();
    var import_ts_mixer4 = (init_esm(), __toCommonJS(esm_exports));
    var minLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(0).lessThanOrEqual(6e3);
    var maxLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(1).lessThanOrEqual(6e3);
    var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
      type = import_v1018.ApplicationCommandOptionType.String;
      max_length;
      min_length;
      setMaxLength(max) {
        maxLengthValidator2.parse(max);
        Reflect.set(this, "max_length", max);
        return this;
      }
      setMinLength(min) {
        minLengthValidator2.parse(min);
        Reflect.set(this, "min_length", min);
        return this;
      }
      toJSON() {
        this.runRequiredValidations();
        if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
          throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
        }
        return { ...this };
      }
    };
    __name(SlashCommandStringOption, "SlashCommandStringOption");
    SlashCommandStringOption = __decorateClass([
      (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
    ], SlashCommandStringOption);
    var import_v1019 = require_v106();
    var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
      type = import_v1019.ApplicationCommandOptionType.User;
      toJSON() {
        this.runRequiredValidations();
        return { ...this };
      }
    };
    __name(SlashCommandUserOption, "SlashCommandUserOption");
    var SharedSlashCommandOptions = class {
      options;
      addBooleanOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
      }
      addUserOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandUserOption);
      }
      addChannelOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
      }
      addRoleOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
      }
      addAttachmentOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
      }
      addMentionableOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
      }
      addStringOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandStringOption);
      }
      addIntegerOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
      }
      addNumberOption(input) {
        return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
      }
      _sharedAddOptionMethod(input, Instance) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new Instance()) : input;
        assertReturnOfBuilder(result, Instance);
        options.push(result);
        return this;
      }
    };
    __name(SharedSlashCommandOptions, "SharedSlashCommandOptions");
    var SlashCommandSubcommandGroupBuilder = class {
      name = void 0;
      description = void 0;
      options = [];
      addSubcommand(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
        options.push(result);
        return this;
      }
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        return {
          type: import_v1020.ApplicationCommandOptionType.SubcommandGroup,
          name: this.name,
          name_localizations: this.name_localizations,
          description: this.description,
          description_localizations: this.description_localizations,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
    SlashCommandSubcommandGroupBuilder = __decorateClass([
      (0, import_ts_mixer5.mix)(SharedNameAndDescription)
    ], SlashCommandSubcommandGroupBuilder);
    var SlashCommandSubcommandBuilder = class {
      name = void 0;
      description = void 0;
      options = [];
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        return {
          type: import_v1020.ApplicationCommandOptionType.Subcommand,
          name: this.name,
          name_localizations: this.name_localizations,
          description: this.description,
          description_localizations: this.description_localizations,
          options: this.options.map((option) => option.toJSON())
        };
      }
    };
    __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
    SlashCommandSubcommandBuilder = __decorateClass([
      (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
    ], SlashCommandSubcommandBuilder);
    var SlashCommandBuilder2 = class {
      name = void 0;
      name_localizations;
      description = void 0;
      description_localizations;
      options = [];
      default_permission = void 0;
      default_member_permissions = void 0;
      dm_permission = void 0;
      toJSON() {
        validateRequiredParameters3(this.name, this.description, this.options);
        validateLocalizationMap(this.name_localizations);
        validateLocalizationMap(this.description_localizations);
        return {
          ...this,
          options: this.options.map((option) => option.toJSON())
        };
      }
      setDefaultPermission(value) {
        validateDefaultPermission(value);
        Reflect.set(this, "default_permission", value);
        return this;
      }
      setDefaultMemberPermissions(permissions2) {
        const permissionValue = validateDefaultMemberPermissions(permissions2);
        Reflect.set(this, "default_member_permissions", permissionValue);
        return this;
      }
      setDMPermission(enabled) {
        validateDMPermission(enabled);
        Reflect.set(this, "dm_permission", enabled);
        return this;
      }
      addSubcommandGroup(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandGroupBuilder);
        options.push(result);
        return this;
      }
      addSubcommand(input) {
        const { options } = this;
        validateMaxOptionsLength(options);
        const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder()) : input;
        assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
        options.push(result);
        return this;
      }
    };
    __name(SlashCommandBuilder2, "SlashCommandBuilder");
    SlashCommandBuilder2 = __decorateClass([
      (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription)
    ], SlashCommandBuilder2);
    var Assertions_exports6 = {};
    __export2(Assertions_exports6, {
      validateDMPermission: () => validateDMPermission2,
      validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
      validateDefaultPermission: () => validateDefaultPermission2,
      validateName: () => validateName2,
      validateRequiredParameters: () => validateRequiredParameters4,
      validateType: () => validateType
    });
    var import_shapeshift11 = require_dist6();
    var import_v1021 = require_v106();
    var namePredicate2 = import_shapeshift11.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+ *)+$/u).setValidationEnabled(isValidationEnabled);
    var typePredicate = import_shapeshift11.s.union(import_shapeshift11.s.literal(import_v1021.ApplicationCommandType.User), import_shapeshift11.s.literal(import_v1021.ApplicationCommandType.Message)).setValidationEnabled(isValidationEnabled);
    var booleanPredicate3 = import_shapeshift11.s.boolean;
    function validateDefaultPermission2(value) {
      booleanPredicate3.parse(value);
    }
    __name(validateDefaultPermission2, "validateDefaultPermission");
    function validateName2(name) {
      namePredicate2.parse(name);
    }
    __name(validateName2, "validateName");
    function validateType(type) {
      typePredicate.parse(type);
    }
    __name(validateType, "validateType");
    function validateRequiredParameters4(name, type) {
      validateName2(name);
      validateType(type);
    }
    __name(validateRequiredParameters4, "validateRequiredParameters");
    var dmPermissionPredicate2 = import_shapeshift11.s.boolean.nullish;
    function validateDMPermission2(value) {
      dmPermissionPredicate2.parse(value);
    }
    __name(validateDMPermission2, "validateDMPermission");
    var memberPermissionPredicate2 = import_shapeshift11.s.union(
      import_shapeshift11.s.bigint.transform((value) => value.toString()),
      import_shapeshift11.s.number.safeInt.transform((value) => value.toString()),
      import_shapeshift11.s.string.regex(/^\d+$/)
    ).nullish;
    function validateDefaultMemberPermissions2(permissions2) {
      return memberPermissionPredicate2.parse(permissions2);
    }
    __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
    var ContextMenuCommandBuilder = class {
      name = void 0;
      name_localizations;
      type = void 0;
      default_permission = void 0;
      default_member_permissions = void 0;
      dm_permission = void 0;
      setName(name) {
        validateName2(name);
        Reflect.set(this, "name", name);
        return this;
      }
      setType(type) {
        validateType(type);
        Reflect.set(this, "type", type);
        return this;
      }
      setDefaultPermission(value) {
        validateDefaultPermission2(value);
        Reflect.set(this, "default_permission", value);
        return this;
      }
      setDefaultMemberPermissions(permissions2) {
        const permissionValue = validateDefaultMemberPermissions2(permissions2);
        Reflect.set(this, "default_member_permissions", permissionValue);
        return this;
      }
      setDMPermission(enabled) {
        validateDMPermission2(enabled);
        Reflect.set(this, "dm_permission", enabled);
        return this;
      }
      setNameLocalization(locale, localizedName) {
        if (!this.name_localizations) {
          Reflect.set(this, "name_localizations", {});
        }
        const parsedLocale = validateLocale(locale);
        if (localizedName === null) {
          this.name_localizations[parsedLocale] = null;
          return this;
        }
        validateName2(localizedName);
        this.name_localizations[parsedLocale] = localizedName;
        return this;
      }
      setNameLocalizations(localizedNames) {
        if (localizedNames === null) {
          Reflect.set(this, "name_localizations", null);
          return this;
        }
        Reflect.set(this, "name_localizations", {});
        for (const args of Object.entries(localizedNames))
          this.setNameLocalization(...args);
        return this;
      }
      toJSON() {
        validateRequiredParameters4(this.name, this.type);
        validateLocalizationMap(this.name_localizations);
        return { ...this };
      }
    };
    __name(ContextMenuCommandBuilder, "ContextMenuCommandBuilder");
    function embedLength(data) {
      var _a, _b, _c, _d, _e;
      return (((_a = data.title) == null ? void 0 : _a.length) ?? 0) + (((_b = data.description) == null ? void 0 : _b.length) ?? 0) + (((_c = data.fields) == null ? void 0 : _c.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0)) ?? 0) + (((_d = data.footer) == null ? void 0 : _d.text.length) ?? 0) + (((_e = data.author) == null ? void 0 : _e.name.length) ?? 0);
    }
    __name(embedLength, "embedLength");
    __reExport(src_exports2, require_dist2(), module2.exports);
    var version2 = "1.3.0";
  }
});

// ../../node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS({
  "../../node_modules/discord.js/src/structures/Base.js"(exports2, module2) {
    "use strict";
    var { flatten } = require_Util();
    var Base = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
      _patch(data) {
        return data;
      }
      _update(data) {
        const clone = this._clone();
        this._patch(data);
        return clone;
      }
      toJSON(...props) {
        return flatten(this, ...props);
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = Base;
  }
});

// ../../node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS({
  "../../node_modules/discord.js/src/util/BitField.js"(exports2, module2) {
    "use strict";
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var _BitField = class {
      constructor(bits = this.constructor.DefaultBit) {
        this.bitfield = this.constructor.resolve(bits);
      }
      any(bit) {
        return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
      }
      equals(bit) {
        return this.bitfield === this.constructor.resolve(bit);
      }
      has(bit) {
        bit = this.constructor.resolve(bit);
        return (this.bitfield & bit) === bit;
      }
      missing(bits, ...hasParams) {
        return new this.constructor(bits).remove(this).toArray(...hasParams);
      }
      freeze() {
        return Object.freeze(this);
      }
      add(...bits) {
        let total = this.constructor.DefaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this))
          return new this.constructor(this.bitfield | total);
        this.bitfield |= total;
        return this;
      }
      remove(...bits) {
        let total = this.constructor.DefaultBit;
        for (const bit of bits) {
          total |= this.constructor.resolve(bit);
        }
        if (Object.isFrozen(this))
          return new this.constructor(this.bitfield & ~total);
        this.bitfield &= ~total;
        return this;
      }
      serialize(...hasParams) {
        const serialized = {};
        for (const [flag, bit] of Object.entries(this.constructor.Flags))
          serialized[flag] = this.has(bit, ...hasParams);
        return serialized;
      }
      toArray(...hasParams) {
        return Object.keys(this.constructor.Flags).filter((bit) => this.has(bit, ...hasParams));
      }
      toJSON() {
        return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
      }
      valueOf() {
        return this.bitfield;
      }
      *[Symbol.iterator]() {
        yield* this.toArray();
      }
      static resolve(bit) {
        const { DefaultBit } = this;
        if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
          return bit;
        if (bit instanceof _BitField)
          return bit.bitfield;
        if (Array.isArray(bit))
          return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);
        if (typeof bit === "string") {
          if (typeof this.Flags[bit] !== "undefined")
            return this.Flags[bit];
          if (!isNaN(bit))
            return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        }
        throw new DiscordjsRangeError2(ErrorCodes2.BitFieldInvalid, bit);
      }
    };
    var BitField = _BitField;
    __publicField(BitField, "Flags", {});
    __publicField(BitField, "DefaultBit", 0);
    module2.exports = BitField;
  }
});

// ../../node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/ChannelFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ChannelFlags } = require_v106();
    var BitField = require_BitField();
    var ChannelFlagsBitField = class extends BitField {
    };
    __publicField(ChannelFlagsBitField, "Flags", ChannelFlags);
    module2.exports = ChannelFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS({
  "../../node_modules/discord.js/src/util/Constants.js"(exports2) {
    "use strict";
    var { ChannelType, MessageType } = require_v106();
    exports2.SweeperKeys = [
      "applicationCommands",
      "bans",
      "emojis",
      "invites",
      "guildMembers",
      "messages",
      "presences",
      "reactions",
      "stageInstances",
      "stickers",
      "threadMembers",
      "threads",
      "users",
      "voiceStates"
    ];
    exports2.NonSystemMessageTypes = [
      MessageType.Default,
      MessageType.Reply,
      MessageType.ChatInputCommand,
      MessageType.ContextMenuCommand
    ];
    exports2.TextBasedChannelTypes = [
      ChannelType.DM,
      ChannelType.GuildText,
      ChannelType.GuildAnnouncement,
      ChannelType.AnnouncementThread,
      ChannelType.PublicThread,
      ChannelType.PrivateThread,
      ChannelType.GuildVoice
    ];
    exports2.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
    exports2.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  }
});

// ../../node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/BaseChannel.js"(exports2) {
    "use strict";
    var { channelLink } = require_dist7();
    var { DiscordSnowflake } = require_dist3();
    var { ChannelType, Routes: Routes3 } = require_v106();
    var Base = require_Base();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var { ThreadChannelTypes } = require_Constants();
    var BaseChannel = class extends Base {
      constructor(client, data, immediatePatch = true) {
        super(client);
        this.type = data.type;
        if (data && immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        if ("flags" in data) {
          this.flags = new ChannelFlagsBitField(data.flags).freeze();
        } else {
          this.flags ?? (this.flags = new ChannelFlagsBitField().freeze());
        }
        this.id = data.id;
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get url() {
        return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
      }
      get partial() {
        return false;
      }
      toString() {
        return `<#${this.id}>`;
      }
      async delete() {
        await this.client.rest.delete(Routes3.channel(this.id));
        return this;
      }
      fetch(force = true) {
        return this.client.channels.fetch(this.id, { force });
      }
      isThread() {
        return ThreadChannelTypes.includes(this.type);
      }
      isTextBased() {
        return "messages" in this;
      }
      isDMBased() {
        return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
      }
      isVoiceBased() {
        return "bitrate" in this;
      }
      toJSON(...props) {
        return super.toJSON({ createdTimestamp: true }, ...props);
      }
    };
    exports2.BaseChannel = BaseChannel;
  }
});

// ../../node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS({
  "../../node_modules/discord.js/src/managers/BaseManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
      }
    };
    module2.exports = BaseManager;
  }
});

// ../../node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS({
  "../../node_modules/discord.js/src/managers/DataManager.js"(exports2, module2) {
    "use strict";
    var BaseManager = require_BaseManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataManager = class extends BaseManager {
      constructor(client, holds) {
        super(client);
        Object.defineProperty(this, "holds", { value: holds });
      }
      get cache() {
        throw new DiscordjsError2(ErrorCodes2.NotImplemented, "get cache", this.constructor.name);
      }
      resolve(idOrInstance) {
        if (idOrInstance instanceof this.holds)
          return idOrInstance;
        if (typeof idOrInstance === "string")
          return this.cache.get(idOrInstance) ?? null;
        return null;
      }
      resolveId(idOrInstance) {
        if (idOrInstance instanceof this.holds)
          return idOrInstance.id;
        if (typeof idOrInstance === "string")
          return idOrInstance;
        return null;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = DataManager;
  }
});

// ../../node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS({
  "../../node_modules/discord.js/src/managers/CachedManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var CachedManager = class extends DataManager {
      constructor(client, holds, iterable) {
        super(client, holds);
        Object.defineProperty(this, "_cache", { value: this.client.options.makeCache(this.constructor, this.holds) });
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      get cache() {
        return this._cache;
      }
      _add(data, cache = true, { id, extras = [] } = {}) {
        const existing = this.cache.get(id ?? data.id);
        if (existing) {
          if (cache) {
            existing._patch(data);
            return existing;
          }
          const clone = existing._clone();
          clone._patch(data);
          return clone;
        }
        const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
        if (cache)
          this.cache.set(id ?? entry.id, entry);
        return entry;
      }
    };
    module2.exports = CachedManager;
  }
});

// ../../node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/PermissionsBitField.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var BitField = require_BitField();
    var PermissionsBitField5 = class extends BitField {
      missing(bits, checkAdmin = true) {
        return checkAdmin && this.has(PermissionFlagsBits4.Administrator) ? [] : super.missing(bits);
      }
      any(permission, checkAdmin = true) {
        return checkAdmin && super.has(PermissionFlagsBits4.Administrator) || super.any(permission);
      }
      has(permission, checkAdmin = true) {
        return checkAdmin && super.has(PermissionFlagsBits4.Administrator) || super.has(permission);
      }
      toArray() {
        return super.toArray(false);
      }
    };
    __publicField(PermissionsBitField5, "Flags", PermissionFlagsBits4);
    __publicField(PermissionsBitField5, "All", Object.values(PermissionFlagsBits4).reduce((all, p) => all | p, 0n));
    __publicField(PermissionsBitField5, "Default", BigInt(104324673));
    __publicField(PermissionsBitField5, "StageModerator", PermissionFlagsBits4.ManageChannels | PermissionFlagsBits4.MuteMembers | PermissionFlagsBits4.MoveMembers);
    __publicField(PermissionsBitField5, "DefaultBit", BigInt(0));
    module2.exports = PermissionsBitField5;
  }
});

// ../../node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS({
  "../../node_modules/discord.js/src/structures/Role.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionsBitField5 = require_PermissionsBitField();
    var Role = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.icon = null;
        this.unicodeEmoji = null;
        if (data)
          this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("color" in data) {
          this.color = data.color;
        }
        if ("hoist" in data) {
          this.hoist = data.hoist;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("permissions" in data) {
          this.permissions = new PermissionsBitField5(BigInt(data.permissions)).freeze();
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("mentionable" in data) {
          this.mentionable = data.mentionable;
        }
        if ("icon" in data)
          this.icon = data.icon;
        if ("unicode_emoji" in data)
          this.unicodeEmoji = data.unicode_emoji;
        this.tags = data.tags ? {} : null;
        if (data.tags) {
          if ("bot_id" in data.tags) {
            this.tags.botId = data.tags.bot_id;
          }
          if ("integration_id" in data.tags) {
            this.tags.integrationId = data.tags.integration_id;
          }
          if ("premium_subscriber" in data.tags) {
            this.tags.premiumSubscriberRole = true;
          }
        }
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get hexColor() {
        return `#${this.color.toString(16).padStart(6, "0")}`;
      }
      get members() {
        return this.guild.members.cache.filter((m) => m.roles.cache.has(this.id));
      }
      get editable() {
        if (this.managed)
          return false;
        const clientMember = this.guild.members.resolve(this.client.user);
        if (!clientMember.permissions.has(PermissionFlagsBits4.ManageRoles))
          return false;
        return clientMember.roles.highest.comparePositionTo(this) > 0;
      }
      get position() {
        const sorted = this.guild._sortedRoles();
        return [...sorted.values()].indexOf(sorted.get(this.id));
      }
      comparePositionTo(role) {
        return this.guild.roles.comparePositions(this, role);
      }
      edit(data) {
        return this.guild.roles.edit(this, data);
      }
      permissionsIn(channel, checkAdmin = true) {
        channel = this.guild.channels.resolve(channel);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        return channel.rolePermissions(this, checkAdmin);
      }
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      setColor(color, reason) {
        return this.edit({ color, reason });
      }
      setHoist(hoist = true, reason) {
        return this.edit({ hoist, reason });
      }
      setPermissions(permissions2, reason) {
        return this.edit({ permissions: permissions2, reason });
      }
      setMentionable(mentionable = true, reason) {
        return this.edit({ mentionable, reason });
      }
      setIcon(icon, reason) {
        return this.edit({ icon, reason });
      }
      setUnicodeEmoji(unicodeEmoji, reason) {
        return this.edit({ unicodeEmoji, reason });
      }
      setPosition(position, options = {}) {
        return this.guild.roles.setPosition(this, position, options);
      }
      async delete(reason) {
        await this.guild.roles.delete(this.id, reason);
        return this;
      }
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
      }
      equals(role) {
        return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
      }
      toString() {
        if (this.id === this.guild.id)
          return "@everyone";
        return `<@&${this.id}>`;
      }
      toJSON() {
        return {
          ...super.toJSON({ createdTimestamp: true }),
          permissions: this.permissions.toJSON()
        };
      }
    };
    exports2.Role = Role;
  }
});

// ../../node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS({
  "../../node_modules/discord.js/src/structures/PermissionOverwrites.js"(exports2, module2) {
    "use strict";
    var { OverwriteType } = require_v106();
    var Base = require_Base();
    var { Role } = require_Role();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionsBitField5 = require_PermissionsBitField();
    var PermissionOverwrites = class extends Base {
      constructor(client, data, channel) {
        super(client);
        Object.defineProperty(this, "channel", { value: channel });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("type" in data) {
          this.type = data.type;
        }
        if ("deny" in data) {
          this.deny = new PermissionsBitField5(BigInt(data.deny)).freeze();
        }
        if ("allow" in data) {
          this.allow = new PermissionsBitField5(BigInt(data.allow)).freeze();
        }
      }
      async edit(options, reason) {
        await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
        return this;
      }
      async delete(reason) {
        await this.channel.permissionOverwrites.delete(this.id, reason);
        return this;
      }
      toJSON() {
        return {
          id: this.id,
          type: this.type,
          allow: this.allow,
          deny: this.deny
        };
      }
      static resolveOverwriteOptions(options, { allow, deny } = {}) {
        allow = new PermissionsBitField5(allow);
        deny = new PermissionsBitField5(deny);
        for (const [perm, value] of Object.entries(options)) {
          if (value === true) {
            allow.add(perm);
            deny.remove(perm);
          } else if (value === false) {
            allow.remove(perm);
            deny.add(perm);
          } else if (value === null) {
            allow.remove(perm);
            deny.remove(perm);
          }
        }
        return { allow, deny };
      }
      static resolve(overwrite, guild) {
        if (overwrite instanceof this)
          return overwrite.toJSON();
        if (typeof overwrite.id === "string" && overwrite.type in OverwriteType) {
          return {
            id: overwrite.id,
            type: overwrite.type,
            allow: PermissionsBitField5.resolve(overwrite.allow ?? PermissionsBitField5.DefaultBit).toString(),
            deny: PermissionsBitField5.resolve(overwrite.deny ?? PermissionsBitField5.DefaultBit).toString()
          };
        }
        const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
        if (!userOrRole)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
        const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
        return {
          id: userOrRole.id,
          type,
          allow: PermissionsBitField5.resolve(overwrite.allow ?? PermissionsBitField5.DefaultBit).toString(),
          deny: PermissionsBitField5.resolve(overwrite.deny ?? PermissionsBitField5.DefaultBit).toString()
        };
      }
    };
    module2.exports = PermissionOverwrites;
  }
});

// ../../node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS({
  "../../node_modules/discord.js/src/managers/PermissionOverwriteManager.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { Collection: Collection2 } = require_dist();
    var { OverwriteType, Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionOverwrites = require_PermissionOverwrites();
    var { Role } = require_Role();
    var cacheWarningEmitted = false;
    var PermissionOverwriteManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, PermissionOverwrites);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process3.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.channel = channel;
        if (iterable) {
          for (const item of iterable) {
            this._add(item);
          }
        }
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.channel] });
      }
      set(overwrites, reason) {
        if (!Array.isArray(overwrites) && !(overwrites instanceof Collection2)) {
          return Promise.reject(
            new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "overwrites",
              "Array or Collection of Permission Overwrites",
              true
            )
          );
        }
        return this.channel.edit({ permissionOverwrites: overwrites, reason });
      }
      async upsert(userOrRole, options, overwriteOptions = {}, existing) {
        let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        let { type, reason } = overwriteOptions;
        if (typeof type !== "number") {
          userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
          if (!userOrRole)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
          type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
        }
        const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
        await this.client.rest.put(Routes3.channelPermission(this.channel.id, userOrRoleId), {
          body: { id: userOrRoleId, type, allow, deny },
          reason
        });
        return this.channel;
      }
      create(userOrRole, options, overwriteOptions) {
        return this.upsert(userOrRole, options, overwriteOptions);
      }
      edit(userOrRole, options, overwriteOptions) {
        const existing = this.cache.get(
          this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole)
        );
        return this.upsert(userOrRole, options, overwriteOptions, existing);
      }
      async delete(userOrRole, reason) {
        const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
        if (!userOrRoleId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "parameter", "User nor a Role");
        await this.client.rest.delete(Routes3.channelPermission(this.channel.id, userOrRoleId), { reason });
        return this.channel;
      }
    };
    module2.exports = PermissionOverwriteManager;
  }
});

// ../../node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildChannel.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PermissionOverwriteManager = require_PermissionOverwriteManager();
    var { VoiceBasedChannelTypes } = require_Constants();
    var PermissionsBitField5 = require_PermissionsBitField();
    var GuildChannel = class extends BaseChannel {
      constructor(guild, data, client, immediatePatch = true) {
        super((guild == null ? void 0 : guild.client) ?? client, data, false);
        this.guild = guild;
        this.guildId = (guild == null ? void 0 : guild.id) ?? data.guild_id;
        this.parentId = this.parentId ?? null;
        this.permissionOverwrites = new PermissionOverwriteManager(this);
        if (data && immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("position" in data) {
          this.rawPosition = data.position;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        }
        if ("permission_overwrites" in data) {
          this.permissionOverwrites.cache.clear();
          for (const overwrite of data.permission_overwrites) {
            this.permissionOverwrites._add(overwrite);
          }
        }
      }
      _clone() {
        const clone = super._clone();
        clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
        return clone;
      }
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      get permissionsLocked() {
        if (!this.parent)
          return null;
        const overwriteIds = /* @__PURE__ */ new Set([
          ...this.permissionOverwrites.cache.keys(),
          ...this.parent.permissionOverwrites.cache.keys()
        ]);
        return [...overwriteIds].every((key) => {
          const channelVal = this.permissionOverwrites.cache.get(key);
          const parentVal = this.parent.permissionOverwrites.cache.get(key);
          if (!channelVal && parentVal.deny.bitfield === PermissionsBitField5.DefaultBit && parentVal.allow.bitfield === PermissionsBitField5.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField5.DefaultBit && channelVal.allow.bitfield === PermissionsBitField5.DefaultBit) {
            return true;
          }
          return typeof channelVal !== "undefined" && typeof parentVal !== "undefined" && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
        });
      }
      get position() {
        const sorted = this.guild._sortedChannels(this);
        return [...sorted.values()].indexOf(sorted.get(this.id));
      }
      permissionsFor(memberOrRole, checkAdmin = true) {
        const member = this.guild.members.resolve(memberOrRole);
        if (member)
          return this.memberPermissions(member, checkAdmin);
        const role = this.guild.roles.resolve(memberOrRole);
        return role && this.rolePermissions(role, checkAdmin);
      }
      overwritesFor(member, verified = false, roles = null) {
        if (!verified)
          member = this.guild.members.resolve(member);
        if (!member)
          return [];
        roles ?? (roles = member.roles.cache);
        const roleOverwrites = [];
        let memberOverwrites;
        let everyoneOverwrites;
        for (const overwrite of this.permissionOverwrites.cache.values()) {
          if (overwrite.id === this.guild.id) {
            everyoneOverwrites = overwrite;
          } else if (roles.has(overwrite.id)) {
            roleOverwrites.push(overwrite);
          } else if (overwrite.id === member.id) {
            memberOverwrites = overwrite;
          }
        }
        return {
          everyone: everyoneOverwrites,
          roles: roleOverwrites,
          member: memberOverwrites
        };
      }
      memberPermissions(member, checkAdmin) {
        var _a, _b, _c, _d;
        if (checkAdmin && member.id === this.guild.ownerId) {
          return new PermissionsBitField5(PermissionsBitField5.All).freeze();
        }
        const roles = member.roles.cache;
        const permissions2 = new PermissionsBitField5(roles.map((role) => role.permissions));
        if (checkAdmin && permissions2.has(PermissionFlagsBits4.Administrator)) {
          return new PermissionsBitField5(PermissionsBitField5.All).freeze();
        }
        const overwrites = this.overwritesFor(member, true, roles);
        return permissions2.remove(((_a = overwrites.everyone) == null ? void 0 : _a.deny) ?? PermissionsBitField5.DefaultBit).add(((_b = overwrites.everyone) == null ? void 0 : _b.allow) ?? PermissionsBitField5.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField5.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField5.DefaultBit).remove(((_c = overwrites.member) == null ? void 0 : _c.deny) ?? PermissionsBitField5.DefaultBit).add(((_d = overwrites.member) == null ? void 0 : _d.allow) ?? PermissionsBitField5.DefaultBit).freeze();
      }
      rolePermissions(role, checkAdmin) {
        if (checkAdmin && role.permissions.has(PermissionFlagsBits4.Administrator)) {
          return new PermissionsBitField5(PermissionsBitField5.All).freeze();
        }
        const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
        const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
        return role.permissions.remove((everyoneOverwrites == null ? void 0 : everyoneOverwrites.deny) ?? PermissionsBitField5.DefaultBit).add((everyoneOverwrites == null ? void 0 : everyoneOverwrites.allow) ?? PermissionsBitField5.DefaultBit).remove((roleOverwrites == null ? void 0 : roleOverwrites.deny) ?? PermissionsBitField5.DefaultBit).add((roleOverwrites == null ? void 0 : roleOverwrites.allow) ?? PermissionsBitField5.DefaultBit).freeze();
      }
      lockPermissions() {
        if (!this.parent)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.GuildChannelOrphan));
        const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
        return this.edit({ permissionOverwrites });
      }
      get members() {
        return this.guild.members.cache.filter((m) => this.permissionsFor(m).has(PermissionFlagsBits4.ViewChannel, false));
      }
      edit(data) {
        return this.guild.channels.edit(this, data);
      }
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      setParent(channel, { lockPermissions = true, reason } = {}) {
        return this.edit({
          parent: channel ?? null,
          lockPermissions,
          reason
        });
      }
      setPosition(position, options = {}) {
        return this.guild.channels.setPosition(this, position, options);
      }
      clone(options = {}) {
        return this.guild.channels.create({
          name: options.name ?? this.name,
          permissionOverwrites: this.permissionOverwrites.cache,
          topic: this.topic,
          type: this.type,
          nsfw: this.nsfw,
          parent: this.parent,
          bitrate: this.bitrate,
          userLimit: this.userLimit,
          rateLimitPerUser: this.rateLimitPerUser,
          position: this.rawPosition,
          reason: null,
          ...options
        });
      }
      equals(channel) {
        let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
        if (equal) {
          if (this.permissionOverwrites && channel.permissionOverwrites) {
            equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
          } else {
            equal = !this.permissionOverwrites && !channel.permissionOverwrites;
          }
        }
        return equal;
      }
      get deletable() {
        return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
      }
      get manageable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        if (permissions2.has(PermissionFlagsBits4.Administrator, false))
          return true;
        if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
          return false;
        const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits4.ManageChannels | PermissionFlagsBits4.Connect : PermissionFlagsBits4.ViewChannel | PermissionFlagsBits4.ManageChannels;
        return permissions2.has(bitfield, false);
      }
      get viewable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        return permissions2.has(PermissionFlagsBits4.ViewChannel, false);
      }
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
    };
    module2.exports = GuildChannel;
  }
});

// ../../node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS({
  "../../node_modules/discord.js/src/util/Util.js"(exports2, module2) {
    "use strict";
    var { parse: parse2 } = require("path");
    var { Collection: Collection2 } = require_dist();
    var { ChannelType, RouteBases, Routes: Routes3 } = require_v106();
    var { fetch } = require_undici();
    var Colors = require_Colors();
    var { DiscordjsError: DiscordjsError2, DiscordjsRangeError: DiscordjsRangeError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var isObject = (d) => typeof d === "object" && d !== null;
    function flatten(obj, ...props) {
      if (!isObject(obj))
        return obj;
      const objProps = Object.keys(obj).filter((k) => !k.startsWith("_")).map((k) => ({ [k]: true }));
      props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
      const out = {};
      for (let [prop, newProp] of Object.entries(props)) {
        if (!newProp)
          continue;
        newProp = newProp === true ? prop : newProp;
        const element = obj[prop];
        const elemIsObj = isObject(element);
        const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
        const hasToJSON = elemIsObj && typeof element.toJSON === "function";
        if (element instanceof Collection2)
          out[newProp] = Array.from(element.keys());
        else if (valueOf instanceof Collection2)
          out[newProp] = Array.from(valueOf.keys());
        else if (Array.isArray(element))
          out[newProp] = element.map((e) => {
            var _a;
            return ((_a = e.toJSON) == null ? void 0 : _a.call(e)) ?? flatten(e);
          });
        else if (typeof valueOf !== "object")
          out[newProp] = valueOf;
        else if (hasToJSON)
          out[newProp] = element.toJSON();
        else if (typeof element === "object")
          out[newProp] = flatten(element);
        else if (!elemIsObj)
          out[newProp] = element;
      }
      return out;
    }
    function escapeMarkdown(text, {
      codeBlock = true,
      inlineCode = true,
      bold = true,
      italic = true,
      underline = true,
      strikethrough = true,
      spoiler = true,
      codeBlockContent = true,
      inlineCodeContent = true,
      escape = true,
      heading = false,
      bulletedList = false,
      numberedList = false,
      maskedLink = false
    } = {}) {
      if (!codeBlockContent) {
        return text.split("```").map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return escapeMarkdown(subString, {
            inlineCode,
            bold,
            italic,
            underline,
            strikethrough,
            spoiler,
            inlineCodeContent,
            escape,
            heading,
            bulletedList,
            numberedList,
            maskedLink
          });
        }).join(codeBlock ? "\\`\\`\\`" : "```");
      }
      if (!inlineCodeContent) {
        return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
          if (index % 2 && index !== array.length - 1)
            return subString;
          return escapeMarkdown(subString, {
            codeBlock,
            bold,
            italic,
            underline,
            strikethrough,
            spoiler,
            escape,
            heading,
            bulletedList,
            numberedList,
            maskedLink
          });
        }).join(inlineCode ? "\\`" : "`");
      }
      if (inlineCode)
        text = escapeInlineCode(text);
      if (codeBlock)
        text = escapeCodeBlock(text);
      if (italic)
        text = escapeItalic(text);
      if (bold)
        text = escapeBold(text);
      if (underline)
        text = escapeUnderline(text);
      if (strikethrough)
        text = escapeStrikethrough(text);
      if (spoiler)
        text = escapeSpoiler(text);
      if (escape)
        text = escapeEscape(text);
      if (heading)
        text = escapeHeading(text);
      if (bulletedList)
        text = escapeBulletedList(text);
      if (numberedList)
        text = escapeNumberedList(text);
      if (maskedLink)
        text = escapeMaskedLink(text);
      return text;
    }
    function escapeCodeBlock(text) {
      return text.replaceAll("```", "\\`\\`\\`");
    }
    function escapeInlineCode(text) {
      return text.replace(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
    }
    function escapeItalic(text) {
      let i = 0;
      text = text.replace(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
        if (match === "**")
          return ++i % 2 ? `\\*${match}` : `${match}\\*`;
        return `\\*${match}`;
      });
      i = 0;
      return text.replace(/(?<=^|[^_])_([^_]|__|$)/g, (_, match) => {
        if (match === "__")
          return ++i % 2 ? `\\_${match}` : `${match}\\_`;
        return `\\_${match}`;
      });
    }
    function escapeBold(text) {
      let i = 0;
      return text.replace(/\*\*(\*)?/g, (_, match) => {
        if (match)
          return ++i % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
        return "\\*\\*";
      });
    }
    function escapeUnderline(text) {
      let i = 0;
      return text.replace(/__(_)?/g, (_, match) => {
        if (match)
          return ++i % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
        return "\\_\\_";
      });
    }
    function escapeStrikethrough(text) {
      return text.replaceAll("~~", "\\~\\~");
    }
    function escapeSpoiler(text) {
      return text.replaceAll("||", "\\|\\|");
    }
    function escapeEscape(text) {
      return text.replaceAll("\\", "\\\\");
    }
    function escapeHeading(text) {
      return text.replaceAll(/^( {0,2}[*-] +)?(#{1,3} )/gm, "$1\\$2");
    }
    function escapeBulletedList(text) {
      return text.replaceAll(/^( *)[*-]( +)/gm, "$1\\-$2");
    }
    function escapeNumberedList(text) {
      return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
    }
    function escapeMaskedLink(text) {
      return text.replaceAll(/\[.+\]\(.+\)/gm, "\\$&");
    }
    async function fetchRecommendedShardCount(token, { guildsPerShard = 1e3, multipleOf = 1 } = {}) {
      if (!token)
        throw new DiscordjsError2(ErrorCodes2.TokenMissing);
      const response = await fetch(RouteBases.api + Routes3.gatewayBot(), {
        method: "GET",
        headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
      });
      if (!response.ok) {
        if (response.status === 401)
          throw new DiscordjsError2(ErrorCodes2.TokenInvalid);
        throw response;
      }
      const { shards } = await response.json();
      return Math.ceil(shards * (1e3 / guildsPerShard) / multipleOf) * multipleOf;
    }
    function parseEmoji(text) {
      if (text.includes("%"))
        text = decodeURIComponent(text);
      if (!text.includes(":"))
        return { animated: false, name: text, id: void 0 };
      const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
      return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
    }
    function resolvePartialEmoji(emoji) {
      if (!emoji)
        return null;
      if (typeof emoji === "string")
        return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
      const { id, name, animated } = emoji;
      if (!id && !name)
        return null;
      return { id, name, animated: Boolean(animated) };
    }
    function mergeDefault(def, given) {
      if (!given)
        return def;
      for (const key in def) {
        if (!Object.hasOwn(given, key) || given[key] === void 0) {
          given[key] = def[key];
        } else if (given[key] === Object(given[key])) {
          given[key] = mergeDefault(def[key], given[key]);
        }
      }
      return given;
    }
    function makeError(obj) {
      const err = new Error(obj.message);
      err.name = obj.name;
      err.stack = obj.stack;
      return err;
    }
    function makePlainError(err) {
      return {
        name: err.name,
        message: err.message,
        stack: err.stack
      };
    }
    function moveElementInArray(array, element, newIndex, offset = false) {
      const index = array.indexOf(element);
      newIndex = (offset ? index : 0) + newIndex;
      if (newIndex > -1 && newIndex < array.length) {
        const removedElement = array.splice(index, 1)[0];
        array.splice(newIndex, 0, removedElement);
      }
      return array.indexOf(element);
    }
    function verifyString(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
      if (typeof data !== "string")
        throw new error(errorMessage);
      if (!allowEmpty && data.length === 0)
        throw new error(errorMessage);
      return data;
    }
    function resolveColor(color) {
      if (typeof color === "string") {
        if (color === "Random")
          return Math.floor(Math.random() * (16777215 + 1));
        if (color === "Default")
          return 0;
        color = Colors[color] ?? parseInt(color.replace("#", ""), 16);
      } else if (Array.isArray(color)) {
        color = (color[0] << 16) + (color[1] << 8) + color[2];
      }
      if (color < 0 || color > 16777215)
        throw new DiscordjsRangeError2(ErrorCodes2.ColorRange);
      else if (Number.isNaN(color))
        throw new DiscordjsTypeError2(ErrorCodes2.ColorConvert);
      return color;
    }
    function discordSort(collection) {
      const isGuildChannel = collection.first() instanceof GuildChannel;
      return collection.sorted(
        isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id))
      );
    }
    async function setPosition(item, position, relative, sorted, client, route, reason) {
      let updatedItems = [...sorted.values()];
      moveElementInArray(updatedItems, item, position, relative);
      updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
      await client.rest.patch(route, { body: updatedItems, reason });
      return updatedItems;
    }
    function basename(path, ext) {
      const res = parse2(path);
      return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
    }
    function cleanContent(str, channel) {
      return str.replaceAll(/<(@[!&]?|#)(\d{17,19})>/g, (match, type, id) => {
        var _a;
        switch (type) {
          case "@":
          case "@!": {
            const member = (_a = channel.guild) == null ? void 0 : _a.members.cache.get(id);
            if (member) {
              return `@${member.displayName}`;
            }
            const user = channel.client.users.cache.get(id);
            return user ? `@${user.username}` : match;
          }
          case "@&": {
            if (channel.type === ChannelType.DM)
              return match;
            const role = channel.guild.roles.cache.get(id);
            return role ? `@${role.name}` : match;
          }
          case "#": {
            const mentionedChannel = channel.client.channels.cache.get(id);
            return mentionedChannel ? `#${mentionedChannel.name}` : match;
          }
          default: {
            return match;
          }
        }
      });
    }
    function cleanCodeBlockContent(text) {
      return text.replaceAll("```", "`\u200B``");
    }
    function parseWebhookURL(url) {
      const matches = url.match(
        /https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i
      );
      if (!matches || matches.length <= 2)
        return null;
      const [, id, token] = matches;
      return {
        id,
        token
      };
    }
    module2.exports = {
      flatten,
      escapeMarkdown,
      escapeCodeBlock,
      escapeInlineCode,
      escapeItalic,
      escapeBold,
      escapeUnderline,
      escapeStrikethrough,
      escapeSpoiler,
      fetchRecommendedShardCount,
      parseEmoji,
      resolvePartialEmoji,
      mergeDefault,
      makeError,
      makePlainError,
      moveElementInArray,
      verifyString,
      resolveColor,
      discordSort,
      setPosition,
      basename,
      cleanContent,
      cleanCodeBlockContent,
      parseWebhookURL
    };
    var GuildChannel = require_GuildChannel();
  }
});

// ../../node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS({
  "../../node_modules/discord.js/src/client/BaseClient.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var { REST: REST2 } = require_dist5();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Options2 = require_Options();
    var { mergeDefault, flatten } = require_Util();
    var BaseClient2 = class extends EventEmitter {
      constructor(options = {}) {
        super({ captureRejections: true });
        if (typeof options !== "object" || options === null) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        }
        this.options = mergeDefault(Options2.createDefault(), options);
        this.rest = new REST2(this.options.rest);
      }
      destroy() {
        this.rest.requestManager.clearHashSweeper();
        this.rest.requestManager.clearHandlerSweeper();
      }
      incrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners + 1);
        }
      }
      decrementMaxListeners() {
        const maxListeners = this.getMaxListeners();
        if (maxListeners !== 0) {
          this.setMaxListeners(maxListeners - 1);
        }
      }
      toJSON(...props) {
        return flatten(this, ...props);
      }
    };
    module2.exports = BaseClient2;
  }
});

// ../../node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS({
  "../../node_modules/discord.js/src/util/Enums.js"(exports2, module2) {
    "use strict";
    function createEnum(keys) {
      const obj = {};
      for (const [index, key] of keys.entries()) {
        if (key === null)
          continue;
        obj[key] = index;
        obj[index] = key;
      }
      return obj;
    }
    module2.exports = { createEnum };
  }
});

// ../../node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS({
  "../../node_modules/discord.js/src/util/Partials.js"(exports2, module2) {
    "use strict";
    var { createEnum } = require_Enums();
    module2.exports = createEnum([
      "User",
      "Channel",
      "GuildMember",
      "Message",
      "Reaction",
      "GuildScheduledEvent",
      "ThreadMember"
    ]);
  }
});

// ../../node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS({
  "../../node_modules/discord.js/src/client/actions/Action.js"(exports2, module2) {
    "use strict";
    var Partials = require_Partials();
    var GenericAction = class {
      constructor(client) {
        this.client = client;
      }
      handle(data) {
        return data;
      }
      getPayload(data, manager, id, partialType, cache) {
        const existing = manager.cache.get(id);
        if (!existing && this.client.options.partials.includes(partialType)) {
          return manager._add(data, cache);
        }
        return existing;
      }
      getChannel(data) {
        const id = data.channel_id ?? data.id;
        return data.channel ?? this.getPayload(
          {
            id,
            guild_id: data.guild_id,
            recipients: [data.author ?? data.user ?? { id: data.user_id }]
          },
          this.client.channels,
          id,
          Partials.Channel
        );
      }
      getMessage(data, channel, cache) {
        var _a;
        const id = data.message_id ?? data.id;
        return data.message ?? this.getPayload(
          {
            id,
            channel_id: channel.id,
            guild_id: data.guild_id ?? ((_a = channel.guild) == null ? void 0 : _a.id)
          },
          channel.messages,
          id,
          Partials.Message,
          cache
        );
      }
      getReaction(data, message, user) {
        const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
        return this.getPayload(
          {
            emoji: data.emoji,
            count: message.partial ? null : 0,
            me: (user == null ? void 0 : user.id) === this.client.user.id
          },
          message.reactions,
          id,
          Partials.Reaction
        );
      }
      getMember(data, guild) {
        return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
      }
      getUser(data) {
        const id = data.user_id;
        return data.user ?? this.getPayload({ id }, this.client.users, id, Partials.User);
      }
      getUserFromMember(data) {
        var _a;
        if (data.guild_id && ((_a = data.member) == null ? void 0 : _a.user)) {
          const guild = this.client.guilds.cache.get(data.guild_id);
          if (guild) {
            return guild.members._add(data.member).user;
          } else {
            return this.client.users._add(data.member.user);
          }
        }
        return this.getUser(data);
      }
      getScheduledEvent(data, guild) {
        const id = data.guild_scheduled_event_id ?? data.id;
        return this.getPayload(
          { id, guild_id: data.guild_id ?? guild.id },
          guild.scheduledEvents,
          id,
          Partials.GuildScheduledEvent
        );
      }
      getThreadMember(id, manager) {
        return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
      }
    };
    module2.exports = GenericAction;
  }
});

// ../../node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS({
  "../../node_modules/discord.js/src/util/Events.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
      CacheSweep: "cacheSweep",
      ChannelCreate: "channelCreate",
      ChannelDelete: "channelDelete",
      ChannelPinsUpdate: "channelPinsUpdate",
      ChannelUpdate: "channelUpdate",
      ClientReady: "ready",
      Debug: "debug",
      Error: "error",
      GuildBanAdd: "guildBanAdd",
      GuildBanRemove: "guildBanRemove",
      GuildCreate: "guildCreate",
      GuildDelete: "guildDelete",
      GuildEmojiCreate: "emojiCreate",
      GuildEmojiDelete: "emojiDelete",
      GuildEmojiUpdate: "emojiUpdate",
      GuildIntegrationsUpdate: "guildIntegrationsUpdate",
      GuildMemberAdd: "guildMemberAdd",
      GuildMemberAvailable: "guildMemberAvailable",
      GuildMemberRemove: "guildMemberRemove",
      GuildMembersChunk: "guildMembersChunk",
      GuildMemberUpdate: "guildMemberUpdate",
      GuildRoleCreate: "roleCreate",
      GuildRoleDelete: "roleDelete",
      GuildRoleUpdate: "roleUpdate",
      GuildScheduledEventCreate: "guildScheduledEventCreate",
      GuildScheduledEventDelete: "guildScheduledEventDelete",
      GuildScheduledEventUpdate: "guildScheduledEventUpdate",
      GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
      GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
      GuildStickerCreate: "stickerCreate",
      GuildStickerDelete: "stickerDelete",
      GuildStickerUpdate: "stickerUpdate",
      GuildUnavailable: "guildUnavailable",
      GuildUpdate: "guildUpdate",
      InteractionCreate: "interactionCreate",
      Invalidated: "invalidated",
      InviteCreate: "inviteCreate",
      InviteDelete: "inviteDelete",
      MessageBulkDelete: "messageDeleteBulk",
      MessageCreate: "messageCreate",
      MessageDelete: "messageDelete",
      MessageReactionAdd: "messageReactionAdd",
      MessageReactionRemove: "messageReactionRemove",
      MessageReactionRemoveAll: "messageReactionRemoveAll",
      MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
      MessageUpdate: "messageUpdate",
      PresenceUpdate: "presenceUpdate",
      Raw: "raw",
      ShardDisconnect: "shardDisconnect",
      ShardError: "shardError",
      ShardReady: "shardReady",
      ShardReconnecting: "shardReconnecting",
      ShardResume: "shardResume",
      StageInstanceCreate: "stageInstanceCreate",
      StageInstanceDelete: "stageInstanceDelete",
      StageInstanceUpdate: "stageInstanceUpdate",
      ThreadCreate: "threadCreate",
      ThreadDelete: "threadDelete",
      ThreadListSync: "threadListSync",
      ThreadMembersUpdate: "threadMembersUpdate",
      ThreadMemberUpdate: "threadMemberUpdate",
      ThreadUpdate: "threadUpdate",
      TypingStart: "typingStart",
      UserUpdate: "userUpdate",
      VoiceServerUpdate: "voiceServerUpdate",
      VoiceStateUpdate: "voiceStateUpdate",
      Warn: "warn",
      WebhooksUpdate: "webhookUpdate"
    };
  }
});

// ../../node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ApplicationCommandPermissionsUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        client.emit(Events3.ApplicationCommandPermissionsUpdate, {
          permissions: data.permissions,
          id: data.id,
          guildId: data.guild_id,
          applicationId: data.application_id
        });
      }
    };
    module2.exports = ApplicationCommandPermissionsUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ChannelCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ChannelCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const channel = client.channels._add(data);
        if (!existing && channel) {
          client.emit(Events3.ChannelCreate, channel);
        }
        return { channel };
      }
    };
    module2.exports = ChannelCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ChannelDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ChannelDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.id);
        if (channel) {
          client.channels._remove(channel.id);
          client.emit(Events3.ChannelDelete, channel);
        }
      }
    };
    module2.exports = ChannelDeleteAction;
  }
});

// ../../node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS({
  "../../node_modules/discord.js/src/managers/CategoryChannelChildManager.js"(exports2, module2) {
    "use strict";
    var DataManager = require_DataManager();
    var GuildChannel = require_GuildChannel();
    var CategoryChannelChildManager = class extends DataManager {
      constructor(channel) {
        super(channel.client, GuildChannel);
        this.channel = channel;
      }
      get cache() {
        return this.guild.channels.cache.filter((c) => c.parentId === this.channel.id);
      }
      get guild() {
        return this.channel.guild;
      }
      create(options) {
        return this.guild.channels.create({
          ...options,
          parent: this.channel.id
        });
      }
    };
    module2.exports = CategoryChannelChildManager;
  }
});

// ../../node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/CategoryChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var CategoryChannelChildManager = require_CategoryChannelChildManager();
    var CategoryChannel = class extends GuildChannel {
      get children() {
        return new CategoryChannelChildManager(this);
      }
    };
    module2.exports = CategoryChannel;
  }
});

// ../../node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS({
  "../../node_modules/discord.js/src/structures/interfaces/Collector.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("timers");
    var { Collection: Collection2 } = require_dist();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { flatten } = require_Util();
    var Collector = class extends EventEmitter {
      constructor(client, options = {}) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.filter = options.filter ?? (() => true);
        this.options = options;
        this.collected = new Collection2();
        this.ended = false;
        this._timeout = null;
        this._idletimeout = null;
        this._endReason = null;
        if (typeof this.filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options.filter", "function");
        }
        this.handleCollect = this.handleCollect.bind(this);
        this.handleDispose = this.handleDispose.bind(this);
        if (options.time)
          this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
        if (options.idle)
          this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      }
      async handleCollect(...args) {
        const collectedId = await this.collect(...args);
        if (collectedId) {
          const filterResult = await this.filter(...args, this.collected);
          if (filterResult) {
            this.collected.set(collectedId, args[0]);
            this.emit("collect", ...args);
            if (this._idletimeout) {
              clearTimeout2(this._idletimeout);
              this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
            }
          } else {
            this.emit("ignore", ...args);
          }
        }
        this.checkEnd();
      }
      async handleDispose(...args) {
        if (!this.options.dispose)
          return;
        const dispose = this.dispose(...args);
        if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
          return;
        this.collected.delete(dispose);
        this.emit("dispose", ...args);
        this.checkEnd();
      }
      get next() {
        return new Promise((resolve, reject) => {
          if (this.ended) {
            reject(this.collected);
            return;
          }
          const cleanup = () => {
            this.removeListener("collect", onCollect);
            this.removeListener("end", onEnd);
          };
          const onCollect = (item) => {
            cleanup();
            resolve(item);
          };
          const onEnd = () => {
            cleanup();
            reject(this.collected);
          };
          this.on("collect", onCollect);
          this.on("end", onEnd);
        });
      }
      stop(reason = "user") {
        if (this.ended)
          return;
        if (this._timeout) {
          clearTimeout2(this._timeout);
          this._timeout = null;
        }
        if (this._idletimeout) {
          clearTimeout2(this._idletimeout);
          this._idletimeout = null;
        }
        this._endReason = reason;
        this.ended = true;
        this.emit("end", this.collected, reason);
      }
      resetTimer({ time, idle } = {}) {
        if (this._timeout) {
          clearTimeout2(this._timeout);
          this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
        }
        if (this._idletimeout) {
          clearTimeout2(this._idletimeout);
          this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
        }
      }
      checkEnd() {
        const reason = this.endReason;
        if (reason)
          this.stop(reason);
        return Boolean(reason);
      }
      async *[Symbol.asyncIterator]() {
        const queue = [];
        const onCollect = (...item) => queue.push(item);
        this.on("collect", onCollect);
        try {
          while (queue.length || !this.ended) {
            if (queue.length) {
              yield queue.shift();
            } else {
              await new Promise((resolve) => {
                const tick = () => {
                  this.removeListener("collect", tick);
                  this.removeListener("end", tick);
                  return resolve();
                };
                this.on("collect", tick);
                this.on("end", tick);
              });
            }
          }
        } finally {
          this.removeListener("collect", onCollect);
        }
      }
      toJSON() {
        return flatten(this);
      }
      get endReason() {
        return this._endReason;
      }
      collect() {
      }
      dispose() {
      }
    };
    module2.exports = Collector;
  }
});

// ../../node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS({
  "../../node_modules/discord.js/src/structures/InteractionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Collector = require_Collector();
    var Events3 = require_Events();
    var InteractionCollector = class extends Collector {
      constructor(client, options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        super(client, options);
        this.messageId = ((_a = options.message) == null ? void 0 : _a.id) ?? null;
        this.messageInteractionId = ((_b = options.interactionResponse) == null ? void 0 : _b.id) ?? null;
        this.channelId = ((_c = options.interactionResponse) == null ? void 0 : _c.interaction.channelId) ?? ((_d = options.message) == null ? void 0 : _d.channelId) ?? ((_e = options.message) == null ? void 0 : _e.channel_id) ?? this.client.channels.resolveId(options.channel);
        this.guildId = ((_f = options.interactionResponse) == null ? void 0 : _f.interaction.guildId) ?? ((_g = options.message) == null ? void 0 : _g.guildId) ?? ((_h = options.message) == null ? void 0 : _h.guild_id) ?? this.client.guilds.resolveId((_i = options.channel) == null ? void 0 : _i.guild) ?? this.client.guilds.resolveId(options.guild);
        this.interactionType = options.interactionType ?? null;
        this.componentType = options.componentType ?? null;
        this.users = new Collection2();
        this.total = 0;
        this.client.incrementMaxListeners();
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.messageId))
            this.stop("messageDelete");
        };
        if (this.messageId || this.messageInteractionId) {
          this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
          this.client.on(Events3.MessageDelete, this._handleMessageDeletion);
          this.client.on(Events3.MessageBulkDelete, bulkDeleteListener);
        }
        if (this.channelId) {
          this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
          this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
          this.client.on(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.on(Events3.ThreadDelete, this._handleThreadDeletion);
        }
        if (this.guildId) {
          this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
          this.client.on(Events3.GuildDelete, this._handleGuildDeletion);
        }
        this.client.on(Events3.InteractionCreate, this.handleCollect);
        this.once("end", () => {
          this.client.removeListener(Events3.InteractionCreate, this.handleCollect);
          this.client.removeListener(Events3.MessageDelete, this._handleMessageDeletion);
          this.client.removeListener(Events3.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events3.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events3.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (interaction) => {
          this.total++;
          this.users.set(interaction.user.id, interaction.user);
        });
      }
      collect(interaction) {
        var _a, _b, _c;
        if (this.interactionType && interaction.type !== this.interactionType)
          return null;
        if (this.componentType && interaction.componentType !== this.componentType)
          return null;
        if (this.messageId && ((_a = interaction.message) == null ? void 0 : _a.id) !== this.messageId)
          return null;
        if (this.messageInteractionId && ((_c = (_b = interaction.message) == null ? void 0 : _b.interaction) == null ? void 0 : _c.id) !== this.messageInteractionId)
          return null;
        if (this.channelId && interaction.channelId !== this.channelId)
          return null;
        if (this.guildId && interaction.guildId !== this.guildId)
          return null;
        return interaction.id;
      }
      dispose(interaction) {
        var _a, _b, _c;
        if (this.type && interaction.type !== this.type)
          return null;
        if (this.componentType && interaction.componentType !== this.componentType)
          return null;
        if (this.messageId && ((_a = interaction.message) == null ? void 0 : _a.id) !== this.messageId)
          return null;
        if (this.messageInteractionId && ((_c = (_b = interaction.message) == null ? void 0 : _b.interaction) == null ? void 0 : _c.id) !== this.messageInteractionId)
          return null;
        if (this.channelId && interaction.channelId !== this.channelId)
          return null;
        if (this.guildId && interaction.guildId !== this.guildId)
          return null;
        return interaction.id;
      }
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      get endReason() {
        if (this.options.max && this.total >= this.options.max)
          return "limit";
        if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
          return "componentLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
          return "userLimit";
        return super.endReason;
      }
      _handleMessageDeletion(message) {
        var _a;
        if (message.id === this.messageId) {
          this.stop("messageDelete");
        }
        if (((_a = message.interaction) == null ? void 0 : _a.id) === this.messageInteractionId) {
          this.stop("messageDelete");
        }
      }
      _handleChannelDeletion(channel) {
        var _a;
        if (channel.id === this.channelId || ((_a = channel.threads) == null ? void 0 : _a.cache.has(this.channelId))) {
          this.stop("channelDelete");
        }
      }
      _handleThreadDeletion(thread) {
        if (thread.id === this.channelId) {
          this.stop("threadDelete");
        }
      }
      _handleGuildDeletion(guild) {
        if (guild.id === this.guildId) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = InteractionCollector;
  }
});

// ../../node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS({
  "../../node_modules/discord.js/src/structures/MessageCollector.js"(exports2, module2) {
    "use strict";
    var Collector = require_Collector();
    var Events3 = require_Events();
    var MessageCollector = class extends Collector {
      constructor(channel, options = {}) {
        super(channel.client, options);
        this.channel = channel;
        this.received = 0;
        const bulkDeleteListener = (messages) => {
          for (const message of messages.values())
            this.handleDispose(message);
        };
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.incrementMaxListeners();
        this.client.on(Events3.MessageCreate, this.handleCollect);
        this.client.on(Events3.MessageDelete, this.handleDispose);
        this.client.on(Events3.MessageBulkDelete, bulkDeleteListener);
        this.client.on(Events3.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events3.ThreadDelete, this._handleThreadDeletion);
        this.client.on(Events3.GuildDelete, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events3.MessageCreate, this.handleCollect);
          this.client.removeListener(Events3.MessageDelete, this.handleDispose);
          this.client.removeListener(Events3.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events3.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events3.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
      }
      collect(message) {
        if (message.channelId !== this.channel.id)
          return null;
        this.received++;
        return message.id;
      }
      dispose(message) {
        return message.channelId === this.channel.id ? message.id : null;
      }
      get endReason() {
        if (this.options.max && this.collected.size >= this.options.max)
          return "limit";
        if (this.options.maxProcessed && this.received === this.options.maxProcessed)
          return "processedLimit";
        return super.endReason;
      }
      _handleChannelDeletion(channel) {
        if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
          this.stop("channelDelete");
        }
      }
      _handleThreadDeletion(thread) {
        if (thread.id === this.channel.id) {
          this.stop("threadDelete");
        }
      }
      _handleGuildDeletion(guild) {
        var _a;
        if (guild.id === ((_a = this.channel.guild) == null ? void 0 : _a.id)) {
          this.stop("guildDelete");
        }
      }
    };
    module2.exports = MessageCollector;
  }
});

// ../../node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS({
  "../../node_modules/discord.js/src/structures/Component.js"(exports2, module2) {
    "use strict";
    var isEqual = require_fast_deep_equal();
    var Component = class {
      constructor(data) {
        this.data = data;
      }
      get type() {
        return this.data.type;
      }
      equals(other) {
        if (other instanceof Component) {
          return isEqual(other.data, this.data);
        }
        return isEqual(other, this.data);
      }
      toJSON() {
        return { ...this.data };
      }
    };
    module2.exports = Component;
  }
});

// ../../node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS({
  "../../node_modules/discord.js/src/structures/ActionRow.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require("util");
    var { isJSONEncodable } = require_dist7();
    var Component = require_Component();
    var { createComponent } = require_Components();
    var ActionRow = class extends Component {
      constructor({ components, ...data }) {
        super(data);
        this.components = components.map((c) => createComponent(c));
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
      toJSON() {
        return { ...this.data, components: this.components.map((c) => c.toJSON()) };
      }
    };
    ActionRow.from = deprecate(ActionRow.from, "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead.");
    module2.exports = ActionRow;
  }
});

// ../../node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/ButtonBuilder.js"(exports2, module2) {
    "use strict";
    var { ButtonBuilder: BuildersButton, isJSONEncodable } = require_dist7();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var ButtonBuilder = class extends BuildersButton {
      constructor({ emoji, ...data } = {}) {
        super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
      }
      setEmoji(emoji) {
        if (typeof emoji === "string") {
          return super.setEmoji(resolvePartialEmoji(emoji));
        }
        return super.setEmoji(emoji);
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ButtonBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS({
  "../../node_modules/discord.js/src/structures/ButtonComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var ButtonComponent = class extends Component {
      get style() {
        return this.data.style;
      }
      get label() {
        return this.data.label ?? null;
      }
      get emoji() {
        return this.data.emoji ?? null;
      }
      get disabled() {
        return this.data.disabled ?? null;
      }
      get customId() {
        return this.data.custom_id ?? null;
      }
      get url() {
        return this.data.url ?? null;
      }
    };
    module2.exports = ButtonComponent;
  }
});

// ../../node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/SelectMenuBuilder.js"(exports2, module2) {
    "use strict";
    var { SelectMenuBuilder: BuildersSelectMenu, isJSONEncodable, normalizeArray } = require_dist7();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var SelectMenuBuilder = class extends BuildersSelectMenu {
      constructor({ options, ...data } = {}) {
        super(
          toSnakeCase({
            ...data,
            options: options == null ? void 0 : options.map(({ emoji, ...option }) => ({
              ...option,
              emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
            }))
          })
        );
      }
      static normalizeEmoji(selectMenuOption) {
        if (isJSONEncodable(selectMenuOption)) {
          return selectMenuOption;
        }
        const { emoji, ...option } = selectMenuOption;
        return {
          ...option,
          emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        };
      }
      addOptions(...options) {
        return super.addOptions(normalizeArray(options).map((option) => SelectMenuBuilder.normalizeEmoji(option)));
      }
      setOptions(...options) {
        return super.setOptions(normalizeArray(options).map((option) => SelectMenuBuilder.normalizeEmoji(option)));
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = SelectMenuBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS({
  "../../node_modules/discord.js/src/structures/SelectMenuComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var SelectMenuComponent = class extends Component {
      get placeholder() {
        return this.data.placeholder ?? null;
      }
      get maxValues() {
        return this.data.max_values ?? null;
      }
      get minValues() {
        return this.data.min_values ?? null;
      }
      get customId() {
        return this.data.custom_id;
      }
      get disabled() {
        return this.data.disabled ?? null;
      }
      get options() {
        return this.data.options;
      }
    };
    module2.exports = SelectMenuComponent;
  }
});

// ../../node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/TextInputBuilder.js"(exports2, module2) {
    "use strict";
    var { TextInputBuilder: BuildersTextInput, isJSONEncodable } = require_dist7();
    var { toSnakeCase } = require_Transformers();
    var TextInputBuilder = class extends BuildersTextInput {
      constructor(data) {
        super(toSnakeCase(data));
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = TextInputBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS({
  "../../node_modules/discord.js/src/structures/TextInputComponent.js"(exports2, module2) {
    "use strict";
    var Component = require_Component();
    var TextInputComponent = class extends Component {
      get customId() {
        return this.data.custom_id;
      }
      get value() {
        return this.data.value;
      }
    };
    module2.exports = TextInputComponent;
  }
});

// ../../node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS({
  "../../node_modules/discord.js/src/util/Components.js"(exports2, module2) {
    "use strict";
    var { ComponentBuilder } = require_dist7();
    var { ComponentType } = require_v106();
    function createComponent(data) {
      if (data instanceof Component) {
        return data;
      }
      switch (data.type) {
        case ComponentType.ActionRow:
          return new ActionRow(data);
        case ComponentType.Button:
          return new ButtonComponent(data);
        case ComponentType.SelectMenu:
          return new SelectMenuComponent(data);
        case ComponentType.TextInput:
          return new TextInputComponent(data);
        default:
          return new Component(data);
      }
    }
    function createComponentBuilder(data) {
      if (data instanceof ComponentBuilder) {
        return data;
      }
      switch (data.type) {
        case ComponentType.ActionRow:
          return new ActionRowBuilder(data);
        case ComponentType.Button:
          return new ButtonBuilder(data);
        case ComponentType.SelectMenu:
          return new SelectMenuBuilder(data);
        case ComponentType.TextInput:
          return new TextInputBuilder(data);
        default:
          return new ComponentBuilder(data);
      }
    }
    module2.exports = { createComponent, createComponentBuilder };
    var ActionRow = require_ActionRow();
    var ActionRowBuilder = require_ActionRowBuilder();
    var ButtonBuilder = require_ButtonBuilder();
    var ButtonComponent = require_ButtonComponent();
    var Component = require_Component();
    var SelectMenuBuilder = require_SelectMenuBuilder();
    var SelectMenuComponent = require_SelectMenuComponent();
    var TextInputBuilder = require_TextInputBuilder();
    var TextInputComponent = require_TextInputComponent();
  }
});

// ../../node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/ActionRowBuilder.js"(exports2, module2) {
    "use strict";
    var { ActionRowBuilder: BuildersActionRow, isJSONEncodable } = require_dist7();
    var { createComponentBuilder } = require_Components();
    var { toSnakeCase } = require_Transformers();
    var ActionRowBuilder = class extends BuildersActionRow {
      constructor({ components, ...data } = {}) {
        super({
          ...toSnakeCase(data),
          components: components == null ? void 0 : components.map((c) => createComponentBuilder(c))
        });
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ActionRowBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildScheduledEvent.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildScheduledEvent = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.guildId = data.guild_id;
        this._patch(data);
      }
      _patch(data) {
        var _a;
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ?? (this.channelId = null);
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        } else {
          this.creatorId ?? (this.creatorId = null);
        }
        this.name = data.name;
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        this.scheduledStartTimestamp = data.scheduled_start_time ? Date.parse(data.scheduled_start_time) : null;
        this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
        this.privacyLevel = data.privacy_level;
        this.status = data.status;
        this.entityType = data.entity_type;
        if ("entity_id" in data) {
          this.entityId = data.entity_id;
        } else {
          this.entityId ?? (this.entityId = null);
        }
        if ("user_count" in data) {
          this.userCount = data.user_count;
        } else {
          this.userCount ?? (this.userCount = null);
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        } else {
          this.creator ?? (this.creator = this.client.users.resolve(this.creatorId));
        }
        if ("entity_metadata" in data) {
          if (data.entity_metadata) {
            this.entityMetadata = {
              location: data.entity_metadata.location ?? ((_a = this.entityMetadata) == null ? void 0 : _a.location) ?? null
            };
          } else {
            this.entityMetadata = null;
          }
        } else {
          this.entityMetadata ?? (this.entityMetadata = null);
        }
        if ("image" in data) {
          this.image = data.image;
        } else {
          this.image ?? (this.image = null);
        }
      }
      coverImageURL(options = {}) {
        return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get scheduledStartAt() {
        return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
      }
      get scheduledEndAt() {
        return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
      }
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      get url() {
        return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
      }
      async createInviteURL(options) {
        let channelId = this.channelId;
        if (this.entityType === GuildScheduledEventEntityType.External) {
          if (!(options == null ? void 0 : options.channel))
            throw new DiscordjsError2(ErrorCodes2.InviteOptionsMissingChannel);
          channelId = this.guild.channels.resolveId(options.channel);
          if (!channelId)
            throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        }
        const invite = await this.guild.invites.create(channelId, options);
        return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
      }
      edit(options) {
        return this.guild.scheduledEvents.edit(this.id, options);
      }
      async delete() {
        await this.guild.scheduledEvents.delete(this.id);
        return this;
      }
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      setScheduledStartTime(scheduledStartTime, reason) {
        return this.edit({ scheduledStartTime, reason });
      }
      setScheduledEndTime(scheduledEndTime, reason) {
        return this.edit({ scheduledEndTime, reason });
      }
      setDescription(description, reason) {
        return this.edit({ description, reason });
      }
      setStatus(status, reason) {
        return this.edit({ status, reason });
      }
      setLocation(location, reason) {
        return this.edit({ entityMetadata: { location }, reason });
      }
      fetchSubscribers(options) {
        return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
      }
      toString() {
        return this.url;
      }
      isActive() {
        return this.status === GuildScheduledEventStatus.Active;
      }
      isCanceled() {
        return this.status === GuildScheduledEventStatus.Canceled;
      }
      isCompleted() {
        return this.status === GuildScheduledEventStatus.Completed;
      }
      isScheduled() {
        return this.status === GuildScheduledEventStatus.Scheduled;
      }
    };
    exports2.GuildScheduledEvent = GuildScheduledEvent;
  }
});

// ../../node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS({
  "../../node_modules/discord.js/src/structures/interfaces/Application.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var Application = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        } else {
          this.name ?? (this.name = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ?? (this.icon = null);
        }
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
      }
      coverURL(options = {}) {
        return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Application;
  }
});

// ../../node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS({
  "../../node_modules/discord.js/src/structures/IntegrationApplication.js"(exports2, module2) {
    "use strict";
    var Application = require_Application();
    var IntegrationApplication = class extends Application {
      _patch(data) {
        super._patch(data);
        if ("bot" in data) {
          this.bot = this.client.users._add(data.bot);
        } else {
          this.bot ?? (this.bot = null);
        }
        if ("terms_of_service_url" in data) {
          this.termsOfServiceURL = data.terms_of_service_url;
        } else {
          this.termsOfServiceURL ?? (this.termsOfServiceURL = null);
        }
        if ("privacy_policy_url" in data) {
          this.privacyPolicyURL = data.privacy_policy_url;
        } else {
          this.privacyPolicyURL ?? (this.privacyPolicyURL = null);
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ?? (this.rpcOrigins = []);
        }
        if ("hook" in data) {
          this.hook = data.hook;
        } else {
          this.hook ?? (this.hook = null);
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ?? (this.cover = null);
        }
        if ("verify_key" in data) {
          this.verifyKey = data.verify_key;
        } else {
          this.verifyKey ?? (this.verifyKey = null);
        }
      }
    };
    module2.exports = IntegrationApplication;
  }
});

// ../../node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS({
  "../../node_modules/discord.js/src/structures/InviteStageInstance.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Base = require_Base();
    var InviteStageInstance = class extends Base {
      constructor(client, data, channelId, guildId) {
        super(client);
        this.channelId = channelId;
        this.guildId = guildId;
        this.members = new Collection2();
        this._patch(data);
      }
      _patch(data) {
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("participant_count" in data) {
          this.participantCount = data.participant_count;
        }
        if ("speaker_count" in data) {
          this.speakerCount = data.speaker_count;
        }
        this.members.clear();
        for (const rawMember of data.members) {
          const member = this.guild.members._add(rawMember);
          this.members.set(member.id, member);
        }
      }
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
    };
    module2.exports = InviteStageInstance;
  }
});

// ../../node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS({
  "../../node_modules/discord.js/src/structures/BaseGuild.js"(exports2, module2) {
    "use strict";
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes3, GuildFeature } = require_v106();
    var Base = require_Base();
    var BaseGuild = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.name = data.name;
        this.icon = data.icon;
        this.features = data.features;
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get nameAcronym() {
        return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
      }
      get partnered() {
        return this.features.includes(GuildFeature.Partnered);
      }
      get verified() {
        return this.features.includes(GuildFeature.Verified);
      }
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
      }
      async fetch() {
        const data = await this.client.rest.get(Routes3.guild(this.id), {
          query: makeURLSearchParams2({ with_counts: true })
        });
        return this.client.guilds._add(data);
      }
      toString() {
        return this.name;
      }
    };
    module2.exports = BaseGuild;
  }
});

// ../../node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS({
  "../../node_modules/discord.js/src/structures/AnonymousGuild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var AnonymousGuild = class extends BaseGuild {
      constructor(client, data, immediatePatch = true) {
        super(client, data);
        if (immediatePatch)
          this._patch(data);
      }
      _patch(data) {
        if ("features" in data)
          this.features = data.features;
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("banner" in data) {
          this.banner = data.banner;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("verification_level" in data) {
          this.verificationLevel = data.verification_level;
        }
        if ("vanity_url_code" in data) {
          this.vanityURLCode = data.vanity_url_code;
        }
        if ("nsfw_level" in data) {
          this.nsfwLevel = data.nsfw_level;
        }
        if ("premium_subscription_count" in data) {
          this.premiumSubscriptionCount = data.premium_subscription_count;
        } else {
          this.premiumSubscriptionCount ?? (this.premiumSubscriptionCount = null);
        }
      }
      bannerURL(options = {}) {
        return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
      }
      splashURL(options = {}) {
        return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
      }
    };
    module2.exports = AnonymousGuild;
  }
});

// ../../node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS({
  "../../node_modules/discord.js/src/structures/Emoji.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var Emoji = class extends Base {
      constructor(client, emoji) {
        super(client);
        this.animated = emoji.animated ?? null;
        this.name = emoji.name ?? null;
        this.id = emoji.id;
      }
      get identifier() {
        if (this.id)
          return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
        return encodeURIComponent(this.name);
      }
      get url() {
        return this.id && this.client.rest.cdn.emoji(this.id, this.animated ? "gif" : "png");
      }
      get createdTimestamp() {
        return this.id && DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return this.id && new Date(this.createdTimestamp);
      }
      toString() {
        return this.id ? `<${this.animated ? "a" : ""}:${this.name}:${this.id}>` : this.name;
      }
      toJSON() {
        return super.toJSON({
          guild: "guildId",
          createdTimestamp: true,
          url: true,
          identifier: true
        });
      }
    };
    exports2.Emoji = Emoji;
  }
});

// ../../node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/WelcomeChannel.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var WelcomeChannel = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description;
        this._emoji = {
          name: data.emoji_name,
          id: data.emoji_id
        };
        this.channelId = data.channel_id;
      }
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      get emoji() {
        return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
      }
    };
    module2.exports = WelcomeChannel;
  }
});

// ../../node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS({
  "../../node_modules/discord.js/src/structures/WelcomeScreen.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { GuildFeature } = require_v106();
    var Base = require_Base();
    var WelcomeChannel = require_WelcomeChannel();
    var WelcomeScreen = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.description = data.description ?? null;
        this.welcomeChannels = new Collection2();
        for (const channel of data.welcome_channels) {
          const welcomeChannel = new WelcomeChannel(this.guild, channel);
          this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
        }
      }
      get enabled() {
        return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
      }
    };
    module2.exports = WelcomeScreen;
  }
});

// ../../node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS({
  "../../node_modules/discord.js/src/structures/InviteGuild.js"(exports2, module2) {
    "use strict";
    var AnonymousGuild = require_AnonymousGuild();
    var WelcomeScreen = require_WelcomeScreen();
    var InviteGuild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data);
        this.welcomeScreen = typeof data.welcome_screen !== "undefined" ? new WelcomeScreen(this, data.welcome_screen) : null;
      }
    };
    module2.exports = InviteGuild;
  }
});

// ../../node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS({
  "../../node_modules/discord.js/src/structures/Invite.js"(exports2, module2) {
    "use strict";
    var { RouteBases, Routes: Routes3, PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var Base = require_Base();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var IntegrationApplication = require_IntegrationApplication();
    var InviteStageInstance = require_InviteStageInstance();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Invite2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        const InviteGuild = require_InviteGuild();
        this.guild ?? (this.guild = null);
        if (data.guild) {
          this.guild = this.client.guilds.resolve(data.guild.id) ?? new InviteGuild(this.client, data.guild);
        }
        if ("code" in data) {
          this.code = data.code;
        }
        if ("approximate_presence_count" in data) {
          this.presenceCount = data.approximate_presence_count;
        } else {
          this.presenceCount ?? (this.presenceCount = null);
        }
        if ("approximate_member_count" in data) {
          this.memberCount = data.approximate_member_count;
        } else {
          this.memberCount ?? (this.memberCount = null);
        }
        if ("temporary" in data) {
          this.temporary = data.temporary ?? null;
        } else {
          this.temporary ?? (this.temporary = null);
        }
        if ("max_age" in data) {
          this.maxAge = data.max_age;
        } else {
          this.maxAge ?? (this.maxAge = null);
        }
        if ("uses" in data) {
          this.uses = data.uses;
        } else {
          this.uses ?? (this.uses = null);
        }
        if ("max_uses" in data) {
          this.maxUses = data.max_uses;
        } else {
          this.maxUses ?? (this.maxUses = null);
        }
        if ("inviter_id" in data) {
          this.inviterId = data.inviter_id;
        } else {
          this.inviterId ?? (this.inviterId = null);
        }
        if ("inviter" in data) {
          this.client.users._add(data.inviter);
          this.inviterId = data.inviter.id;
        }
        if ("target_user" in data) {
          this.targetUser = this.client.users._add(data.target_user);
        } else {
          this.targetUser ?? (this.targetUser = null);
        }
        if ("target_application" in data) {
          this.targetApplication = new IntegrationApplication(this.client, data.target_application);
        } else {
          this.targetApplication ?? (this.targetApplication = null);
        }
        if ("target_type" in data) {
          this.targetType = data.target_type;
        } else {
          this.targetType ?? (this.targetType = null);
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("channel" in data) {
          this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
          this.channelId ?? (this.channelId = data.channel.id);
        }
        if ("created_at" in data) {
          this.createdTimestamp = Date.parse(data.created_at);
        } else {
          this.createdTimestamp ?? (this.createdTimestamp = null);
        }
        if ("expires_at" in data) {
          this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
        } else {
          this._expiresTimestamp ?? (this._expiresTimestamp = null);
        }
        if ("stage_instance" in data) {
          this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
        } else {
          this.stageInstance ?? (this.stageInstance = null);
        }
        if ("guild_scheduled_event" in data) {
          this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
        } else {
          this.guildScheduledEvent ?? (this.guildScheduledEvent = null);
        }
      }
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      get deletable() {
        var _a;
        const guild = this.guild;
        if (!guild || !this.client.guilds.cache.has(guild.id))
          return false;
        if (!guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return Boolean(
          ((_a = this.channel) == null ? void 0 : _a.permissionsFor(this.client.user).has(PermissionFlagsBits4.ManageChannels, false)) || guild.members.me.permissions.has(PermissionFlagsBits4.ManageGuild)
        );
      }
      get expiresTimestamp() {
        return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1e3 : null);
      }
      get expiresAt() {
        return this.expiresTimestamp && new Date(this.expiresTimestamp);
      }
      get inviter() {
        return this.inviterId && this.client.users.resolve(this.inviterId);
      }
      get url() {
        return `${RouteBases.invite}/${this.code}`;
      }
      async delete(reason) {
        await this.client.rest.delete(Routes3.invite(this.code), { reason });
        return this;
      }
      toString() {
        return this.url;
      }
      toJSON() {
        return super.toJSON({
          url: true,
          expiresTimestamp: true,
          presenceCount: false,
          memberCount: false,
          uses: false,
          channel: "channelId",
          inviter: "inviterId",
          guild: "guildId"
        });
      }
      valueOf() {
        return this.code;
      }
    };
    __publicField(Invite2, "InvitesPattern", /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i);
    module2.exports = Invite2;
  }
});

// ../../node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildTemplate.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("timers");
    var { RouteBases, Routes: Routes3 } = require_v106();
    var Base = require_Base();
    var DataResolver2 = require_DataResolver();
    var Events3 = require_Events();
    var GuildTemplate2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        if ("code" in data) {
          this.code = data.code;
        }
        if ("name" in data) {
          this.name = data.name;
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("usage_count" in data) {
          this.usageCount = data.usage_count;
        }
        if ("creator_id" in data) {
          this.creatorId = data.creator_id;
        }
        if ("creator" in data) {
          this.creator = this.client.users._add(data.creator);
        }
        if ("created_at" in data) {
          this.createdTimestamp = Date.parse(data.created_at);
        }
        if ("updated_at" in data) {
          this.updatedTimestamp = Date.parse(data.updated_at);
        }
        if ("source_guild_id" in data) {
          this.guildId = data.source_guild_id;
        }
        if ("serialized_source_guild" in data) {
          this.serializedGuild = data.serialized_source_guild;
        }
        this.unSynced = "is_dirty" in data ? Boolean(data.is_dirty) : null;
        return this;
      }
      async createGuild(name, icon) {
        const { client } = this;
        const data = await client.rest.post(Routes3.template(this.code), {
          body: {
            name,
            icon: await DataResolver2.resolveImage(icon)
          }
        });
        if (client.guilds.cache.has(data.id))
          return client.guilds.cache.get(data.id);
        return new Promise((resolve) => {
          const resolveGuild = (guild) => {
            client.off(Events3.GuildCreate, handleGuild);
            client.decrementMaxListeners();
            resolve(guild);
          };
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout2(timeout);
              resolveGuild(guild);
            }
          };
          client.incrementMaxListeners();
          client.on(Events3.GuildCreate, handleGuild);
          const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
        });
      }
      async edit({ name, description } = {}) {
        const data = await this.client.rest.patch(Routes3.guildTemplate(this.guildId, this.code), {
          body: { name, description }
        });
        return this._patch(data);
      }
      async delete() {
        await this.client.rest.delete(Routes3.guildTemplate(this.guildId, this.code));
        return this;
      }
      async sync() {
        const data = await this.client.rest.put(Routes3.guildTemplate(this.guildId, this.code));
        return this._patch(data);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get updatedAt() {
        return new Date(this.updatedTimestamp);
      }
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      get url() {
        return `${RouteBases.template}/${this.code}`;
      }
      toString() {
        return this.code;
      }
    };
    __publicField(GuildTemplate2, "GuildTemplatesPattern", /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i);
    module2.exports = GuildTemplate2;
  }
});

// ../../node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS({
  "../../node_modules/discord.js/src/util/DataResolver.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer5 } = require("buffer");
    var fs2 = require("fs/promises");
    var path = require("path");
    var { fetch } = require_undici();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Invite2 = require_Invite();
    var DataResolver2 = class extends null {
      static resolveCode(data, regex) {
        var _a;
        return ((_a = regex.exec(data)) == null ? void 0 : _a[1]) ?? data;
      }
      static resolveInviteCode(data) {
        return this.resolveCode(data, Invite2.InvitesPattern);
      }
      static resolveGuildTemplateCode(data) {
        const GuildTemplate2 = require_GuildTemplate();
        return this.resolveCode(data, GuildTemplate2.GuildTemplatesPattern);
      }
      static async resolveImage(image) {
        if (!image)
          return null;
        if (typeof image === "string" && image.startsWith("data:")) {
          return image;
        }
        const file = await this.resolveFile(image);
        return this.resolveBase64(file.data);
      }
      static resolveBase64(data) {
        if (Buffer5.isBuffer(data))
          return `data:image/jpg;base64,${data.toString("base64")}`;
        return data;
      }
      static async resolveFile(resource) {
        if (Buffer5.isBuffer(resource))
          return { data: resource };
        if (typeof resource[Symbol.asyncIterator] === "function") {
          const buffers = [];
          for await (const data of resource)
            buffers.push(Buffer5.from(data));
          return { data: Buffer5.concat(buffers) };
        }
        if (typeof resource === "string") {
          if (/^https?:\/\//.test(resource)) {
            const res = await fetch(resource);
            return { data: Buffer5.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
          }
          const file = path.resolve(resource);
          const stats = await fs2.stat(file);
          if (!stats.isFile())
            throw new DiscordjsError2(ErrorCodes2.FileNotFound, file);
          return { data: await fs2.readFile(file) };
        }
        throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
      }
    };
    module2.exports = DataResolver2;
  }
});

// ../../node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/MessageFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { MessageFlags } = require_v106();
    var BitField = require_BitField();
    var MessageFlagsBitField = class extends BitField {
    };
    __publicField(MessageFlagsBitField, "Flags", MessageFlags);
    module2.exports = MessageFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/BaseInteraction.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
    var Base = require_Base();
    var PermissionsBitField5 = require_PermissionsBitField();
    var BaseInteraction = class extends Base {
      constructor(client, data) {
        var _a, _b;
        super(client);
        this.type = data.type;
        this.id = data.id;
        Object.defineProperty(this, "token", { value: data.token });
        this.applicationId = data.application_id;
        this.channelId = data.channel_id ?? null;
        this.guildId = data.guild_id ?? null;
        this.user = this.client.users._add(data.user ?? data.member.user);
        this.member = data.member ? ((_a = this.guild) == null ? void 0 : _a.members._add(data.member)) ?? data.member : null;
        this.version = data.version;
        this.appPermissions = data.app_permissions ? new PermissionsBitField5(data.app_permissions).freeze() : null;
        this.memberPermissions = ((_b = data.member) == null ? void 0 : _b.permissions) ? new PermissionsBitField5(data.member.permissions).freeze() : null;
        this.locale = data.locale;
        this.guildLocale = data.guild_locale ?? null;
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get channel() {
        return this.client.channels.cache.get(this.channelId) ?? null;
      }
      get guild() {
        return this.client.guilds.cache.get(this.guildId) ?? null;
      }
      inGuild() {
        return Boolean(this.guildId && this.member);
      }
      inCachedGuild() {
        return Boolean(this.guild && this.member);
      }
      inRawGuild() {
        return Boolean(this.guildId && !this.guild && this.member);
      }
      isAutocomplete() {
        return this.type === InteractionType.ApplicationCommandAutocomplete;
      }
      isCommand() {
        return this.type === InteractionType.ApplicationCommand;
      }
      isChatInputCommand() {
        return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
      }
      isContextMenuCommand() {
        return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
      }
      isMessageComponent() {
        return this.type === InteractionType.MessageComponent;
      }
      isModalSubmit() {
        return this.type === InteractionType.ModalSubmit;
      }
      isUserContextMenuCommand() {
        return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
      }
      isMessageContextMenuCommand() {
        return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
      }
      isButton() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
      }
      isSelectMenu() {
        return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.SelectMenu;
      }
      isRepliable() {
        return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
      }
    };
    module2.exports = BaseInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS({
  "../../node_modules/discord.js/src/structures/Attachment.js"(exports2, module2) {
    "use strict";
    var { basename, flatten } = require_Util();
    var Attachment = class {
      constructor(data) {
        this.attachment = data.url;
        this.name = data.filename;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("size" in data) {
          this.size = data.size;
        }
        if ("url" in data) {
          this.url = data.url;
        }
        if ("proxy_url" in data) {
          this.proxyURL = data.proxy_url;
        }
        if ("height" in data) {
          this.height = data.height;
        } else {
          this.height ?? (this.height = null);
        }
        if ("width" in data) {
          this.width = data.width;
        } else {
          this.width ?? (this.width = null);
        }
        if ("content_type" in data) {
          this.contentType = data.content_type;
        } else {
          this.contentType ?? (this.contentType = null);
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        this.ephemeral = data.ephemeral ?? false;
      }
      get spoiler() {
        return basename(this.url ?? this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = Attachment;
  }
});

// ../../node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS({
  "../../node_modules/discord.js/src/structures/TeamMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var TeamMember = class extends Base {
      constructor(team, data) {
        super(team.client);
        this.team = team;
        this._patch(data);
      }
      _patch(data) {
        if ("permissions" in data) {
          this.permissions = data.permissions;
        }
        if ("membership_state" in data) {
          this.membershipState = data.membership_state;
        }
        if ("user" in data) {
          this.user = this.client.users._add(data.user);
        }
      }
      get id() {
        return this.user.id;
      }
      toString() {
        return this.user.toString();
      }
    };
    module2.exports = TeamMember;
  }
});

// ../../node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS({
  "../../node_modules/discord.js/src/structures/Team.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var TeamMember = require_TeamMember();
    var Team = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        } else {
          this.icon ?? (this.icon = null);
        }
        if ("owner_user_id" in data) {
          this.ownerId = data.owner_user_id;
        } else {
          this.ownerId ?? (this.ownerId = null);
        }
        this.members = new Collection2();
        for (const memberData of data.members) {
          const member = new TeamMember(this, memberData);
          this.members.set(member.id, member);
        }
      }
      get owner() {
        return this.members.get(this.ownerId) ?? null;
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return super.toJSON({ createdTimestamp: true });
      }
    };
    module2.exports = Team;
  }
});

// ../../node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes: Routes3 } = require_v106();
    var BaseManager = require_BaseManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ApplicationCommandPermissionsManager = class extends BaseManager {
      constructor(manager) {
        var _a;
        super(manager.client);
        this.manager = manager;
        this.guild = manager.guild ?? null;
        this.guildId = manager.guildId ?? ((_a = manager.guild) == null ? void 0 : _a.id) ?? null;
        this.commandId = manager.id ?? null;
      }
      permissionsPath(guildId, commandId) {
        if (commandId) {
          return Routes3.applicationCommandPermissions(this.client.application.id, guildId, commandId);
        }
        return Routes3.guildApplicationCommandsPermissions(this.client.application.id, guildId);
      }
      async fetch({ guild, command: command2 } = {}) {
        const { guildId, commandId } = this._validateOptions(guild, command2);
        if (commandId) {
          const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
          return data2.permissions;
        }
        const data = await this.client.rest.get(this.permissionsPath(guildId));
        return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection2());
      }
      async set({ guild, command: command2, permissions: permissions2, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command2);
        if (!Array.isArray(permissions2)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissions",
            "Array of ApplicationCommandPermissions",
            true
          );
        }
        if (!commandId) {
          commandId = this.client.user.id;
        }
        const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
          body: { permissions: permissions2 },
          auth: false,
          headers: { Authorization: `Bearer ${token}` }
        });
        return data.permissions;
      }
      async add({ guild, command: command2, permissions: permissions2, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command2);
        if (!commandId) {
          commandId = this.client.user.id;
        }
        if (!Array.isArray(permissions2)) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissions",
            "Array of ApplicationCommandPermissions",
            true
          );
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        const newPermissions = permissions2.slice();
        for (const perm of existing) {
          if (!newPermissions.some((x) => x.id === perm.id)) {
            newPermissions.push(perm);
          }
        }
        return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
      }
      async remove({ guild, command: command2, users, roles, channels, token } = {}) {
        if (!token) {
          throw new DiscordjsError2(ErrorCodes2.ApplicationCommandPermissionsTokenMissing);
        }
        let { guildId, commandId } = this._validateOptions(guild, command2);
        if (!commandId) {
          commandId = this.client.user.id;
        }
        if (!users && !roles && !channels) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
        }
        let resolvedUserIds = [];
        if (Array.isArray(users)) {
          for (const user of users) {
            const userId = this.client.users.resolveId(user);
            if (!userId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "users", user);
            resolvedUserIds.push(userId);
          }
        }
        let resolvedRoleIds = [];
        if (Array.isArray(roles)) {
          for (const role of roles) {
            if (typeof role === "string") {
              resolvedRoleIds.push(role);
              continue;
            }
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "roles");
            const roleId = this.guild.roles.resolveId(role);
            if (!roleId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "users", role);
            resolvedRoleIds.push(roleId);
          }
        }
        let resolvedChannelIds = [];
        if (Array.isArray(channels)) {
          for (const channel of channels) {
            if (typeof channel === "string") {
              resolvedChannelIds.push(channel);
              continue;
            }
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "channels");
            const channelId = this.guild.channels.resolveId(channel);
            if (!channelId)
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "channels", channel);
            resolvedChannelIds.push(channelId);
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        const permissions2 = existing.filter((perm) => {
          switch (perm.type) {
            case ApplicationCommandPermissionType.Role:
              return !resolvedRoleIds.includes(perm.id);
            case ApplicationCommandPermissionType.User:
              return !resolvedUserIds.includes(perm.id);
            case ApplicationCommandPermissionType.Channel:
              return !resolvedChannelIds.includes(perm.id);
          }
          return true;
        });
        return this.set({ guild: guildId, command: commandId, permissions: permissions2, token });
      }
      async has({ guild, command: command2, permissionId, permissionType }) {
        const { guildId, commandId } = this._validateOptions(guild, command2);
        if (!commandId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        if (!permissionId) {
          throw new DiscordjsTypeError2(
            ErrorCodes2.InvalidType,
            "permissionId",
            "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant"
          );
        }
        let resolvedId = permissionId;
        if (typeof permissionId !== "string") {
          resolvedId = this.client.users.resolveId(permissionId);
          if (!resolvedId) {
            if (!this.guild)
              throw new DiscordjsError2(ErrorCodes2.GuildUncachedEntityResolve, "roles");
            resolvedId = this.guild.roles.resolveId(permissionId);
          }
          if (!resolvedId) {
            resolvedId = this.guild.channels.resolveId(permissionId);
          }
          if (!resolvedId) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "permissionId",
              "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant"
            );
          }
        }
        let existing = [];
        try {
          existing = await this.fetch({ guild: guildId, command: commandId });
        } catch (error) {
          if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
            throw error;
        }
        return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
      }
      _validateOptions(guild, command2) {
        var _a, _b, _c;
        const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
        if (!guildId)
          throw new DiscordjsError2(ErrorCodes2.GlobalCommandPermissions);
        let commandId = this.commandId;
        if (command2 && !commandId) {
          commandId = (_b = (_a = this.manager).resolveId) == null ? void 0 : _b.call(_a, command2);
          if (!commandId && this.guild) {
            commandId = this.guild.commands.resolveId(command2);
          }
          commandId ?? (commandId = (_c = this.client.application) == null ? void 0 : _c.commands.resolveId(command2));
          if (!commandId) {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable", true);
          }
        }
        return { guildId, commandId };
      }
    };
    module2.exports = ApplicationCommandPermissionsManager;
  }
});

// ../../node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS({
  "../../node_modules/discord.js/src/structures/ApplicationCommand.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { ApplicationCommandOptionType } = require_v106();
    var isEqual = require_fast_deep_equal();
    var Base = require_Base();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var PermissionsBitField5 = require_PermissionsBitField();
    var ApplicationCommand = class extends Base {
      constructor(client, data, guild, guildId) {
        super(client);
        this.id = data.id;
        this.applicationId = data.application_id;
        this.guild = guild ?? null;
        this.guildId = (guild == null ? void 0 : guild.id) ?? guildId ?? null;
        this.permissions = new ApplicationCommandPermissionsManager(this);
        this.type = data.type;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data) {
          this.name = data.name;
        }
        if ("name_localizations" in data) {
          this.nameLocalizations = data.name_localizations;
        } else {
          this.nameLocalizations ?? (this.nameLocalizations = null);
        }
        if ("name_localized" in data) {
          this.nameLocalized = data.name_localized;
        } else {
          this.nameLocalized ?? (this.nameLocalized = null);
        }
        if ("description" in data) {
          this.description = data.description;
        }
        if ("description_localizations" in data) {
          this.descriptionLocalizations = data.description_localizations;
        } else {
          this.descriptionLocalizations ?? (this.descriptionLocalizations = null);
        }
        if ("description_localized" in data) {
          this.descriptionLocalized = data.description_localized;
        } else {
          this.descriptionLocalized ?? (this.descriptionLocalized = null);
        }
        if ("options" in data) {
          this.options = data.options.map((o) => this.constructor.transformOption(o, true));
        } else {
          this.options ?? (this.options = []);
        }
        if ("default_member_permissions" in data) {
          this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField5(BigInt(data.default_member_permissions)).freeze() : null;
        } else {
          this.defaultMemberPermissions ?? (this.defaultMemberPermissions = null);
        }
        if ("dm_permission" in data) {
          this.dmPermission = data.dm_permission;
        } else {
          this.dmPermission ?? (this.dmPermission = null);
        }
        if ("version" in data) {
          this.version = data.version;
        }
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get manager() {
        return (this.guild ?? this.client.application).commands;
      }
      edit(data) {
        return this.manager.edit(this, data, this.guildId);
      }
      setName(name) {
        return this.edit({ name });
      }
      setNameLocalizations(nameLocalizations) {
        return this.edit({ nameLocalizations });
      }
      setDescription(description) {
        return this.edit({ description });
      }
      setDescriptionLocalizations(descriptionLocalizations) {
        return this.edit({ descriptionLocalizations });
      }
      setDefaultMemberPermissions(defaultMemberPermissions) {
        return this.edit({ defaultMemberPermissions });
      }
      setDMPermission(dmPermission = true) {
        return this.edit({ dmPermission });
      }
      setOptions(options) {
        return this.edit({ options });
      }
      delete() {
        return this.manager.delete(this, this.guildId);
      }
      equals(command2, enforceOptionOrder = false) {
        var _a, _b, _c;
        if (command2.id && this.id !== command2.id)
          return false;
        let defaultMemberPermissions = null;
        let dmPermission = command2.dmPermission ?? command2.dm_permission;
        if ("default_member_permissions" in command2) {
          defaultMemberPermissions = command2.default_member_permissions ? new PermissionsBitField5(BigInt(command2.default_member_permissions)).bitfield : null;
        }
        if ("defaultMemberPermissions" in command2) {
          defaultMemberPermissions = command2.defaultMemberPermissions !== null ? new PermissionsBitField5(command2.defaultMemberPermissions).bitfield : null;
        }
        if (command2.name !== this.name || "description" in command2 && command2.description !== this.description || "version" in command2 && command2.version !== this.version || command2.type && command2.type !== this.type || (((_a = command2.options) == null ? void 0 : _a.length) ?? 0) !== (((_b = this.options) == null ? void 0 : _b.length) ?? 0) || defaultMemberPermissions !== (((_c = this.defaultMemberPermissions) == null ? void 0 : _c.bitfield) ?? null) || typeof dmPermission !== "undefined" && dmPermission !== this.dmPermission || !isEqual(command2.nameLocalizations ?? command2.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(
          command2.descriptionLocalizations ?? command2.description_localizations ?? {},
          this.descriptionLocalizations ?? {}
        )) {
          return false;
        }
        if (command2.options) {
          return this.constructor.optionsEqual(this.options, command2.options, enforceOptionOrder);
        }
        return true;
      }
      static optionsEqual(existing, options, enforceOptionOrder = false) {
        if (existing.length !== options.length)
          return false;
        if (enforceOptionOrder) {
          return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
        }
        const newOptions = new Map(options.map((option) => [option.name, option]));
        for (const option of existing) {
          const foundOption = newOptions.get(option.name);
          if (!foundOption || !this._optionEquals(option, foundOption))
            return false;
        }
        return true;
      }
      static _optionEquals(existing, option, enforceOptionOrder = false) {
        var _a, _b, _c, _d, _e, _f;
        if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? void 0 : false)) !== existing.required || ((_a = option.choices) == null ? void 0 : _a.length) !== ((_b = existing.choices) == null ? void 0 : _b.length) || ((_c = option.options) == null ? void 0 : _c.length) !== ((_d = existing.options) == null ? void 0 : _d.length) || ((_e = option.channelTypes ?? option.channel_types) == null ? void 0 : _e.length) !== ((_f = existing.channelTypes) == null ? void 0 : _f.length) || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(
          option.descriptionLocalizations ?? option.description_localizations ?? {},
          existing.descriptionLocalizations ?? {}
        )) {
          return false;
        }
        if (existing.choices) {
          if (enforceOptionOrder && !existing.choices.every(
            (choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(
              choice.nameLocalizations ?? {},
              option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}
            )
          )) {
            return false;
          }
          if (!enforceOptionOrder) {
            const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
            for (const choice of existing.choices) {
              const foundChoice = newChoices.get(choice.name);
              if (!foundChoice || foundChoice.value !== choice.value)
                return false;
            }
          }
        }
        if (existing.channelTypes) {
          const newTypes = option.channelTypes ?? option.channel_types;
          for (const type of existing.channelTypes) {
            if (!newTypes.includes(type))
              return false;
          }
        }
        if (existing.options) {
          return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
        }
        return true;
      }
      static transformOption(option, received) {
        var _a, _b;
        const channelTypesKey = received ? "channelTypes" : "channel_types";
        const minValueKey = received ? "minValue" : "min_value";
        const maxValueKey = received ? "maxValue" : "max_value";
        const minLengthKey = received ? "minLength" : "min_length";
        const maxLengthKey = received ? "maxLength" : "max_length";
        const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
        const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
        const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
        const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
        return {
          type: option.type,
          name: option.name,
          [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
          [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
          description: option.description,
          [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
          [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
          required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? void 0 : false),
          autocomplete: option.autocomplete,
          choices: (_a = option.choices) == null ? void 0 : _a.map((choice) => ({
            name: choice.name,
            [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
            [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
            value: choice.value
          })),
          options: (_b = option.options) == null ? void 0 : _b.map((o) => this.transformOption(o, received)),
          [channelTypesKey]: option.channelTypes ?? option.channel_types,
          [minValueKey]: option.minValue ?? option.min_value,
          [maxValueKey]: option.maxValue ?? option.max_value,
          [minLengthKey]: option.minLength ?? option.min_length,
          [maxLengthKey]: option.maxLength ?? option.max_length
        };
      }
    };
    module2.exports = ApplicationCommand;
  }
});

// ../../node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist7();
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes3 } = require_v106();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ApplicationCommand = require_ApplicationCommand();
    var PermissionsBitField5 = require_PermissionsBitField();
    var ApplicationCommandManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, ApplicationCommand, iterable);
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
      _add(data, cache, guildId) {
        return super._add(data, cache, { extras: [this.guild, guildId] });
      }
      commandPath({ id, guildId } = {}) {
        var _a, _b;
        if (this.guild ?? guildId) {
          if (id) {
            return Routes3.applicationGuildCommand(this.client.application.id, ((_a = this.guild) == null ? void 0 : _a.id) ?? guildId, id);
          }
          return Routes3.applicationGuildCommands(this.client.application.id, ((_b = this.guild) == null ? void 0 : _b.id) ?? guildId);
        }
        if (id) {
          return Routes3.applicationCommand(this.client.application.id, id);
        }
        return Routes3.applicationCommands(this.client.application.id);
      }
      async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
        if (typeof id === "object") {
          ({ guildId, cache = true, locale, withLocalizations } = id);
        } else if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const command2 = await this.client.rest.get(this.commandPath({ id, guildId }));
          return this._add(command2, cache);
        }
        const data = await this.client.rest.get(this.commandPath({ guildId }), {
          headers: {
            "X-Discord-Locale": locale
          },
          query: makeURLSearchParams2({ with_localizations: withLocalizations })
        });
        return data.reduce((coll, command2) => coll.set(command2.id, this._add(command2, cache, guildId)), new Collection2());
      }
      async create(command2, guildId) {
        const data = await this.client.rest.post(this.commandPath({ guildId }), {
          body: this.constructor.transformCommand(command2)
        });
        return this._add(data, true, guildId);
      }
      async set(commands, guildId) {
        const data = await this.client.rest.put(this.commandPath({ guildId }), {
          body: commands.map((c) => this.constructor.transformCommand(c))
        });
        return data.reduce((coll, command2) => coll.set(command2.id, this._add(command2, true, guildId)), new Collection2());
      }
      async edit(command2, data, guildId) {
        const id = this.resolveId(command2);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
          body: this.constructor.transformCommand(data)
        });
        return this._add(patched, true, guildId);
      }
      async delete(command2, guildId) {
        const id = this.resolveId(command2);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "command", "ApplicationCommandResolvable");
        await this.client.rest.delete(this.commandPath({ id, guildId }));
        const cached = this.cache.get(id);
        this.cache.delete(id);
        return cached ?? null;
      }
      static transformCommand(command2) {
        var _a;
        if (isJSONEncodable(command2))
          return command2.toJSON();
        let default_member_permissions;
        if ("default_member_permissions" in command2) {
          default_member_permissions = command2.default_member_permissions ? new PermissionsBitField5(BigInt(command2.default_member_permissions)).bitfield.toString() : command2.default_member_permissions;
        }
        if ("defaultMemberPermissions" in command2) {
          default_member_permissions = command2.defaultMemberPermissions !== null ? new PermissionsBitField5(command2.defaultMemberPermissions).bitfield.toString() : command2.defaultMemberPermissions;
        }
        return {
          name: command2.name,
          name_localizations: command2.nameLocalizations ?? command2.name_localizations,
          description: command2.description,
          description_localizations: command2.descriptionLocalizations ?? command2.description_localizations,
          type: command2.type,
          options: (_a = command2.options) == null ? void 0 : _a.map((o) => ApplicationCommand.transformOption(o)),
          default_member_permissions,
          dm_permission: command2.dmPermission ?? command2.dm_permission
        };
      }
    };
    module2.exports = ApplicationCommandManager;
  }
});

// ../../node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/ApplicationFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ApplicationFlags } = require_v106();
    var BitField = require_BitField();
    var ApplicationFlagsBitField = class extends BitField {
    };
    __publicField(ApplicationFlagsBitField, "Flags", ApplicationFlags);
    module2.exports = ApplicationFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS({
  "../../node_modules/discord.js/src/structures/ClientApplication.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var Team = require_Team();
    var Application = require_Application();
    var ApplicationCommandManager = require_ApplicationCommandManager();
    var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
    var PermissionsBitField5 = require_PermissionsBitField();
    var ClientApplication = class extends Application {
      constructor(client, data) {
        super(client, data);
        this.commands = new ApplicationCommandManager(this.client);
      }
      _patch(data) {
        super._patch(data);
        this.tags = data.tags ?? [];
        if ("install_params" in data) {
          this.installParams = {
            scopes: data.install_params.scopes,
            permissions: new PermissionsBitField5(data.install_params.permissions).freeze()
          };
        } else {
          this.installParams ?? (this.installParams = null);
        }
        if ("custom_install_url" in data) {
          this.customInstallURL = data.custom_install_url;
        } else {
          this.customInstallURL = null;
        }
        if ("flags" in data) {
          this.flags = new ApplicationFlagsBitField(data.flags).freeze();
        }
        if ("cover_image" in data) {
          this.cover = data.cover_image;
        } else {
          this.cover ?? (this.cover = null);
        }
        if ("rpc_origins" in data) {
          this.rpcOrigins = data.rpc_origins;
        } else {
          this.rpcOrigins ?? (this.rpcOrigins = []);
        }
        if ("bot_require_code_grant" in data) {
          this.botRequireCodeGrant = data.bot_require_code_grant;
        } else {
          this.botRequireCodeGrant ?? (this.botRequireCodeGrant = null);
        }
        if ("bot_public" in data) {
          this.botPublic = data.bot_public;
        } else {
          this.botPublic ?? (this.botPublic = null);
        }
        this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
      }
      get partial() {
        return !this.name;
      }
      async fetch() {
        const app = await this.client.rest.get(Routes3.oauth2CurrentApplication());
        this._patch(app);
        return this;
      }
    };
    module2.exports = ClientApplication;
  }
});

// ../../node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS({
  "../../node_modules/discord.js/src/structures/Embed.js"(exports2, module2) {
    "use strict";
    var isEqual = require_fast_deep_equal();
    var Embed = class {
      constructor(data) {
        this.data = { ...data };
      }
      get fields() {
        return this.data.fields ?? [];
      }
      get title() {
        return this.data.title ?? null;
      }
      get description() {
        return this.data.description ?? null;
      }
      get url() {
        return this.data.url ?? null;
      }
      get color() {
        return this.data.color ?? null;
      }
      get timestamp() {
        return this.data.timestamp ?? null;
      }
      get thumbnail() {
        if (!this.data.thumbnail)
          return null;
        return {
          url: this.data.thumbnail.url,
          proxyURL: this.data.thumbnail.proxy_url,
          height: this.data.thumbnail.height,
          width: this.data.thumbnail.width
        };
      }
      get image() {
        if (!this.data.image)
          return null;
        return {
          url: this.data.image.url,
          proxyURL: this.data.image.proxy_url,
          height: this.data.image.height,
          width: this.data.image.width
        };
      }
      get video() {
        if (!this.data.video)
          return null;
        return {
          url: this.data.video.url,
          proxyURL: this.data.video.proxy_url,
          height: this.data.video.height,
          width: this.data.video.width
        };
      }
      get author() {
        if (!this.data.author)
          return null;
        return {
          name: this.data.author.name,
          url: this.data.author.url,
          iconURL: this.data.author.icon_url,
          proxyIconURL: this.data.author.proxy_icon_url
        };
      }
      get provider() {
        return this.data.provider ?? null;
      }
      get footer() {
        if (!this.data.footer)
          return null;
        return {
          text: this.data.footer.text,
          iconURL: this.data.footer.icon_url,
          proxyIconURL: this.data.footer.proxy_icon_url
        };
      }
      get length() {
        var _a, _b, _c, _d, _e;
        return (((_a = this.data.title) == null ? void 0 : _a.length) ?? 0) + (((_b = this.data.description) == null ? void 0 : _b.length) ?? 0) + (((_c = this.data.fields) == null ? void 0 : _c.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0)) ?? 0) + (((_d = this.data.footer) == null ? void 0 : _d.text.length) ?? 0) + (((_e = this.data.author) == null ? void 0 : _e.name.length) ?? 0);
      }
      get hexColor() {
        return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
      }
      toJSON() {
        return { ...this.data };
      }
      equals(other) {
        if (other instanceof Embed) {
          return isEqual(other.data, this.data);
        }
        return isEqual(other, this.data);
      }
    };
    module2.exports = Embed;
  }
});

// ../../node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS({
  "../../node_modules/discord.js/src/structures/MessageMentions.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { FormattingPatterns } = require_v106();
    var { flatten } = require_Util();
    var _MessageMentions = class {
      constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
        Object.defineProperty(this, "client", { value: message.client });
        Object.defineProperty(this, "guild", { value: message.guild });
        Object.defineProperty(this, "_content", { value: message.content });
        this.everyone = Boolean(everyone);
        if (users) {
          if (users instanceof Collection2) {
            this.users = new Collection2(users);
          } else {
            this.users = new Collection2();
            for (const mention of users) {
              if (mention.member && message.guild) {
                message.guild.members._add(Object.assign(mention.member, { user: mention }));
              }
              const user = message.client.users._add(mention);
              this.users.set(user.id, user);
            }
          }
        } else {
          this.users = new Collection2();
        }
        if (roles instanceof Collection2) {
          this.roles = new Collection2(roles);
        } else if (roles) {
          this.roles = new Collection2();
          const guild = message.guild;
          if (guild) {
            for (const mention of roles) {
              const role = guild.roles.cache.get(mention);
              if (role)
                this.roles.set(role.id, role);
            }
          }
        } else {
          this.roles = new Collection2();
        }
        this._members = null;
        this._channels = null;
        this._parsedUsers = null;
        if (crosspostedChannels) {
          if (crosspostedChannels instanceof Collection2) {
            this.crosspostedChannels = new Collection2(crosspostedChannels);
          } else {
            this.crosspostedChannels = new Collection2();
            for (const d of crosspostedChannels) {
              this.crosspostedChannels.set(d.id, {
                channelId: d.id,
                guildId: d.guild_id,
                type: d.type,
                name: d.name
              });
            }
          }
        } else {
          this.crosspostedChannels = new Collection2();
        }
        this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
      }
      get members() {
        if (this._members)
          return this._members;
        if (!this.guild)
          return null;
        this._members = new Collection2();
        this.users.forEach((user) => {
          const member = this.guild.members.resolve(user);
          if (member)
            this._members.set(member.user.id, member);
        });
        return this._members;
      }
      get channels() {
        if (this._channels)
          return this._channels;
        this._channels = new Collection2();
        let matches;
        while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
          const channel = this.client.channels.cache.get(matches.groups.id);
          if (channel)
            this._channels.set(channel.id, channel);
        }
        return this._channels;
      }
      get parsedUsers() {
        if (this._parsedUsers)
          return this._parsedUsers;
        this._parsedUsers = new Collection2();
        let matches;
        while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
          const user = this.client.users.cache.get(matches[1]);
          if (user)
            this._parsedUsers.set(user.id, user);
        }
        return this._parsedUsers;
      }
      has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
        var _a, _b, _c;
        const user = this.client.users.resolve(data);
        if (!ignoreEveryone && user && this.everyone)
          return true;
        const userWasRepliedTo = user && ((_a = this.repliedUser) == null ? void 0 : _a.id) === user.id;
        if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
          return true;
        if (!ignoreDirect) {
          if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
            return true;
          const role = (_b = this.guild) == null ? void 0 : _b.roles.resolve(data);
          if (role && this.roles.has(role.id))
            return true;
          const channel = this.client.channels.resolve(data);
          if (channel && this.channels.has(channel.id))
            return true;
        }
        if (!ignoreRoles) {
          const member = (_c = this.guild) == null ? void 0 : _c.members.resolve(data);
          if (member) {
            for (const mentionedRole of this.roles.values())
              if (member.roles.cache.has(mentionedRole.id))
                return true;
          }
        }
        return false;
      }
      toJSON() {
        return flatten(this, {
          members: true,
          channels: true
        });
      }
    };
    var MessageMentions = _MessageMentions;
    __publicField(MessageMentions, "EveryonePattern", /@(?<mention>everyone|here)/);
    __publicField(MessageMentions, "UsersPattern", FormattingPatterns.UserWithOptionalNickname);
    __publicField(MessageMentions, "RolesPattern", FormattingPatterns.Role);
    __publicField(MessageMentions, "ChannelsPattern", FormattingPatterns.Channel);
    __publicField(MessageMentions, "GlobalChannelsPattern", new RegExp(_MessageMentions.ChannelsPattern.source, "g"));
    __publicField(MessageMentions, "GlobalUsersPattern", new RegExp(_MessageMentions.UsersPattern.source, "g"));
    module2.exports = MessageMentions;
  }
});

// ../../node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS({
  "../../node_modules/discord.js/src/structures/ReactionCollector.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Collector = require_Collector();
    var Events3 = require_Events();
    var ReactionCollector = class extends Collector {
      constructor(message, options = {}) {
        super(message.client, options);
        this.message = message;
        this.users = new Collection2();
        this.total = 0;
        this.empty = this.empty.bind(this);
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        const bulkDeleteListener = (messages) => {
          if (messages.has(this.message.id))
            this.stop("messageDelete");
        };
        this.client.incrementMaxListeners();
        this.client.on(Events3.MessageReactionAdd, this.handleCollect);
        this.client.on(Events3.MessageReactionRemove, this.handleDispose);
        this.client.on(Events3.MessageReactionRemoveAll, this.empty);
        this.client.on(Events3.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events3.MessageBulkDelete, bulkDeleteListener);
        this.client.on(Events3.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events3.ThreadDelete, this._handleThreadDeletion);
        this.client.on(Events3.GuildDelete, this._handleGuildDeletion);
        this.once("end", () => {
          this.client.removeListener(Events3.MessageReactionAdd, this.handleCollect);
          this.client.removeListener(Events3.MessageReactionRemove, this.handleDispose);
          this.client.removeListener(Events3.MessageReactionRemoveAll, this.empty);
          this.client.removeListener(Events3.MessageDelete, this._handleMessageDeletion);
          this.client.removeListener(Events3.MessageBulkDelete, bulkDeleteListener);
          this.client.removeListener(Events3.ChannelDelete, this._handleChannelDeletion);
          this.client.removeListener(Events3.ThreadDelete, this._handleThreadDeletion);
          this.client.removeListener(Events3.GuildDelete, this._handleGuildDeletion);
          this.client.decrementMaxListeners();
        });
        this.on("collect", (reaction, user) => {
          if (reaction.count === 1) {
            this.emit("create", reaction, user);
          }
          this.total++;
          this.users.set(user.id, user);
        });
        this.on("remove", (reaction, user) => {
          this.total--;
          if (!this.collected.some((r) => r.users.cache.has(user.id)))
            this.users.delete(user.id);
        });
      }
      collect(reaction) {
        if (reaction.message.id !== this.message.id)
          return null;
        return ReactionCollector.key(reaction);
      }
      dispose(reaction, user) {
        if (reaction.message.id !== this.message.id)
          return null;
        if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
          this.emit("remove", reaction, user);
        }
        return reaction.count ? null : ReactionCollector.key(reaction);
      }
      empty() {
        this.total = 0;
        this.collected.clear();
        this.users.clear();
        this.checkEnd();
      }
      get endReason() {
        if (this.options.max && this.total >= this.options.max)
          return "limit";
        if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
          return "emojiLimit";
        if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
          return "userLimit";
        return super.endReason;
      }
      _handleMessageDeletion(message) {
        if (message.id === this.message.id) {
          this.stop("messageDelete");
        }
      }
      _handleChannelDeletion(channel) {
        var _a;
        if (channel.id === this.message.channelId || ((_a = channel.threads) == null ? void 0 : _a.cache.has(this.message.channelId))) {
          this.stop("channelDelete");
        }
      }
      _handleThreadDeletion(thread) {
        if (thread.id === this.message.channelId) {
          this.stop("threadDelete");
        }
      }
      _handleGuildDeletion(guild) {
        var _a;
        if (guild.id === ((_a = this.message.guild) == null ? void 0 : _a.id)) {
          this.stop("guildDelete");
        }
      }
      static key(reaction) {
        return reaction.emoji.id ?? reaction.emoji.name;
      }
    };
    module2.exports = ReactionCollector;
  }
});

// ../../node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS({
  "../../node_modules/discord.js/src/structures/Sticker.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes3, StickerFormatType } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Sticker2 = class extends Base {
      constructor(client, sticker) {
        super(client);
        this._patch(sticker);
      }
      _patch(sticker) {
        this.id = sticker.id;
        if ("description" in sticker) {
          this.description = sticker.description;
        } else {
          this.description ?? (this.description = null);
        }
        if ("type" in sticker) {
          this.type = sticker.type;
        } else {
          this.type ?? (this.type = null);
        }
        if ("format_type" in sticker) {
          this.format = sticker.format_type;
        }
        if ("name" in sticker) {
          this.name = sticker.name;
        }
        if ("pack_id" in sticker) {
          this.packId = sticker.pack_id;
        } else {
          this.packId ?? (this.packId = null);
        }
        if ("tags" in sticker) {
          this.tags = sticker.tags;
        } else {
          this.tags ?? (this.tags = null);
        }
        if ("available" in sticker) {
          this.available = sticker.available;
        } else {
          this.available ?? (this.available = null);
        }
        if ("guild_id" in sticker) {
          this.guildId = sticker.guild_id;
        } else {
          this.guildId ?? (this.guildId = null);
        }
        if ("user" in sticker) {
          this.user = this.client.users._add(sticker.user);
        } else {
          this.user ?? (this.user = null);
        }
        if ("sort_value" in sticker) {
          this.sortValue = sticker.sort_value;
        } else {
          this.sortValue ?? (this.sortValue = null);
        }
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get partial() {
        return !this.type;
      }
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      get url() {
        return this.client.rest.cdn.sticker(this.id, this.format === StickerFormatType.Lottie ? "json" : "png");
      }
      async fetch() {
        const data = await this.client.rest.get(Routes3.sticker(this.id));
        this._patch(data);
        return this;
      }
      async fetchPack() {
        return (this.packId && (await this.client.fetchPremiumStickerPacks()).get(this.packId)) ?? null;
      }
      async fetchUser() {
        if (this.partial)
          await this.fetch();
        if (!this.guildId)
          throw new DiscordjsError2(ErrorCodes2.NotGuildSticker);
        return this.guild.stickers.fetchUser(this);
      }
      edit(data) {
        return this.guild.stickers.edit(this, data);
      }
      async delete(reason) {
        await this.guild.stickers.delete(this, reason);
        return this;
      }
      equals(other) {
        if (other instanceof Sticker2) {
          return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
        } else {
          return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
        }
      }
    };
    exports2.Sticker = Sticker2;
  }
});

// ../../node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS({
  "../../node_modules/discord.js/src/structures/BaseGuildEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var BaseGuildEmoji = class extends Emoji {
      constructor(client, data, guild) {
        super(client, data);
        this.guild = guild;
        this.requiresColons = null;
        this.managed = null;
        this.available = null;
        this._patch(data);
      }
      _patch(data) {
        if ("name" in data)
          this.name = data.name;
        if ("require_colons" in data) {
          this.requiresColons = data.require_colons;
        }
        if ("managed" in data) {
          this.managed = data.managed;
        }
        if ("available" in data) {
          this.available = data.available;
        }
      }
    };
    module2.exports = BaseGuildEmoji;
  }
});

// ../../node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildEmojiRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var DataManager = require_DataManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Role } = require_Role();
    var GuildEmojiRoleManager = class extends DataManager {
      constructor(emoji) {
        super(emoji.client, Role);
        this.emoji = emoji;
        this.guild = emoji.guild;
      }
      get cache() {
        return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
      }
      add(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2))
          roleOrRoles = [roleOrRoles];
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role));
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles);
      }
      remove(roleOrRoles) {
        if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection2))
          roleOrRoles = [roleOrRoles];
        const resolvedRoleIds = [];
        for (const role of roleOrRoles.values()) {
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId) {
            return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role));
          }
          resolvedRoleIds.push(roleId);
        }
        const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
        return this.set(newRoles);
      }
      set(roles) {
        return this.emoji.edit({ roles });
      }
      clone() {
        const clone = new this.constructor(this.emoji);
        clone._patch([...this.cache.keys()]);
        return clone;
      }
      _patch(roles) {
        this.emoji._roles = roles;
      }
      valueOf() {
        return this.cache;
      }
    };
    module2.exports = GuildEmojiRoleManager;
  }
});

// ../../node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildEmoji.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    var GuildEmoji = class extends BaseGuildEmoji {
      constructor(client, data, guild) {
        super(client, data, guild);
        this.author = null;
        Object.defineProperty(this, "_roles", { value: [], writable: true });
        this._patch(data);
      }
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      _patch(data) {
        super._patch(data);
        if (data.user)
          this.author = this.client.users._add(data.user);
        if (data.roles)
          this._roles = data.roles;
      }
      get deletable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits4.ManageEmojisAndStickers);
      }
      get roles() {
        return new GuildEmojiRoleManager(this);
      }
      fetchAuthor() {
        return this.guild.emojis.fetchAuthor(this);
      }
      edit(data) {
        return this.guild.emojis.edit(this.id, data);
      }
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      async delete(reason) {
        await this.guild.emojis.delete(this.id, reason);
        return this;
      }
      equals(other) {
        if (other instanceof GuildEmoji) {
          return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
        } else {
          return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
        }
      }
    };
    module2.exports = GuildEmoji;
  }
});

// ../../node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS({
  "../../node_modules/discord.js/src/structures/ReactionEmoji.js"(exports2, module2) {
    "use strict";
    var { Emoji } = require_Emoji();
    var { flatten } = require_Util();
    var ReactionEmoji = class extends Emoji {
      constructor(reaction, emoji) {
        super(reaction.message.client, emoji);
        this.reaction = reaction;
      }
      toJSON() {
        return flatten(this, { identifier: true });
      }
      valueOf() {
        return this.id;
      }
    };
    module2.exports = ReactionEmoji;
  }
});

// ../../node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/UserFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { UserFlags } = require_v106();
    var BitField = require_BitField();
    var UserFlagsBitField = class extends BitField {
    };
    __publicField(UserFlagsBitField, "Flags", UserFlags);
    module2.exports = UserFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/structures/User.js
var require_User = __commonJS({
  "../../node_modules/discord.js/src/structures/User.js"(exports2, module2) {
    "use strict";
    var { userMention } = require_dist7();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var TextBasedChannel = require_TextBasedChannel();
    var UserFlagsBitField = require_UserFlagsBitField();
    var User = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.bot = null;
        this.system = null;
        this.flags = null;
        this._patch(data);
      }
      _patch(data) {
        if ("username" in data) {
          this.username = data.username;
        } else {
          this.username ?? (this.username = null);
        }
        if ("bot" in data) {
          this.bot = Boolean(data.bot);
        } else if (!this.partial && typeof this.bot !== "boolean") {
          this.bot = false;
        }
        if ("discriminator" in data) {
          this.discriminator = data.discriminator;
        } else {
          this.discriminator ?? (this.discriminator = null);
        }
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else {
          this.avatar ?? (this.avatar = null);
        }
        if ("banner" in data) {
          this.banner = data.banner;
        } else if (this.banner !== null) {
          this.banner ?? (this.banner = void 0);
        }
        if ("accent_color" in data) {
          this.accentColor = data.accent_color;
        } else if (this.accentColor !== null) {
          this.accentColor ?? (this.accentColor = void 0);
        }
        if ("system" in data) {
          this.system = Boolean(data.system);
        } else if (!this.partial && typeof this.system !== "boolean") {
          this.system = false;
        }
        if ("public_flags" in data) {
          this.flags = new UserFlagsBitField(data.public_flags);
        }
      }
      get partial() {
        return typeof this.username !== "string";
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
      }
      get defaultAvatarURL() {
        return this.client.rest.cdn.defaultAvatar(this.discriminator % 5);
      }
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.defaultAvatarURL;
      }
      get hexAccentColor() {
        if (typeof this.accentColor !== "number")
          return this.accentColor;
        return `#${this.accentColor.toString(16).padStart(6, "0")}`;
      }
      bannerURL(options = {}) {
        return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
      }
      get tag() {
        return typeof this.username === "string" ? `${this.username}#${this.discriminator}` : null;
      }
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      createDM(force = false) {
        return this.client.users.createDM(this.id, { force });
      }
      deleteDM() {
        return this.client.users.deleteDM(this.id);
      }
      equals(user) {
        var _a, _b;
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar && ((_a = this.flags) == null ? void 0 : _a.bitfield) === ((_b = user.flags) == null ? void 0 : _b.bitfield) && this.banner === user.banner && this.accentColor === user.accentColor;
      }
      _equals(user) {
        var _a;
        return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.avatar === user.avatar && ((_a = this.flags) == null ? void 0 : _a.bitfield) === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true);
      }
      fetchFlags(force = false) {
        return this.client.users.fetchFlags(this.id, { force });
      }
      fetch(force = true) {
        return this.client.users.fetch(this.id, { force });
      }
      toString() {
        return userMention(this.id);
      }
      toJSON(...props) {
        const json = super.toJSON(
          {
            createdTimestamp: true,
            defaultAvatarURL: true,
            hexAccentColor: true,
            tag: true
          },
          ...props
        );
        json.avatarURL = this.avatarURL();
        json.displayAvatarURL = this.displayAvatarURL();
        json.bannerURL = this.banner ? this.bannerURL() : this.banner;
        return json;
      }
      send() {
      }
    };
    TextBasedChannel.applyToClass(User);
    module2.exports = User;
  }
});

// ../../node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ReactionUserManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var User = require_User();
    var ReactionUserManager = class extends CachedManager {
      constructor(reaction, iterable) {
        super(reaction.client, User, iterable);
        this.reaction = reaction;
      }
      async fetch({ limit = 100, after } = {}) {
        const message = this.reaction.message;
        const query = makeURLSearchParams2({ limit, after });
        const data = await this.client.rest.get(
          Routes3.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier),
          { query }
        );
        const users = new Collection2();
        for (const rawUser of data) {
          const user = this.client.users._add(rawUser);
          this.cache.set(user.id, user);
          users.set(user.id, user);
        }
        return users;
      }
      async remove(user = this.client.user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsError2(ErrorCodes2.ReactionResolveUser);
        const message = this.reaction.message;
        const route = userId === this.client.user.id ? Routes3.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes3.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
        await this.client.rest.delete(route);
        return this.reaction;
      }
    };
    module2.exports = ReactionUserManager;
  }
});

// ../../node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS({
  "../../node_modules/discord.js/src/structures/MessageReaction.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var ReactionUserManager = require_ReactionUserManager();
    var { flatten } = require_Util();
    var MessageReaction = class {
      constructor(client, data, message) {
        Object.defineProperty(this, "client", { value: client });
        this.message = message;
        this.me = data.me;
        this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
        this._emoji = new ReactionEmoji(this, data.emoji);
        this._patch(data);
      }
      _patch(data) {
        if ("count" in data) {
          this.count ?? (this.count = data.count);
        }
      }
      react() {
        return this.message.react(this.emoji);
      }
      async remove() {
        await this.client.rest.delete(
          Routes3.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier)
        );
        return this;
      }
      get emoji() {
        if (this._emoji instanceof GuildEmoji)
          return this._emoji;
        if (this._emoji.id) {
          const emojis = this.message.client.emojis.cache;
          if (emojis.has(this._emoji.id)) {
            const emoji = emojis.get(this._emoji.id);
            this._emoji = emoji;
            return emoji;
          }
        }
        return this._emoji;
      }
      get partial() {
        return this.count === null;
      }
      async fetch() {
        const message = await this.message.fetch();
        const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
        this._patch(existing ?? { count: 0 });
        return this;
      }
      toJSON() {
        return flatten(this, { emoji: "emojiId", message: "messageId" });
      }
      _add(user) {
        if (this.partial)
          return;
        this.users.cache.set(user.id, user);
        if (!this.me || user.id !== this.message.client.user.id || this.count === 0)
          this.count++;
        this.me || (this.me = user.id === this.message.client.user.id);
      }
      _remove(user) {
        if (this.partial)
          return;
        this.users.cache.delete(user.id);
        if (!this.me || user.id !== this.message.client.user.id)
          this.count--;
        if (user.id === this.message.client.user.id)
          this.me = false;
        if (this.count <= 0 && this.users.cache.size === 0) {
          this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
        }
      }
    };
    module2.exports = MessageReaction;
  }
});

// ../../node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ReactionManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var MessageReaction = require_MessageReaction();
    var ReactionManager = class extends CachedManager {
      constructor(message, iterable) {
        super(message.client, MessageReaction, iterable);
        this.message = message;
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
      }
      async removeAll() {
        await this.client.rest.delete(Routes3.channelMessageAllReactions(this.message.channelId, this.message.id));
        return this.message;
      }
    };
    module2.exports = ReactionManager;
  }
});

// ../../node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS({
  "../../node_modules/discord.js/src/structures/Message.js"(exports2) {
    "use strict";
    var { messageLink } = require_dist7();
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var {
      InteractionType,
      ChannelType,
      MessageType,
      MessageFlags,
      PermissionFlagsBits: PermissionFlagsBits4
    } = require_v106();
    var Attachment = require_Attachment();
    var Base = require_Base();
    var ClientApplication = require_ClientApplication();
    var Embed = require_Embed();
    var InteractionCollector = require_InteractionCollector();
    var Mentions = require_MessageMentions();
    var MessagePayload = require_MessagePayload();
    var ReactionCollector = require_ReactionCollector();
    var { Sticker: Sticker2 } = require_Sticker();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ReactionManager = require_ReactionManager();
    var { createComponent } = require_Components();
    var { NonSystemMessageTypes } = require_Constants();
    var MessageFlagsBitField = require_MessageFlagsBitField();
    var PermissionsBitField5 = require_PermissionsBitField();
    var { cleanContent, resolvePartialEmoji } = require_Util();
    var Message = class extends Base {
      constructor(client, data) {
        var _a, _b;
        super(client);
        this.channelId = data.channel_id;
        this.guildId = data.guild_id ?? ((_b = (_a = this.channel) == null ? void 0 : _a.guild) == null ? void 0 : _b.id) ?? null;
        this._patch(data);
      }
      _patch(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.id = data.id;
        this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
        if ("type" in data) {
          this.type = data.type;
          this.system = !NonSystemMessageTypes.includes(this.type);
        } else {
          this.system ?? (this.system = null);
          this.type ?? (this.type = null);
        }
        if ("content" in data) {
          this.content = data.content;
        } else {
          this.content ?? (this.content = null);
        }
        if ("author" in data) {
          this.author = this.client.users._add(data.author, !data.webhook_id);
        } else {
          this.author ?? (this.author = null);
        }
        if ("pinned" in data) {
          this.pinned = Boolean(data.pinned);
        } else {
          this.pinned ?? (this.pinned = null);
        }
        if ("tts" in data) {
          this.tts = data.tts;
        } else {
          this.tts ?? (this.tts = null);
        }
        if ("nonce" in data) {
          this.nonce = data.nonce;
        } else {
          this.nonce ?? (this.nonce = null);
        }
        if ("embeds" in data) {
          this.embeds = data.embeds.map((e) => new Embed(e));
        } else {
          this.embeds = ((_a = this.embeds) == null ? void 0 : _a.slice()) ?? [];
        }
        if ("components" in data) {
          this.components = data.components.map((c) => createComponent(c));
        } else {
          this.components = ((_b = this.components) == null ? void 0 : _b.slice()) ?? [];
        }
        if ("attachments" in data) {
          this.attachments = new Collection2();
          if (data.attachments) {
            for (const attachment of data.attachments) {
              this.attachments.set(attachment.id, new Attachment(attachment));
            }
          }
        } else {
          this.attachments = new Collection2(this.attachments);
        }
        if ("sticker_items" in data || "stickers" in data) {
          this.stickers = new Collection2(
            (_c = data.sticker_items ?? data.stickers) == null ? void 0 : _c.map((s) => [s.id, new Sticker2(this.client, s)])
          );
        } else {
          this.stickers = new Collection2(this.stickers);
        }
        if ("position" in data) {
          this.position = data.position;
        } else {
          this.position ?? (this.position = null);
        }
        if (data.edited_timestamp) {
          this.editedTimestamp = Date.parse(data.edited_timestamp);
        } else {
          this.editedTimestamp ?? (this.editedTimestamp = null);
        }
        if ("reactions" in data) {
          this.reactions = new ReactionManager(this);
          if (((_d = data.reactions) == null ? void 0 : _d.length) > 0) {
            for (const reaction of data.reactions) {
              this.reactions._add(reaction);
            }
          }
        } else {
          this.reactions ?? (this.reactions = new ReactionManager(this));
        }
        if (!this.mentions) {
          this.mentions = new Mentions(
            this,
            data.mentions,
            data.mention_roles,
            data.mention_everyone,
            data.mention_channels,
            (_e = data.referenced_message) == null ? void 0 : _e.author
          );
        } else {
          this.mentions = new Mentions(
            this,
            data.mentions ?? this.mentions.users,
            data.mention_roles ?? this.mentions.roles,
            data.mention_everyone ?? this.mentions.everyone,
            data.mention_channels ?? this.mentions.crosspostedChannels,
            ((_f = data.referenced_message) == null ? void 0 : _f.author) ?? this.mentions.repliedUser
          );
        }
        if ("webhook_id" in data) {
          this.webhookId = data.webhook_id;
        } else {
          this.webhookId ?? (this.webhookId = null);
        }
        if ("application" in data) {
          this.groupActivityApplication = new ClientApplication(this.client, data.application);
        } else {
          this.groupActivityApplication ?? (this.groupActivityApplication = null);
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ?? (this.applicationId = null);
        }
        if ("activity" in data) {
          this.activity = {
            partyId: data.activity.party_id,
            type: data.activity.type
          };
        } else {
          this.activity ?? (this.activity = null);
        }
        if ("thread" in data) {
          this.client.channels._add(data.thread, this.guild);
        }
        if (this.member && data.member) {
          this.member._patch(data.member);
        } else if (data.member && this.guild && this.author) {
          this.guild.members._add(Object.assign(data.member, { user: this.author }));
        }
        if ("flags" in data) {
          this.flags = new MessageFlagsBitField(data.flags).freeze();
        } else {
          this.flags = new MessageFlagsBitField(this.flags).freeze();
        }
        if ("message_reference" in data) {
          this.reference = {
            channelId: data.message_reference.channel_id,
            guildId: data.message_reference.guild_id,
            messageId: data.message_reference.message_id
          };
        } else {
          this.reference ?? (this.reference = null);
        }
        if (data.referenced_message) {
          (_h = this.channel) == null ? void 0 : _h.messages._add({ guild_id: (_g = data.message_reference) == null ? void 0 : _g.guild_id, ...data.referenced_message });
        }
        if (data.interaction) {
          this.interaction = {
            id: data.interaction.id,
            type: data.interaction.type,
            commandName: data.interaction.name,
            user: this.client.users._add(data.interaction.user)
          };
        } else {
          this.interaction ?? (this.interaction = null);
        }
      }
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      get partial() {
        return typeof this.content !== "string" || !this.author;
      }
      get member() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.members.resolve(this.author)) ?? null;
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get editedAt() {
        return this.editedTimestamp && new Date(this.editedTimestamp);
      }
      get guild() {
        var _a;
        return this.client.guilds.resolve(this.guildId) ?? ((_a = this.channel) == null ? void 0 : _a.guild) ?? null;
      }
      get hasThread() {
        return this.flags.has(MessageFlags.HasThread);
      }
      get thread() {
        var _a, _b;
        return ((_b = (_a = this.channel) == null ? void 0 : _a.threads) == null ? void 0 : _b.resolve(this.id)) ?? null;
      }
      get url() {
        return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
      }
      get cleanContent() {
        return this.content != null ? cleanContent(this.content, this.channel) : null;
      }
      createReactionCollector(options = {}) {
        return new ReactionCollector(this, options);
      }
      awaitReactions(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createReactionCollector(options);
          collector.once("end", (reactions, reason) => {
            var _a;
            if ((_a = options.errors) == null ? void 0 : _a.includes(reason))
              reject(reactions);
            else
              resolve(reactions);
          });
        });
      }
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionType: InteractionType.MessageComponent,
          message: this
        });
      }
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      get editable() {
        var _a, _b;
        const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || ((_a = this.channel) == null ? void 0 : _a.viewable)));
        if ((_b = this.channel) == null ? void 0 : _b.isThread()) {
          return precheck && !this.channel.locked;
        }
        return precheck;
      }
      get deletable() {
        var _a, _b;
        if (!this.guild) {
          return this.author.id === this.client.user.id;
        }
        if (!((_a = this.channel) == null ? void 0 : _a.viewable)) {
          return false;
        }
        const permissions2 = (_b = this.channel) == null ? void 0 : _b.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        if (permissions2.has(PermissionFlagsBits4.Administrator, false))
          return true;
        return Boolean(
          this.author.id === this.client.user.id || permissions2.has(PermissionFlagsBits4.ManageMessages, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now()
        );
      }
      get pinnable() {
        var _a;
        const { channel } = this;
        return Boolean(
          !this.system && (!this.guild || (channel == null ? void 0 : channel.viewable) && ((_a = channel == null ? void 0 : channel.permissionsFor(this.client.user)) == null ? void 0 : _a.has(PermissionFlagsBits4.ManageMessages, false)))
        );
      }
      async fetchReference() {
        if (!this.reference)
          throw new DiscordjsError2(ErrorCodes2.MessageReferenceMissing);
        const { channelId, messageId } = this.reference;
        const channel = this.client.channels.resolve(channelId);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        const message = await channel.messages.fetch(messageId);
        return message;
      }
      get crosspostable() {
        var _a;
        const bitfield = PermissionFlagsBits4.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField5.DefaultBit : PermissionFlagsBits4.ManageMessages);
        const { channel } = this;
        return Boolean(
          (channel == null ? void 0 : channel.type) === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && ((_a = channel.permissionsFor(this.client.user)) == null ? void 0 : _a.has(bitfield, false))
        );
      }
      edit(options) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.edit(this, options);
      }
      crosspost() {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.crosspost(this.id);
      }
      async pin(reason) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.pin(this.id, reason);
        return this;
      }
      async unpin(reason) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.unpin(this.id, reason);
        return this;
      }
      async react(emoji) {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.react(this.id, emoji);
        return this.client.actions.MessageReactionAdd.handle(
          {
            user: this.client.user,
            channel: this.channel,
            message: this,
            emoji: resolvePartialEmoji(emoji)
          },
          true
        ).reaction;
      }
      async delete() {
        if (!this.channel)
          throw new DiscordjsError2(ErrorCodes2.ChannelNotCached);
        await this.channel.messages.delete(this.id);
        return this;
      }
      reply(options) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        let data;
        if (options instanceof MessagePayload) {
          data = options;
        } else {
          data = MessagePayload.create(this, options, {
            reply: {
              messageReference: this,
              failIfNotExists: (options == null ? void 0 : options.failIfNotExists) ?? this.client.options.failIfNotExists
            }
          });
        }
        return this.channel.send(data);
      }
      startThread(options = {}) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.MessageThreadParent));
        }
        if (this.hasThread)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.MessageExistingThread));
        return this.channel.threads.create({ ...options, startMessage: this });
      }
      fetch(force = true) {
        if (!this.channel)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ChannelNotCached));
        return this.channel.messages.fetch({ message: this.id, force });
      }
      fetchWebhook() {
        if (!this.webhookId)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.WebhookMessage));
        if (this.webhookId === this.applicationId)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.WebhookApplication));
        return this.client.fetchWebhook(this.webhookId);
      }
      suppressEmbeds(suppress = true) {
        const flags = new MessageFlagsBitField(this.flags.bitfield);
        if (suppress) {
          flags.add(MessageFlags.SuppressEmbeds);
        } else {
          flags.remove(MessageFlags.SuppressEmbeds);
        }
        return this.edit({ flags });
      }
      removeAttachments() {
        return this.edit({ attachments: [] });
      }
      resolveComponent(customId) {
        return this.components.flatMap((row) => row.components).find((component) => component.customId === customId) ?? null;
      }
      equals(message, rawData) {
        if (!message)
          return false;
        const embedUpdate = !message.author && !message.attachments;
        if (embedUpdate)
          return this.id === message.id && this.embeds.length === message.embeds.length;
        let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
        if (equal && rawData) {
          equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
        }
        return equal;
      }
      inGuild() {
        return Boolean(this.guildId);
      }
      toString() {
        return this.content;
      }
      toJSON() {
        return super.toJSON({
          channel: "channelId",
          author: "authorId",
          groupActivityApplication: "groupActivityApplicationId",
          guild: "guildId",
          cleanContent: true,
          member: false,
          reactions: false
        });
      }
    };
    exports2.Message = Message;
  }
});

// ../../node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS({
  "../../node_modules/discord.js/src/structures/Webhook.js"(exports2, module2) {
    "use strict";
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { lazy } = require_dist2();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes3, WebhookType } = require_v106();
    var MessagePayload = require_MessagePayload();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var getMessage = lazy(() => require_Message().Message);
    var Webhook2 = class {
      constructor(client, data) {
        Object.defineProperty(this, "client", { value: client });
        if (data)
          this._patch(data);
      }
      _patch(data) {
        var _a, _b, _c, _d;
        if ("name" in data) {
          this.name = data.name;
        }
        Object.defineProperty(this, "token", { value: data.token ?? null, writable: true, configurable: true });
        if ("avatar" in data) {
          this.avatar = data.avatar;
        }
        this.id = data.id;
        if ("type" in data) {
          this.type = data.type;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("user" in data) {
          this.owner = ((_a = this.client.users) == null ? void 0 : _a._add(data.user)) ?? data.user;
        } else {
          this.owner ?? (this.owner = null);
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        } else {
          this.applicationId ?? (this.applicationId = null);
        }
        if ("source_guild" in data) {
          this.sourceGuild = ((_b = this.client.guilds) == null ? void 0 : _b.resolve(data.source_guild.id)) ?? data.source_guild;
        } else {
          this.sourceGuild ?? (this.sourceGuild = null);
        }
        if ("source_channel" in data) {
          this.sourceChannel = ((_d = this.client.channels) == null ? void 0 : _d.resolve((_c = data.source_channel) == null ? void 0 : _c.id)) ?? data.source_channel;
        } else {
          this.sourceChannel ?? (this.sourceChannel = null);
        }
      }
      async send(options) {
        var _a;
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveBody();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveBody();
        }
        const query = makeURLSearchParams2({
          wait: true,
          thread_id: messagePayload.options.threadId
        });
        const { body, files } = await messagePayload.resolveFiles();
        const d = await this.client.rest.post(Routes3.webhook(this.id, this.token), { body, files, query, auth: false });
        if (!this.client.channels)
          return d;
        return ((_a = this.client.channels.cache.get(d.channel_id)) == null ? void 0 : _a.messages._add(d, false)) ?? new (getMessage())(this.client, d);
      }
      async sendSlackMessage(body) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        const data = await this.client.rest.post(Routes3.webhookPlatform(this.id, this.token, "slack"), {
          query: makeURLSearchParams2({ wait: true }),
          auth: false,
          body
        });
        return data.toString() === "ok";
      }
      async edit({ name = this.name, avatar, channel, reason }) {
        if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        channel && (channel = channel.id ?? channel);
        const data = await this.client.rest.patch(Routes3.webhook(this.id, channel ? void 0 : this.token), {
          body: { name, avatar, channel_id: channel },
          reason,
          auth: !this.token || Boolean(channel)
        });
        this.name = data.name;
        this.avatar = data.avatar;
        this.channelId = data.channel_id;
        return this;
      }
      async fetchMessage(message, { threadId } = {}) {
        var _a;
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        const data = await this.client.rest.get(Routes3.webhookMessage(this.id, this.token, message), {
          query: threadId ? makeURLSearchParams2({ thread_id: threadId }) : void 0,
          auth: false
        });
        if (!this.client.channels)
          return data;
        return ((_a = this.client.channels.cache.get(data.channel_id)) == null ? void 0 : _a.messages._add(data, false)) ?? new (getMessage())(this.client, data);
      }
      async editMessage(message, options) {
        var _a;
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body, files } = await messagePayload.resolveBody().resolveFiles();
        const d = await this.client.rest.patch(
          Routes3.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id),
          {
            body,
            files,
            query: messagePayload.options.threadId ? makeURLSearchParams2({ thread_id: messagePayload.options.threadId }) : void 0,
            auth: false
          }
        );
        const channelManager = this.client.channels;
        if (!channelManager)
          return d;
        const messageManager = (_a = channelManager.cache.get(d.channel_id)) == null ? void 0 : _a.messages;
        if (!messageManager)
          return new (getMessage())(this.client, d);
        const existing = messageManager.cache.get(d.id);
        if (!existing)
          return messageManager._add(d);
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      async delete(reason) {
        await this.client.rest.delete(Routes3.webhook(this.id, this.token), { reason, auth: !this.token });
      }
      async deleteMessage(message, threadId) {
        if (!this.token)
          throw new DiscordjsError2(ErrorCodes2.WebhookTokenUnavailable);
        await this.client.rest.delete(
          Routes3.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id),
          {
            query: threadId ? makeURLSearchParams2({ thread_id: threadId }) : void 0,
            auth: false
          }
        );
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get url() {
        return this.client.options.rest.api + Routes3.webhook(this.id, this.token);
      }
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
      }
      isUserCreated() {
        return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
      }
      isApplicationCreated() {
        return this.type === WebhookType.Application;
      }
      isChannelFollower() {
        return this.type === WebhookType.ChannelFollower;
      }
      isIncoming() {
        return this.type === WebhookType.Incoming;
      }
      static applyToClass(structure, ignore = []) {
        for (const prop of [
          "send",
          "sendSlackMessage",
          "fetchMessage",
          "edit",
          "editMessage",
          "delete",
          "deleteMessage",
          "createdTimestamp",
          "createdAt",
          "url"
        ]) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook2.prototype, prop));
        }
      }
    };
    module2.exports = Webhook2;
  }
});

// ../../node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS({
  "../../node_modules/discord.js/src/client/WebhookClient.js"(exports2, module2) {
    "use strict";
    var BaseClient2 = require_BaseClient();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Webhook2 = require_Webhook();
    var { parseWebhookURL } = require_Util();
    var WebhookClient = class extends BaseClient2 {
      constructor(data, options) {
        super(options);
        Object.defineProperty(this, "client", { value: this });
        let { id, token } = data;
        if ("url" in data) {
          const parsed = parseWebhookURL(data.url);
          if (!parsed) {
            throw new DiscordjsError2(ErrorCodes2.WebhookURLInvalid);
          }
          ({ id, token } = parsed);
        }
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      send() {
      }
      fetchMessage() {
      }
      editMessage() {
      }
      sendSlackMessage() {
      }
      edit() {
      }
      delete() {
      }
      deleteMessage() {
      }
      get createdTimestamp() {
      }
      get createdAt() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(WebhookClient);
    module2.exports = WebhookClient;
  }
});

// ../../node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS({
  "../../node_modules/discord.js/src/structures/VoiceState.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes3 } = require_v106();
    var Base = require_Base();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var VoiceState = class extends Base {
      constructor(guild, data) {
        super(guild.client);
        this.guild = guild;
        this.id = data.user_id;
        this._patch(data);
      }
      _patch(data) {
        if ("deaf" in data) {
          this.serverDeaf = data.deaf;
        } else {
          this.serverDeaf ?? (this.serverDeaf = null);
        }
        if ("mute" in data) {
          this.serverMute = data.mute;
        } else {
          this.serverMute ?? (this.serverMute = null);
        }
        if ("self_deaf" in data) {
          this.selfDeaf = data.self_deaf;
        } else {
          this.selfDeaf ?? (this.selfDeaf = null);
        }
        if ("self_mute" in data) {
          this.selfMute = data.self_mute;
        } else {
          this.selfMute ?? (this.selfMute = null);
        }
        if ("self_video" in data) {
          this.selfVideo = data.self_video;
        } else {
          this.selfVideo ?? (this.selfVideo = null);
        }
        if ("session_id" in data) {
          this.sessionId = data.session_id;
        } else {
          this.sessionId ?? (this.sessionId = null);
        }
        if ("self_video" in data) {
          this.streaming = data.self_stream ?? false;
        } else {
          this.streaming ?? (this.streaming = null);
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        } else {
          this.channelId ?? (this.channelId = null);
        }
        if ("suppress" in data) {
          this.suppress = data.suppress;
        } else {
          this.suppress ?? (this.suppress = null);
        }
        if ("request_to_speak_timestamp" in data) {
          this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
        } else {
          this.requestToSpeakTimestamp ?? (this.requestToSpeakTimestamp = null);
        }
        return this;
      }
      get member() {
        return this.guild.members.cache.get(this.id) ?? null;
      }
      get channel() {
        return this.guild.channels.cache.get(this.channelId) ?? null;
      }
      get deaf() {
        return this.serverDeaf || this.selfDeaf;
      }
      get mute() {
        return this.serverMute || this.selfMute;
      }
      setMute(mute = true, reason) {
        return this.guild.members.edit(this.id, { mute, reason });
      }
      setDeaf(deaf = true, reason) {
        return this.guild.members.edit(this.id, { deaf, reason });
      }
      disconnect(reason) {
        return this.setChannel(null, reason);
      }
      setChannel(channel, reason) {
        return this.guild.members.edit(this.id, { channel, reason });
      }
      async edit(data) {
        var _a;
        if (((_a = this.channel) == null ? void 0 : _a.type) !== ChannelType.GuildStageVoice)
          throw new DiscordjsError2(ErrorCodes2.VoiceNotStageChannel);
        const target = this.client.user.id === this.id ? "@me" : this.id;
        if (target !== "@me" && typeof data.requestToSpeak !== "undefined") {
          throw new DiscordjsError2(ErrorCodes2.VoiceStateNotOwn);
        }
        if (!["boolean", "undefined"].includes(typeof data.requestToSpeak)) {
          throw new DiscordjsTypeError2(ErrorCodes2.VoiceStateInvalidType, "requestToSpeak");
        }
        if (!["boolean", "undefined"].includes(typeof data.suppressed)) {
          throw new DiscordjsTypeError2(ErrorCodes2.VoiceStateInvalidType, "suppressed");
        }
        await this.client.rest.patch(Routes3.guildVoiceState(this.guild.id, target), {
          body: {
            channel_id: this.channelId,
            request_to_speak_timestamp: data.requestToSpeak ? new Date().toISOString() : data.requestToSpeak === false ? null : void 0,
            suppress: data.suppressed
          }
        });
        return this;
      }
      setRequestToSpeak(requestToSpeak = true) {
        return this.edit({ requestToSpeak });
      }
      setSuppressed(suppressed = true) {
        return this.edit({ suppressed });
      }
      toJSON() {
        return super.toJSON({
          id: true,
          serverDeaf: true,
          serverMute: true,
          selfDeaf: true,
          selfMute: true,
          sessionId: true,
          channelId: "channel"
        });
      }
    };
    module2.exports = VoiceState;
  }
});

// ../../node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildMemberRoleManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3 } = require_v106();
    var DataManager = require_DataManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Role } = require_Role();
    var GuildMemberRoleManager = class extends DataManager {
      constructor(member) {
        super(member.client, Role);
        this.member = member;
        this.guild = member.guild;
      }
      get cache() {
        const everyone = this.guild.roles.everyone;
        return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
      }
      get hoist() {
        const hoistedRoles = this.cache.filter((role) => role.hoist);
        if (!hoistedRoles.size)
          return null;
        return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      get icon() {
        const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
        if (!iconRoles.size)
          return null;
        return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      get color() {
        const coloredRoles = this.cache.filter((role) => role.color);
        if (!coloredRoles.size)
          return null;
        return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
      }
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
      get premiumSubscriberRole() {
        return this.cache.find((role) => {
          var _a;
          return (_a = role.tags) == null ? void 0 : _a.premiumSubscriberRole;
        }) ?? null;
      }
      get botRole() {
        if (!this.member.user.bot)
          return null;
        return this.cache.find((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.botId) === this.member.user.id;
        }) ?? null;
      }
      async add(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "roles",
              "Role, Snowflake or Array or Collection of Roles or Snowflakes"
            );
          }
          await this.client.rest.put(Routes3.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
          const clone = this.member._clone();
          clone._roles = [...this.cache.keys(), roleOrRoles];
          return clone;
        }
      }
      async remove(roleOrRoles, reason) {
        if (roleOrRoles instanceof Collection2 || Array.isArray(roleOrRoles)) {
          const resolvedRoles = [];
          for (const role of roleOrRoles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
          return this.set(newRoles, reason);
        } else {
          roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
          if (roleOrRoles === null) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "roles",
              "Role, Snowflake or Array or Collection of Roles or Snowflakes"
            );
          }
          await this.client.rest.delete(Routes3.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
          const clone = this.member._clone();
          const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
          clone._roles = [...newRoles.keys()];
          return clone;
        }
      }
      set(roles, reason) {
        return this.member.edit({ roles, reason });
      }
      clone() {
        const clone = new this.constructor(this.member);
        clone.member._roles = [...this.cache.keys()];
        return clone;
      }
    };
    module2.exports = GuildMemberRoleManager;
  }
});

// ../../node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildMember.js"(exports2) {
    "use strict";
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var Base = require_Base();
    var VoiceState = require_VoiceState();
    var TextBasedChannel = require_TextBasedChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildMemberRoleManager = require_GuildMemberRoleManager();
    var PermissionsBitField5 = require_PermissionsBitField();
    var GuildMember = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.joinedTimestamp = null;
        this.premiumSinceTimestamp = null;
        this.nickname = null;
        this.pending = null;
        this.communicationDisabledUntilTimestamp = null;
        this._roles = [];
        if (data)
          this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("nick" in data)
          this.nickname = data.nick;
        if ("avatar" in data) {
          this.avatar = data.avatar;
        } else if (typeof this.avatar !== "string") {
          this.avatar = null;
        }
        if ("joined_at" in data)
          this.joinedTimestamp = Date.parse(data.joined_at);
        if ("premium_since" in data) {
          this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
        }
        if ("roles" in data)
          this._roles = data.roles;
        if ("pending" in data) {
          this.pending = data.pending;
        } else if (!this.partial) {
          this.pending ?? (this.pending = false);
        }
        if ("communication_disabled_until" in data) {
          this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
        }
      }
      _clone() {
        const clone = super._clone();
        clone._roles = this._roles.slice();
        return clone;
      }
      get partial() {
        return this.joinedTimestamp === null;
      }
      get roles() {
        return new GuildMemberRoleManager(this);
      }
      get voice() {
        return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
      }
      avatarURL(options = {}) {
        return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
      }
      displayAvatarURL(options) {
        return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
      }
      get joinedAt() {
        return this.joinedTimestamp && new Date(this.joinedTimestamp);
      }
      get communicationDisabledUntil() {
        return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
      }
      get premiumSince() {
        return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
      }
      get presence() {
        return this.guild.presences.resolve(this.id);
      }
      get displayColor() {
        var _a;
        return ((_a = this.roles.color) == null ? void 0 : _a.color) ?? 0;
      }
      get displayHexColor() {
        var _a;
        return ((_a = this.roles.color) == null ? void 0 : _a.hexColor) ?? "#000000";
      }
      get id() {
        return this.user.id;
      }
      get dmChannel() {
        return this.client.users.dmChannel(this.id);
      }
      get displayName() {
        return this.nickname ?? this.user.username;
      }
      get permissions() {
        if (this.user.id === this.guild.ownerId)
          return new PermissionsBitField5(PermissionsBitField5.All).freeze();
        return new PermissionsBitField5(this.roles.cache.map((role) => role.permissions)).freeze();
      }
      get manageable() {
        if (this.user.id === this.guild.ownerId)
          return false;
        if (this.user.id === this.client.user.id)
          return false;
        if (this.client.user.id === this.guild.ownerId)
          return true;
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
      }
      get kickable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits4.KickMembers);
      }
      get bannable() {
        if (!this.guild.members.me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits4.BanMembers);
      }
      get moderatable() {
        var _a;
        return !this.permissions.has(PermissionFlagsBits4.Administrator) && this.manageable && (((_a = this.guild.members.me) == null ? void 0 : _a.permissions.has(PermissionFlagsBits4.ModerateMembers)) ?? false);
      }
      isCommunicationDisabled() {
        return this.communicationDisabledUntilTimestamp > Date.now();
      }
      permissionsIn(channel) {
        channel = this.guild.channels.resolve(channel);
        if (!channel)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        return channel.permissionsFor(this);
      }
      edit(data) {
        return this.guild.members.edit(this, data);
      }
      setNickname(nick, reason) {
        return this.edit({ nick, reason });
      }
      createDM(force = false) {
        return this.user.createDM(force);
      }
      deleteDM() {
        return this.user.deleteDM();
      }
      kick(reason) {
        return this.guild.members.kick(this, reason);
      }
      ban(options) {
        return this.guild.members.ban(this, options);
      }
      disableCommunicationUntil(communicationDisabledUntil, reason) {
        return this.edit({ communicationDisabledUntil, reason });
      }
      timeout(timeout, reason) {
        return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
      }
      fetch(force = true) {
        return this.guild.members.fetch({ user: this.id, cache: true, force });
      }
      equals(member) {
        return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
      }
      toString() {
        return this.user.toString();
      }
      toJSON() {
        const json = super.toJSON({
          guild: "guildId",
          user: "userId",
          displayName: true,
          roles: true
        });
        json.avatarURL = this.avatarURL();
        json.displayAvatarURL = this.displayAvatarURL();
        return json;
      }
      send() {
      }
    };
    TextBasedChannel.applyToClass(GuildMember);
    exports2.GuildMember = GuildMember;
  }
});

// ../../node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS({
  "../../node_modules/discord.js/src/managers/MessageManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Message } = require_Message();
    var MessagePayload = require_MessagePayload();
    var { resolvePartialEmoji } = require_Util();
    var MessageManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, Message, iterable);
        this.channel = channel;
      }
      _add(data, cache) {
        return super._add(data, cache);
      }
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { message, cache, force } = options;
        const resolvedMessage = this.resolveId(message ?? options);
        if (resolvedMessage)
          return this._fetchSingle({ message: resolvedMessage, cache, force });
        return this._fetchMany(options);
      }
      async _fetchSingle({ message, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(message);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.channelMessage(this.channel.id, message));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes3.channelMessages(this.channel.id), {
          query: makeURLSearchParams2(options)
        });
        return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection2());
      }
      async fetchPinned(cache = true) {
        const data = await this.client.rest.get(Routes3.channelPins(this.channel.id));
        const messages = new Collection2();
        for (const message of data)
          messages.set(message.id, this._add(message, cache));
        return messages;
      }
      async edit(message, options) {
        const messageId = this.resolveId(message);
        if (!messageId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
        const d = await this.client.rest.patch(Routes3.channelMessage(this.channel.id, messageId), { body, files });
        const existing = this.cache.get(messageId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      async crosspost(message) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        const data = await this.client.rest.post(Routes3.channelMessageCrosspost(this.channel.id, message));
        return this.cache.get(data.id) ?? this._add(data);
      }
      async pin(message, reason) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.put(Routes3.channelPin(this.channel.id, message), { reason });
      }
      async unpin(message, reason) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.delete(Routes3.channelPin(this.channel.id, message), { reason });
      }
      async react(message, emoji) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        emoji = resolvePartialEmoji(emoji);
        if (!emoji)
          throw new DiscordjsTypeError2(ErrorCodes2.EmojiType, "emoji", "EmojiIdentifierResolvable");
        const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
        await this.client.rest.put(Routes3.channelMessageOwnReaction(this.channel.id, message, emojiId));
      }
      async delete(message) {
        message = this.resolveId(message);
        if (!message)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "message", "MessageResolvable");
        await this.client.rest.delete(Routes3.channelMessage(this.channel.id, message));
      }
    };
    module2.exports = MessageManager;
  }
});

// ../../node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS({
  "../../node_modules/discord.js/src/structures/InteractionWebhook.js"(exports2, module2) {
    "use strict";
    var Webhook2 = require_Webhook();
    var InteractionWebhook = class {
      constructor(client, id, token) {
        Object.defineProperty(this, "client", { value: client });
        this.id = id;
        Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
      }
      send() {
      }
      fetchMessage() {
      }
      editMessage() {
      }
      deleteMessage() {
      }
      get url() {
      }
    };
    Webhook2.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
    module2.exports = InteractionWebhook;
  }
});

// ../../node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS({
  "../../node_modules/discord.js/src/structures/MessagePayload.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer5 } = require("buffer");
    var { isJSONEncodable } = require_dist7();
    var { lazy } = require_dist2();
    var { MessageFlags } = require_v106();
    var ActionRowBuilder = require_ActionRowBuilder();
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var MessageFlagsBitField = require_MessageFlagsBitField();
    var { basename, verifyString } = require_Util();
    var getBaseInteraction = lazy(() => require_BaseInteraction());
    var MessagePayload = class {
      constructor(target, options) {
        this.target = target;
        this.options = options;
        this.body = null;
        this.files = null;
      }
      get isWebhook() {
        const Webhook2 = require_Webhook();
        const WebhookClient = require_WebhookClient();
        return this.target instanceof Webhook2 || this.target instanceof WebhookClient;
      }
      get isUser() {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        return this.target instanceof User || this.target instanceof GuildMember;
      }
      get isMessage() {
        const { Message } = require_Message();
        return this.target instanceof Message;
      }
      get isMessageManager() {
        const MessageManager = require_MessageManager();
        return this.target instanceof MessageManager;
      }
      get isInteraction() {
        const BaseInteraction = getBaseInteraction();
        const InteractionWebhook = require_InteractionWebhook();
        return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
      }
      makeContent() {
        let content;
        if (this.options.content === null) {
          content = "";
        } else if (typeof this.options.content !== "undefined") {
          content = verifyString(this.options.content, DiscordjsRangeError2, ErrorCodes2.MessageContentType, true);
        }
        return content;
      }
      resolveBody() {
        var _a, _b, _c, _d, _e;
        if (this.body)
          return this;
        const isInteraction = this.isInteraction;
        const isWebhook = this.isWebhook;
        const content = this.makeContent();
        const tts = Boolean(this.options.tts);
        let nonce;
        if (typeof this.options.nonce !== "undefined") {
          nonce = this.options.nonce;
          if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
            throw new DiscordjsRangeError2(ErrorCodes2.MessageNonceType);
          }
        }
        const components = (_a = this.options.components) == null ? void 0 : _a.map((c) => (isJSONEncodable(c) ? c : new ActionRowBuilder(c)).toJSON());
        let username;
        let avatarURL;
        let threadName;
        if (isWebhook) {
          username = this.options.username ?? this.target.name;
          if (this.options.avatarURL)
            avatarURL = this.options.avatarURL;
          if (this.options.threadName)
            threadName = this.options.threadName;
        }
        let flags;
        if (typeof this.options.flags !== "undefined" || this.isMessage && typeof this.options.reply === "undefined" || this.isMessageManager) {
          flags = this.options.flags != null ? new MessageFlagsBitField(this.options.flags).bitfield : (_b = this.target.flags) == null ? void 0 : _b.bitfield;
        }
        if (isInteraction && this.options.ephemeral) {
          flags |= MessageFlags.Ephemeral;
        }
        let allowedMentions = typeof this.options.allowedMentions === "undefined" ? this.target.client.options.allowedMentions : this.options.allowedMentions;
        if (typeof (allowedMentions == null ? void 0 : allowedMentions.repliedUser) !== "undefined") {
          allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
          delete allowedMentions.repliedUser;
        }
        let message_reference;
        if (typeof this.options.reply === "object") {
          const reference = this.options.reply.messageReference;
          const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
          if (message_id) {
            message_reference = {
              message_id,
              fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
            };
          }
        }
        const attachments = (_c = this.options.files) == null ? void 0 : _c.map((file, index) => ({
          id: index.toString(),
          description: file.description
        }));
        if (Array.isArray(this.options.attachments)) {
          this.options.attachments.push(...attachments ?? []);
        } else {
          this.options.attachments = attachments;
        }
        this.body = {
          content,
          tts,
          nonce,
          embeds: (_d = this.options.embeds) == null ? void 0 : _d.map(
            (embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)
          ),
          components,
          username,
          avatar_url: avatarURL,
          allowed_mentions: typeof content === "undefined" && typeof message_reference === "undefined" ? void 0 : allowedMentions,
          flags,
          message_reference,
          attachments: this.options.attachments,
          sticker_ids: (_e = this.options.stickers) == null ? void 0 : _e.map((sticker) => sticker.id ?? sticker),
          thread_name: threadName
        };
        return this;
      }
      async resolveFiles() {
        var _a;
        if (this.files)
          return this;
        this.files = await Promise.all(((_a = this.options.files) == null ? void 0 : _a.map((file) => this.constructor.resolveFile(file))) ?? []);
        return this;
      }
      static async resolveFile(fileLike) {
        let attachment;
        let name;
        const findName = (thing) => {
          if (typeof thing === "string") {
            return basename(thing);
          }
          if (thing.path) {
            return basename(thing.path);
          }
          return "file.jpg";
        };
        const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer5 || typeof fileLike.pipe === "function";
        if (ownAttachment) {
          attachment = fileLike;
          name = findName(attachment);
        } else {
          attachment = fileLike.attachment;
          name = fileLike.name ?? findName(attachment);
        }
        const { data, contentType } = await DataResolver2.resolveFile(attachment);
        return { data, name, contentType };
      }
      static create(target, options, extra = {}) {
        return new this(
          target,
          typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra }
        );
      }
    };
    module2.exports = MessagePayload;
  }
});

// ../../node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var { InteractionType, Routes: Routes3 } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var InteractionCollector = require_InteractionCollector();
    var MessageCollector = require_MessageCollector();
    var MessagePayload = require_MessagePayload();
    var TextBasedChannel = class {
      constructor() {
        this.messages = new MessageManager(this);
        this.lastMessageId = null;
        this.lastPinTimestamp = null;
      }
      get lastMessage() {
        return this.messages.resolve(this.lastMessageId);
      }
      get lastPinAt() {
        return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
      }
      async send(options) {
        const User = require_User();
        const { GuildMember } = require_GuildMember();
        if (this instanceof User || this instanceof GuildMember) {
          const dm = await this.createDM();
          return dm.send(options);
        }
        let messagePayload;
        if (options instanceof MessagePayload) {
          messagePayload = options.resolveBody();
        } else {
          messagePayload = MessagePayload.create(this, options).resolveBody();
        }
        const { body, files } = await messagePayload.resolveFiles();
        const d = await this.client.rest.post(Routes3.channelMessages(this.id), { body, files });
        return this.messages.cache.get(d.id) ?? this.messages._add(d);
      }
      async sendTyping() {
        await this.client.rest.post(Routes3.channelTyping(this.id));
      }
      createMessageCollector(options = {}) {
        return new MessageCollector(this, options);
      }
      awaitMessages(options = {}) {
        return new Promise((resolve, reject) => {
          const collector = this.createMessageCollector(options);
          collector.once("end", (collection, reason) => {
            var _a;
            if ((_a = options.errors) == null ? void 0 : _a.includes(reason)) {
              reject(collection);
            } else {
              resolve(collection);
            }
          });
        });
      }
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionType: InteractionType.MessageComponent,
          channel: this
        });
      }
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      async bulkDelete(messages, filterOld = false) {
        if (Array.isArray(messages) || messages instanceof Collection2) {
          let messageIds = messages instanceof Collection2 ? [...messages.keys()] : messages.map((m) => m.id ?? m);
          if (filterOld) {
            messageIds = messageIds.filter((id) => Date.now() - DiscordSnowflake.timestampFrom(id) < 12096e5);
          }
          if (messageIds.length === 0)
            return new Collection2();
          if (messageIds.length === 1) {
            const message = this.client.actions.MessageDelete.getMessage(
              {
                message_id: messageIds[0]
              },
              this
            );
            await this.client.rest.delete(Routes3.channelMessage(this.id, messageIds[0]));
            return message ? new Collection2([[message.id, message]]) : new Collection2();
          }
          await this.client.rest.post(Routes3.channelBulkDelete(this.id), { body: { messages: messageIds } });
          return messageIds.reduce(
            (col, id) => col.set(
              id,
              this.client.actions.MessageDeleteBulk.getMessage(
                {
                  message_id: id
                },
                this
              )
            ),
            new Collection2()
          );
        }
        if (!isNaN(messages)) {
          const msgs = await this.messages.fetch({ limit: messages });
          return this.bulkDelete(msgs, filterOld);
        }
        throw new DiscordjsTypeError2(ErrorCodes2.MessageBulkDeleteType);
      }
      fetchWebhooks() {
        return this.guild.channels.fetchWebhooks(this.id);
      }
      createWebhook(options) {
        return this.guild.channels.createWebhook({ channel: this.id, ...options });
      }
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
      setNSFW(nsfw = true, reason) {
        return this.edit({ nsfw, reason });
      }
      static applyToClass(structure, full = false, ignore = []) {
        const props = ["send"];
        if (full) {
          props.push(
            "lastMessage",
            "lastPinAt",
            "bulkDelete",
            "sendTyping",
            "createMessageCollector",
            "awaitMessages",
            "createMessageComponentCollector",
            "awaitMessageComponent",
            "fetchWebhooks",
            "createWebhook",
            "setRateLimitPerUser",
            "setNSFW"
          );
        }
        for (const prop of props) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop)
          );
        }
      }
    };
    module2.exports = TextBasedChannel;
    var MessageManager = require_MessageManager();
  }
});

// ../../node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/DMChannel.js"(exports2, module2) {
    "use strict";
    var { userMention } = require_dist7();
    var { ChannelType } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var Partials = require_Partials();
    var DMChannel = class extends BaseChannel {
      constructor(client, data) {
        super(client, data);
        this.type = ChannelType.DM;
        this.messages = new MessageManager(this);
      }
      _patch(data) {
        super._patch(data);
        if (data.recipients) {
          const recipient = data.recipients[0];
          this.recipientId = recipient.id;
          if ("username" in recipient || this.client.options.partials.includes(Partials.Users)) {
            this.client.users._add(recipient);
          }
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
      }
      get partial() {
        return typeof this.lastMessageId === "undefined";
      }
      get recipient() {
        return this.client.users.resolve(this.recipientId);
      }
      fetch(force = true) {
        return this.client.users.createDM(this.recipientId, { force });
      }
      toString() {
        return userMention(this.recipientId);
      }
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
    };
    TextBasedChannel.applyToClass(DMChannel, true, [
      "bulkDelete",
      "fetchWebhooks",
      "createWebhook",
      "setRateLimitPerUser",
      "setNSFW"
    ]);
    module2.exports = DMChannel;
  }
});

// ../../node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js"(exports2, module2) {
    "use strict";
    var BitField = require_BitField();
    var ThreadMemberFlagsBitField = class extends BitField {
    };
    __publicField(ThreadMemberFlagsBitField, "Flags", {});
    module2.exports = ThreadMemberFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS({
  "../../node_modules/discord.js/src/structures/ThreadMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
    var ThreadMember = class extends Base {
      constructor(thread, data) {
        super(thread.client);
        this.thread = thread;
        this.joinedTimestamp = null;
        this.flags = null;
        this.id = data.user_id;
        this._patch(data);
      }
      _patch(data) {
        if ("join_timestamp" in data)
          this.joinedTimestamp = Date.parse(data.join_timestamp);
        if ("flags" in data)
          this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
      }
      get partial() {
        return this.flags === null;
      }
      get guildMember() {
        return this.thread.guild.members.resolve(this.id);
      }
      get joinedAt() {
        return this.joinedTimestamp && new Date(this.joinedTimestamp);
      }
      get user() {
        return this.client.users.resolve(this.id);
      }
      get manageable() {
        return !this.thread.archived && this.thread.editable;
      }
      async remove(reason) {
        await this.thread.members.remove(this.id, reason);
        return this;
      }
    };
    module2.exports = ThreadMember;
  }
});

// ../../node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ThreadMemberManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ThreadMember = require_ThreadMember();
    var ThreadMemberManager = class extends CachedManager {
      constructor(thread, iterable) {
        super(thread.client, ThreadMember, iterable);
        this.thread = thread;
      }
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (cache)
          existing == null ? void 0 : existing._patch(data);
        if (existing)
          return existing;
        const member = new ThreadMember(this.thread, data);
        if (cache)
          this.cache.set(data.user_id, member);
        return member;
      }
      fetchMe(options) {
        return this.fetch({ ...options, member: this.client.user.id });
      }
      get me() {
        return this.resolve(this.client.user.id);
      }
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable)
          return super.resolve(userResolvable);
        return null;
      }
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      async add(member, reason) {
        const id = member === "@me" ? member : this.client.users.resolveId(member);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "member", "UserResolvable");
        await this.client.rest.put(Routes3.threadMembers(this.thread.id, id), { reason });
        return id;
      }
      async remove(id, reason) {
        await this.client.rest.delete(Routes3.threadMembers(this.thread.id, id), { reason });
        return id;
      }
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { member, cache, force } = options;
        const resolvedMember = this.resolveId(member ?? options);
        if (resolvedMember)
          return this._fetchSingle({ member: resolvedMember, cache, force });
        return this._fetchMany(options);
      }
      async _fetchSingle({ member, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(member);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.threadMembers(this.thread.id, member));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes3.threadMembers(this.thread.id));
        return data.reduce((col, member) => col.set(member.user_id, this._add(member, options.cache)), new Collection2());
      }
    };
    module2.exports = ThreadMemberManager;
  }
});

// ../../node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/ThreadChannel.js"(exports2, module2) {
    "use strict";
    var { ChannelType, PermissionFlagsBits: PermissionFlagsBits4, Routes: Routes3 } = require_v106();
    var { BaseChannel } = require_BaseChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var { DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var MessageManager = require_MessageManager();
    var ThreadMemberManager = require_ThreadMemberManager();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var ThreadChannel = class extends BaseChannel {
      constructor(guild, data, client, fromInteraction = false) {
        super((guild == null ? void 0 : guild.client) ?? client, data, false);
        this.guild = guild;
        this.guildId = (guild == null ? void 0 : guild.id) ?? data.guild_id;
        this.messages = new MessageManager(this);
        this.members = new ThreadMemberManager(this);
        if (data)
          this._patch(data, fromInteraction);
      }
      _patch(data, partial = false) {
        super._patch(data);
        if ("name" in data) {
          this.name = data.name;
        }
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("parent_id" in data) {
          this.parentId = data.parent_id;
        } else {
          this.parentId ?? (this.parentId = null);
        }
        if ("thread_metadata" in data) {
          this.locked = data.thread_metadata.locked ?? false;
          this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
          this.archived = data.thread_metadata.archived;
          this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
          this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
          if ("create_timestamp" in data.thread_metadata) {
            this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
          }
        } else {
          this.locked ?? (this.locked = null);
          this.archived ?? (this.archived = null);
          this.autoArchiveDuration ?? (this.autoArchiveDuration = null);
          this.archiveTimestamp ?? (this.archiveTimestamp = null);
          this.invitable ?? (this.invitable = null);
        }
        this._createdTimestamp ?? (this._createdTimestamp = this.type === ChannelType.PrivateThread ? super.createdTimestamp : null);
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        } else {
          this.ownerId ?? (this.ownerId = null);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        } else {
          this.lastMessageId ?? (this.lastMessageId = null);
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        } else {
          this.lastPinTimestamp ?? (this.lastPinTimestamp = null);
        }
        if ("rate_limit_per_user" in data || !partial) {
          this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
        } else {
          this.rateLimitPerUser ?? (this.rateLimitPerUser = null);
        }
        if ("message_count" in data) {
          this.messageCount = data.message_count;
        } else {
          this.messageCount ?? (this.messageCount = null);
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        } else {
          this.memberCount ?? (this.memberCount = null);
        }
        if ("total_message_sent" in data) {
          this.totalMessageSent = data.total_message_sent;
        } else {
          this.totalMessageSent ?? (this.totalMessageSent = null);
        }
        if (data.member && this.client.user)
          this.members._add({ user_id: this.client.user.id, ...data.member });
        if (data.messages)
          for (const message of data.messages)
            this.messages._add(message);
        if ("applied_tags" in data) {
          this.appliedTags = data.applied_tags;
        } else {
          this.appliedTags ?? (this.appliedTags = []);
        }
      }
      get createdTimestamp() {
        return this._createdTimestamp;
      }
      get guildMembers() {
        return this.members.cache.mapValues((member) => member.guildMember);
      }
      get archivedAt() {
        return this.archiveTimestamp && new Date(this.archiveTimestamp);
      }
      get createdAt() {
        return this.createdTimestamp && new Date(this.createdTimestamp);
      }
      get parent() {
        return this.guild.channels.resolve(this.parentId);
      }
      async join() {
        await this.members.add("@me");
        return this;
      }
      async leave() {
        await this.members.remove("@me");
        return this;
      }
      permissionsFor(memberOrRole, checkAdmin) {
        var _a;
        return ((_a = this.parent) == null ? void 0 : _a.permissionsFor(memberOrRole, checkAdmin)) ?? null;
      }
      async fetchOwner({ cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.members.cache.get(this.ownerId);
          if (existing)
            return existing;
        }
        const members = await this.members.fetch({ cache });
        return members.get(this.ownerId) ?? null;
      }
      async fetchStarterMessage(options) {
        var _a;
        const channel = ((_a = this.parent) == null ? void 0 : _a.type) === ChannelType.GuildForum ? this : this.parent;
        return (channel == null ? void 0 : channel.messages.fetch({ message: this.id, ...options })) ?? null;
      }
      async edit(data) {
        const newData = await this.client.rest.patch(Routes3.channel(this.id), {
          body: {
            name: (data.name ?? this.name).trim(),
            archived: data.archived,
            auto_archive_duration: data.autoArchiveDuration,
            rate_limit_per_user: data.rateLimitPerUser,
            locked: data.locked,
            invitable: this.type === ChannelType.PrivateThread ? data.invitable : void 0,
            applied_tags: data.appliedTags,
            flags: "flags" in data ? ChannelFlagsBitField.resolve(data.flags) : void 0
          },
          reason: data.reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      setArchived(archived = true, reason) {
        return this.edit({ archived, reason });
      }
      setAutoArchiveDuration(autoArchiveDuration, reason) {
        return this.edit({ autoArchiveDuration, reason });
      }
      setInvitable(invitable = true, reason) {
        if (this.type !== ChannelType.PrivateThread) {
          return Promise.reject(new DiscordjsRangeError2(ErrorCodes2.ThreadInvitableType, this.type));
        }
        return this.edit({ invitable, reason });
      }
      setLocked(locked = true, reason) {
        return this.edit({ locked, reason });
      }
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
      setAppliedTags(appliedTags, reason) {
        return this.edit({ appliedTags, reason });
      }
      get joined() {
        var _a;
        return this.members.cache.has((_a = this.client.user) == null ? void 0 : _a.id);
      }
      get editable() {
        return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
      }
      get joinable() {
        var _a;
        return !this.archived && !this.joined && ((_a = this.permissionsFor(this.client.user)) == null ? void 0 : _a.has(
          this.type === ChannelType.PrivateThread ? PermissionFlagsBits4.ManageThreads : PermissionFlagsBits4.ViewChannel,
          false
        ));
      }
      get manageable() {
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        if (permissions2.has(PermissionFlagsBits4.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions2.has(PermissionFlagsBits4.ManageThreads, false);
      }
      get viewable() {
        if (this.client.user.id === this.guild.ownerId)
          return true;
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        return permissions2.has(PermissionFlagsBits4.ViewChannel, false);
      }
      get sendable() {
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        if (permissions2.has(PermissionFlagsBits4.Administrator, false))
          return true;
        return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions2.has(PermissionFlagsBits4.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
      }
      get unarchivable() {
        return this.archived && this.sendable && (!this.locked || this.manageable);
      }
      async delete(reason) {
        await this.guild.channels.delete(this.id, reason);
        return this;
      }
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
    };
    TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
    module2.exports = ThreadChannel;
  }
});

// ../../node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ThreadManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ThreadChannel = require_ThreadChannel();
    var ThreadManager = class extends CachedManager {
      constructor(channel, iterable) {
        super(channel.client, ThreadChannel, iterable);
        this.channel = channel;
      }
      _add(thread) {
        const existing = this.cache.get(thread.id);
        if (existing)
          return existing;
        this.cache.set(thread.id, thread);
        return thread;
      }
      fetch(options, { cache = true, force = false } = {}) {
        if (!options)
          return this.fetchActive(cache);
        const channel = this.client.channels.resolveId(options);
        if (channel)
          return this.client.channels.fetch(channel, cache, force);
        if (options.archived) {
          return this.fetchArchived(options.archived, cache);
        }
        return this.fetchActive(cache);
      }
      async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
        var _a, _b;
        let path = Routes3.channelThreads(this.channel.id, type);
        if (type === "private" && !fetchAll) {
          path = Routes3.channelJoinedArchivedThreads(this.channel.id);
        }
        let timestamp;
        let id;
        const query = makeURLSearchParams2({ limit });
        if (typeof before !== "undefined") {
          if (before instanceof ThreadChannel || /^\d{16,19}$/.test(String(before))) {
            id = this.resolveId(before);
            timestamp = (_b = (_a = this.resolve(before)) == null ? void 0 : _a.archivedAt) == null ? void 0 : _b.toISOString();
            const toUse = type === "private" && !fetchAll ? id : timestamp;
            if (toUse) {
              query.set("before", toUse);
            }
          } else {
            try {
              timestamp = new Date(before).toISOString();
              if (type === "public" || fetchAll) {
                query.set("before", timestamp);
              }
            } catch {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
            }
          }
        }
        const raw = await this.client.rest.get(path, { query });
        return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
      }
      async fetchActive(cache = true) {
        const raw = await this.client.rest.get(Routes3.guildActiveThreads(this.channel.guild.id));
        return this.constructor._mapThreads(raw, this.client, { parent: this.channel, cache });
      }
      static _mapThreads(rawThreads, client, { parent, guild, cache }) {
        var _a;
        const threads = rawThreads.threads.reduce((coll, raw) => {
          const thread = client.channels._add(raw, guild ?? (parent == null ? void 0 : parent.guild), { cache });
          if (parent && thread.parentId !== parent.id)
            return coll;
          return coll.set(thread.id, thread);
        }, new Collection2());
        for (const rawMember of rawThreads.members)
          (_a = client.channels.cache.get(rawMember.id)) == null ? void 0 : _a.members._add(rawMember);
        return {
          threads,
          hasMore: rawThreads.has_more ?? false
        };
      }
    };
    module2.exports = ThreadManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildTextThreadManager.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes3 } = require_v106();
    var ThreadManager = require_ThreadManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildTextThreadManager = class extends ThreadManager {
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        startMessage,
        type,
        invitable,
        reason,
        rateLimitPerUser
      } = {}) {
        let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
        let startMessageId;
        if (startMessage) {
          startMessageId = this.channel.messages.resolveId(startMessage);
          if (!startMessageId)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "startMessage", "MessageResolvable");
        } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
          resolvedType = type ?? resolvedType;
        }
        const data = await this.client.rest.post(Routes3.threads(this.channel.id, startMessageId), {
          body: {
            name,
            auto_archive_duration: autoArchiveDuration,
            type: resolvedType,
            invitable: resolvedType === ChannelType.PrivateThread ? invitable : void 0,
            rate_limit_per_user: rateLimitPerUser
          },
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildTextThreadManager;
  }
});

// ../../node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/BaseGuildTextChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var MessageManager = require_MessageManager();
    var BaseGuildTextChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new MessageManager(this);
        this.threads = new GuildTextThreadManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("nsfw" in data) {
          this.nsfw = Boolean(data.nsfw);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("last_pin_timestamp" in data) {
          this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        }
        if ("messages" in data) {
          for (const message of data.messages)
            this.messages._add(message);
        }
      }
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration, reason });
      }
      setType(type, reason) {
        return this.edit({ type, reason });
      }
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      get lastMessage() {
      }
      get lastPinAt() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
    module2.exports = BaseGuildTextChannel;
  }
});

// ../../node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/NewsChannel.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var NewsChannel = class extends BaseGuildTextChannel {
      async addFollower(channel, reason) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        await this.client.rest.post(Routes3.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
        return this;
      }
    };
    module2.exports = NewsChannel;
  }
});

// ../../node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var GuildChannel = require_GuildChannel();
    var BaseGuildVoiceChannel = class extends GuildChannel {
      _patch(data) {
        super._patch(data);
        if ("rtc_region" in data) {
          this.rtcRegion = data.rtc_region;
        }
        if ("bitrate" in data) {
          this.bitrate = data.bitrate;
        }
        if ("user_limit" in data) {
          this.userLimit = data.user_limit;
        }
      }
      get members() {
        const coll = new Collection2();
        for (const state of this.guild.voiceStates.cache.values()) {
          if (state.channelId === this.id && state.member) {
            coll.set(state.id, state.member);
          }
        }
        return coll;
      }
      get full() {
        return this.userLimit > 0 && this.members.size >= this.userLimit;
      }
      get joinable() {
        if (!this.viewable)
          return false;
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        if (permissions2.has(PermissionFlagsBits4.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions2.has(PermissionFlagsBits4.Connect, false);
      }
      setRTCRegion(rtcRegion, reason) {
        return this.edit({ rtcRegion, reason });
      }
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      fetchInvites(cache = true) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
    };
    module2.exports = BaseGuildVoiceChannel;
  }
});

// ../../node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/StageChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var StageChannel = class extends BaseGuildVoiceChannel {
      _patch(data) {
        super._patch(data);
        if ("topic" in data) {
          this.topic = data.topic;
        }
      }
      get stageInstance() {
        return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
      }
      createStageInstance(options) {
        return this.guild.stageInstances.create(this.id, options);
      }
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
    };
    module2.exports = StageChannel;
  }
});

// ../../node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/TextChannel.js"(exports2, module2) {
    "use strict";
    var BaseGuildTextChannel = require_BaseGuildTextChannel();
    var TextChannel = class extends BaseGuildTextChannel {
      _patch(data) {
        super._patch(data);
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
      }
      setRateLimitPerUser(rateLimitPerUser, reason) {
        return this.edit({ rateLimitPerUser, reason });
      }
    };
    module2.exports = TextChannel;
  }
});

// ../../node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/VoiceChannel.js"(exports2, module2) {
    "use strict";
    var { PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var MessageManager = require_MessageManager();
    var VoiceChannel = class extends BaseGuildVoiceChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.messages = new MessageManager(this);
        this.nsfw = Boolean(data.nsfw);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("video_quality_mode" in data) {
          this.videoQualityMode = data.video_quality_mode;
        } else {
          this.videoQualityMode ?? (this.videoQualityMode = null);
        }
        if ("last_message_id" in data) {
          this.lastMessageId = data.last_message_id;
        }
        if ("messages" in data) {
          for (const message of data.messages)
            this.messages._add(message);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        }
        if ("nsfw" in data) {
          this.nsfw = Boolean(data.nsfw);
        }
      }
      get joinable() {
        if (!super.joinable)
          return false;
        if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits4.MoveMembers, false))
          return false;
        return true;
      }
      get speakable() {
        const permissions2 = this.permissionsFor(this.client.user);
        if (!permissions2)
          return false;
        if (permissions2.has(PermissionFlagsBits4.Administrator, false))
          return true;
        return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions2.has(PermissionFlagsBits4.Speak, false);
      }
      setBitrate(bitrate, reason) {
        return this.edit({ bitrate, reason });
      }
      setUserLimit(userLimit, reason) {
        return this.edit({ userLimit, reason });
      }
      setVideoQualityMode(videoQualityMode, reason) {
        return this.edit({ videoQualityMode, reason });
      }
      get lastMessage() {
      }
      send() {
      }
      sendTyping() {
      }
      createMessageCollector() {
      }
      awaitMessages() {
      }
      createMessageComponentCollector() {
      }
      awaitMessageComponent() {
      }
      bulkDelete() {
      }
      fetchWebhooks() {
      }
      createWebhook() {
      }
      setRateLimitPerUser() {
      }
      setNSFW() {
      }
    };
    TextBasedChannel.applyToClass(VoiceChannel, true, ["lastPinAt"]);
    module2.exports = VoiceChannel;
  }
});

// ../../node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/DirectoryChannel.js"(exports2, module2) {
    "use strict";
    var { BaseChannel } = require_BaseChannel();
    var DirectoryChannel = class extends BaseChannel {
      constructor(guild, data, client) {
        super(client, data);
        this.guild = guild;
        this.guildId = guild.id;
      }
      _patch(data) {
        super._patch(data);
        this.name = data.name;
      }
    };
    module2.exports = DirectoryChannel;
  }
});

// ../../node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/PartialGroupDMChannel.js"(exports2, module2) {
    "use strict";
    var { BaseChannel } = require_BaseChannel();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var PartialGroupDMChannel = class extends BaseChannel {
      constructor(client, data) {
        super(client, data);
        this.flags = null;
        this.name = data.name;
        this.icon = data.icon;
        this.recipients = data.recipients;
      }
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
      }
      delete() {
        return Promise.reject(new DiscordjsError2(ErrorCodes2.DeleteGroupDMChannel));
      }
      fetch() {
        return Promise.reject(new DiscordjsError2(ErrorCodes2.FetchGroupDMChannel));
      }
    };
    module2.exports = PartialGroupDMChannel;
  }
});

// ../../node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildForumThreadManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var ThreadManager = require_ThreadManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var MessagePayload = require_MessagePayload();
    var GuildForumThreadManager = class extends ThreadManager {
      async create({
        name,
        autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
        message,
        reason,
        rateLimitPerUser,
        appliedTags
      } = {}) {
        if (!message) {
          throw new DiscordjsTypeError2(ErrorCodes2.GuildForumMessageRequired);
        }
        const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
        const data = await this.client.rest.post(Routes3.threads(this.channel.id), {
          body: {
            name,
            auto_archive_duration: autoArchiveDuration,
            rate_limit_per_user: rateLimitPerUser,
            applied_tags: appliedTags,
            message: body
          },
          files,
          reason
        });
        return this.client.actions.ThreadCreate.handle(data).thread;
      }
    };
    module2.exports = GuildForumThreadManager;
  }
});

// ../../node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS({
  "../../node_modules/discord.js/src/structures/ForumChannel.js"(exports2, module2) {
    "use strict";
    var GuildChannel = require_GuildChannel();
    var TextBasedChannel = require_TextBasedChannel();
    var GuildForumThreadManager = require_GuildForumThreadManager();
    var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();
    var ForumChannel = class extends GuildChannel {
      constructor(guild, data, client) {
        super(guild, data, client, false);
        this.threads = new GuildForumThreadManager(this);
        this._patch(data);
      }
      _patch(data) {
        super._patch(data);
        if ("available_tags" in data) {
          this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
        } else {
          this.availableTags ?? (this.availableTags = []);
        }
        if ("default_reaction_emoji" in data) {
          this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
        } else {
          this.defaultReactionEmoji ?? (this.defaultReactionEmoji = null);
        }
        if ("default_thread_rate_limit_per_user" in data) {
          this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
        } else {
          this.defaultThreadRateLimitPerUser ?? (this.defaultThreadRateLimitPerUser = null);
        }
        if ("rate_limit_per_user" in data) {
          this.rateLimitPerUser = data.rate_limit_per_user;
        } else {
          this.rateLimitPerUser ?? (this.rateLimitPerUser = null);
        }
        if ("default_auto_archive_duration" in data) {
          this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
        } else {
          this.defaultAutoArchiveDuration ?? (this.defaultAutoArchiveDuration = null);
        }
        if ("nsfw" in data) {
          this.nsfw = data.nsfw;
        } else {
          this.nsfw ?? (this.nsfw = false);
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("default_sort_order" in data) {
          this.defaultSortOrder = data.default_sort_order;
        } else {
          this.defaultSortOrder ?? (this.defaultSortOrder = null);
        }
      }
      setAvailableTags(availableTags, reason) {
        return this.edit({ availableTags, reason });
      }
      setDefaultReactionEmoji(defaultReactionEmoji, reason) {
        return this.edit({ defaultReactionEmoji, reason });
      }
      setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
        return this.edit({ defaultThreadRateLimitPerUser, reason });
      }
      createInvite(options) {
        return this.guild.invites.create(this.id, options);
      }
      fetchInvites(cache) {
        return this.guild.invites.fetch({ channelId: this.id, cache });
      }
      setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
        return this.edit({ defaultAutoArchiveDuration, reason });
      }
      setTopic(topic, reason) {
        return this.edit({ topic, reason });
      }
      setDefaultSortOrder(defaultSortOrder, reason) {
        return this.edit({ defaultSortOrder, reason });
      }
      createWebhook() {
      }
      fetchWebhooks() {
      }
      setNSFW() {
      }
      setRateLimitPerUser() {
      }
    };
    TextBasedChannel.applyToClass(ForumChannel, true, [
      "send",
      "lastMessage",
      "lastPinAt",
      "bulkDelete",
      "sendTyping",
      "createMessageCollector",
      "awaitMessages",
      "createMessageComponentCollector",
      "awaitMessageComponent"
    ]);
    module2.exports = ForumChannel;
  }
});

// ../../node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS({
  "../../node_modules/discord.js/src/util/Channels.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var { ChannelType } = require_v106();
    var getCategoryChannel = lazy(() => require_CategoryChannel());
    var getDMChannel = lazy(() => require_DMChannel());
    var getNewsChannel = lazy(() => require_NewsChannel());
    var getStageChannel = lazy(() => require_StageChannel());
    var getTextChannel = lazy(() => require_TextChannel());
    var getThreadChannel = lazy(() => require_ThreadChannel());
    var getVoiceChannel = lazy(() => require_VoiceChannel());
    var getDirectoryChannel = lazy(() => require_DirectoryChannel());
    var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
    var getForumChannel = lazy(() => require_ForumChannel());
    function createChannel(client, data, guild, { allowUnknownGuild, fromInteraction } = {}) {
      var _a, _b;
      let channel;
      if (!data.guild_id && !guild) {
        if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
          channel = new (getDMChannel())(client, data);
        } else if (data.type === ChannelType.GroupDM) {
          channel = new (getPartialGroupDMChannel())(client, data);
        }
      } else {
        guild ?? (guild = client.guilds.cache.get(data.guild_id));
        if (guild || allowUnknownGuild) {
          switch (data.type) {
            case ChannelType.GuildText: {
              channel = new (getTextChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildVoice: {
              channel = new (getVoiceChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildCategory: {
              channel = new (getCategoryChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildAnnouncement: {
              channel = new (getNewsChannel())(guild, data, client);
              break;
            }
            case ChannelType.GuildStageVoice: {
              channel = new (getStageChannel())(guild, data, client);
              break;
            }
            case ChannelType.AnnouncementThread:
            case ChannelType.PublicThread:
            case ChannelType.PrivateThread: {
              channel = new (getThreadChannel())(guild, data, client, fromInteraction);
              if (!allowUnknownGuild)
                (_a = channel.parent) == null ? void 0 : _a.threads.cache.set(channel.id, channel);
              break;
            }
            case ChannelType.GuildDirectory:
              channel = new (getDirectoryChannel())(guild, data, client);
              break;
            case ChannelType.GuildForum:
              channel = new (getForumChannel())(guild, data, client);
              break;
          }
          if (channel && !allowUnknownGuild)
            (_b = guild.channels) == null ? void 0 : _b.cache.set(channel.id, channel);
        }
      }
      return channel;
    }
    function transformAPIGuildForumTag(tag) {
      return {
        id: tag.id,
        name: tag.name,
        moderated: tag.moderated,
        emoji: tag.emoji_id ?? tag.emoji_name ? {
          id: tag.emoji_id,
          name: tag.emoji_name
        } : null
      };
    }
    function transformGuildForumTag(tag) {
      var _a, _b;
      return {
        id: tag.id,
        name: tag.name,
        moderated: tag.moderated,
        emoji_id: ((_a = tag.emoji) == null ? void 0 : _a.id) ?? null,
        emoji_name: ((_b = tag.emoji) == null ? void 0 : _b.name) ?? null
      };
    }
    function transformAPIGuildDefaultReaction(defaultReaction) {
      return {
        id: defaultReaction.emoji_id,
        name: defaultReaction.emoji_name
      };
    }
    function transformGuildDefaultReaction(defaultReaction) {
      return {
        emoji_id: defaultReaction.id,
        emoji_name: defaultReaction.name
      };
    }
    module2.exports = {
      createChannel,
      transformAPIGuildForumTag,
      transformGuildForumTag,
      transformAPIGuildDefaultReaction,
      transformGuildDefaultReaction
    };
  }
});

// ../../node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ChannelUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var { createChannel } = require_Channels();
    var ChannelUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        let channel = client.channels.cache.get(data.id);
        if (channel) {
          const old = channel._update(data);
          if (channel.type !== data.type) {
            const newChannel = createChannel(this.client, data, channel.guild);
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
            channel = newChannel;
            this.client.channels.cache.set(channel.id, channel);
          }
          return {
            old,
            updated: channel
          };
        } else {
          client.channels._add(data);
        }
        return {};
      }
    };
    module2.exports = ChannelUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildBanAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildBanAdd = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild)
          client.emit(Events3.GuildBanAdd, guild.bans._add(data));
      }
    };
    module2.exports = GuildBanAdd;
  }
});

// ../../node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildBan.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var GuildBan = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this._patch(data);
      }
      _patch(data) {
        if ("user" in data) {
          this.user = this.client.users._add(data.user, true);
        }
        if ("reason" in data) {
          this.reason = data.reason;
        }
      }
      get partial() {
        return !("reason" in this);
      }
      fetch(force = true) {
        return this.guild.bans.fetch({ user: this.user, cache: true, force });
      }
    };
    module2.exports = GuildBan;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildBanRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildBan = require_GuildBan();
    var Events3 = require_Events();
    var GuildBanRemove = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
          guild.bans.cache.delete(ban.user.id);
          client.emit(Events3.GuildBanRemove, ban);
        }
      }
    };
    module2.exports = GuildBanRemove;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildChannelsPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialChannel of data.channels) {
            const channel = guild.channels.cache.get(partialChannel.id);
            if (channel)
              channel.rawPosition = partialChannel.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildChannelsPositionUpdate;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildDeleteAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        let guild = client.guilds.cache.get(data.id);
        if (guild) {
          if (data.unavailable) {
            guild.available = false;
            client.emit(Events3.GuildUnavailable, guild);
            return;
          }
          for (const channel of guild.channels.cache.values())
            this.client.channels._remove(channel.id);
          (_a = client.voice.adapters.get(data.id)) == null ? void 0 : _a.destroy();
          client.guilds.cache.delete(guild.id);
          client.emit(Events3.GuildDelete, guild);
        }
      }
    };
    module2.exports = GuildDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildEmojiCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildEmojiCreateAction = class extends Action {
      handle(guild, createdEmoji) {
        const already = guild.emojis.cache.has(createdEmoji.id);
        const emoji = guild.emojis._add(createdEmoji);
        if (!already)
          this.client.emit(Events3.GuildEmojiCreate, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildEmojiDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildEmojiDeleteAction = class extends Action {
      handle(emoji) {
        emoji.guild.emojis.cache.delete(emoji.id);
        this.client.emit(Events3.GuildEmojiDelete, emoji);
        return { emoji };
      }
    };
    module2.exports = GuildEmojiDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildEmojiUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events3.GuildEmojiUpdate, old, current);
        return { emoji: current };
      }
    };
    module2.exports = GuildEmojiUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildEmojisUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!(guild == null ? void 0 : guild.emojis))
          return;
        const deletions = new Map(guild.emojis.cache);
        for (const emoji of data.emojis) {
          const cachedEmoji = guild.emojis.cache.get(emoji.id);
          if (cachedEmoji) {
            deletions.delete(emoji.id);
            if (!cachedEmoji.equals(emoji)) {
              this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
            }
          } else {
            this.client.actions.GuildEmojiCreate.handle(guild, emoji);
          }
        }
        for (const emoji of deletions.values()) {
          this.client.actions.GuildEmojiDelete.handle(emoji);
        }
      }
    };
    module2.exports = GuildEmojisUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildIntegrationsUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild)
          client.emit(Events3.GuildIntegrationsUpdate, guild);
      }
    };
    module2.exports = GuildIntegrationsUpdate;
  }
});

// ../../node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS({
  "../../node_modules/discord.js/src/util/Status.js"(exports2, module2) {
    "use strict";
    var { createEnum } = require_Enums();
    module2.exports = createEnum([
      "Ready",
      "Connecting",
      "Reconnecting",
      "Idle",
      "Nearly",
      "Disconnected",
      "WaitingForGuilds",
      "Identifying",
      "Resuming"
    ]);
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildMemberRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var GuildMemberRemoveAction = class extends Action {
      handle(data, shard) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let member = null;
        if (guild) {
          member = this.getMember({ user: data.user }, guild);
          guild.memberCount--;
          if (member) {
            guild.members.cache.delete(member.id);
            if (shard.status === Status2.Ready)
              client.emit(Events3.GuildMemberRemove, member);
          }
          guild.presences.cache.delete(data.user.id);
          guild.voiceStates.cache.delete(data.user.id);
        }
        return { guild, member };
      }
    };
    module2.exports = GuildMemberRemoveAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var GuildMemberUpdateAction = class extends Action {
      handle(data, shard) {
        const { client } = this;
        if (data.user.username) {
          const user = client.users.cache.get(data.user.id);
          if (!user) {
            client.users._add(data.user);
          } else if (!user._equals(data.user)) {
            client.actions.UserUpdate.handle(data.user);
          }
        }
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const member = this.getMember({ user: data.user }, guild);
          if (member) {
            const old = member._update(data);
            if (shard.status === Status2.Ready && !member.equals(old))
              client.emit(Events3.GuildMemberUpdate, old, member);
          } else {
            const newMember = guild.members._add(data);
            this.client.emit(Events3.GuildMemberAvailable, newMember);
          }
        }
      }
    };
    module2.exports = GuildMemberUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildRoleCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildRoleCreate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          const already = guild.roles.cache.has(data.role.id);
          role = guild.roles._add(data.role);
          if (!already)
            client.emit(Events3.GuildRoleCreate, role);
        }
        return { role };
      }
    };
    module2.exports = GuildRoleCreate;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildRoleDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildRoleDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        let role;
        if (guild) {
          role = guild.roles.cache.get(data.role_id);
          if (role) {
            guild.roles.cache.delete(data.role_id);
            client.emit(Events3.GuildRoleDelete, role);
          }
        }
        return { role };
      }
    };
    module2.exports = GuildRoleDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildRoleUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildRoleUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          let old = null;
          const role = guild.roles.cache.get(data.role.id);
          if (role) {
            old = role._update(data.role);
            client.emit(Events3.GuildRoleUpdate, old, role);
          }
          return {
            old,
            updated: role
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildRoleUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildRolesPositionUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          for (const partialRole of data.roles) {
            const role = guild.roles.cache.get(partialRole.id);
            if (role)
              role.rawPosition = partialRole.position;
          }
        }
        return { guild };
      }
    };
    module2.exports = GuildRolesPositionUpdate;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events3.GuildScheduledEventCreate, guildScheduledEvent);
          return { guildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          if (guildScheduledEvent) {
            guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
            client.emit(Events3.GuildScheduledEventDelete, guildScheduledEvent);
            return { guildScheduledEvent };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldGuildScheduledEvent = ((_a = guild.scheduledEvents.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newGuildScheduledEvent = guild.scheduledEvents._add(data);
          client.emit(Events3.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
          return { oldGuildScheduledEvent, newGuildScheduledEvent };
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventUserAddAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events3.GuildScheduledEventUserAdd, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserAddAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildScheduledEventUserRemoveAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const guildScheduledEvent = this.getScheduledEvent(data, guild);
          const user = this.getUser(data);
          if (guildScheduledEvent && user) {
            client.emit(Events3.GuildScheduledEventUserRemove, guildScheduledEvent, user);
            return { guildScheduledEvent, user };
          }
        }
        return {};
      }
    };
    module2.exports = GuildScheduledEventUserRemoveAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildStickerCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildStickerCreateAction = class extends Action {
      handle(guild, createdSticker) {
        const already = guild.stickers.cache.has(createdSticker.id);
        const sticker = guild.stickers._add(createdSticker);
        if (!already)
          this.client.emit(Events3.GuildStickerCreate, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildStickerDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildStickerDeleteAction = class extends Action {
      handle(sticker) {
        sticker.guild.stickers.cache.delete(sticker.id);
        this.client.emit(Events3.GuildStickerDelete, sticker);
        return { sticker };
      }
    };
    module2.exports = GuildStickerDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildStickerUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildStickerUpdateAction = class extends Action {
      handle(current, data) {
        const old = current._update(data);
        this.client.emit(Events3.GuildStickerUpdate, old, current);
        return { sticker: current };
      }
    };
    module2.exports = GuildStickerUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildStickersUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var GuildStickersUpdateAction = class extends Action {
      handle(data) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!(guild == null ? void 0 : guild.stickers))
          return;
        const deletions = new Map(guild.stickers.cache);
        for (const sticker of data.stickers) {
          const cachedSticker = guild.stickers.cache.get(sticker.id);
          if (cachedSticker) {
            deletions.delete(sticker.id);
            if (!cachedSticker.equals(sticker)) {
              this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
            }
          } else {
            this.client.actions.GuildStickerCreate.handle(guild, sticker);
          }
        }
        for (const sticker of deletions.values()) {
          this.client.actions.GuildStickerDelete.handle(sticker);
        }
      }
    };
    module2.exports = GuildStickersUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/GuildUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var GuildUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.id);
        if (guild) {
          const old = guild._update(data);
          client.emit(Events3.GuildUpdate, old, guild);
          return {
            old,
            updated: guild
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = GuildUpdateAction;
  }
});

// ../../node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS({
  "../../node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js"(exports2, module2) {
    "use strict";
    var { ApplicationCommandOptionType } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var CommandInteractionOptionResolver = class {
      constructor(client, options, resolved) {
        var _a, _b;
        Object.defineProperty(this, "client", { value: client });
        this._group = null;
        this._subcommand = null;
        this._hoistedOptions = options;
        if (((_a = this._hoistedOptions[0]) == null ? void 0 : _a.type) === ApplicationCommandOptionType.SubcommandGroup) {
          this._group = this._hoistedOptions[0].name;
          this._hoistedOptions = this._hoistedOptions[0].options ?? [];
        }
        if (((_b = this._hoistedOptions[0]) == null ? void 0 : _b.type) === ApplicationCommandOptionType.Subcommand) {
          this._subcommand = this._hoistedOptions[0].name;
          this._hoistedOptions = this._hoistedOptions[0].options ?? [];
        }
        Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
        Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
      }
      get(name, required = false) {
        const option = this._hoistedOptions.find((opt) => opt.name === name);
        if (!option) {
          if (required) {
            throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNotFound, name);
          }
          return null;
        }
        return option;
      }
      _getTypedOption(name, type, properties, required) {
        const option = this.get(name, required);
        if (!option) {
          return null;
        } else if (option.type !== type) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionType, name, option.type, type);
        } else if (required && properties.every((prop) => option[prop] === null || typeof option[prop] === "undefined")) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionEmpty, name, option.type);
        }
        return option;
      }
      getSubcommand(required = true) {
        if (required && !this._subcommand) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNoSubcommand);
        }
        return this._subcommand;
      }
      getSubcommandGroup(required = false) {
        if (required && !this._group) {
          throw new DiscordjsTypeError2(ErrorCodes2.CommandInteractionOptionNoSubcommandGroup);
        }
        return this._group;
      }
      getBoolean(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.Boolean, ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      getChannel(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.Channel, ["channel"], required);
        return (option == null ? void 0 : option.channel) ?? null;
      }
      getString(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.String, ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      getInteger(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.Integer, ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      getNumber(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.Number, ["value"], required);
        return (option == null ? void 0 : option.value) ?? null;
      }
      getUser(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.User, ["user"], required);
        return (option == null ? void 0 : option.user) ?? null;
      }
      getMember(name) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.User, ["member"], false);
        return (option == null ? void 0 : option.member) ?? null;
      }
      getRole(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.Role, ["role"], required);
        return (option == null ? void 0 : option.role) ?? null;
      }
      getAttachment(name, required = false) {
        const option = this._getTypedOption(name, ApplicationCommandOptionType.Attachment, ["attachment"], required);
        return (option == null ? void 0 : option.attachment) ?? null;
      }
      getMentionable(name, required = false) {
        const option = this._getTypedOption(
          name,
          ApplicationCommandOptionType.Mentionable,
          ["user", "member", "role"],
          required
        );
        return (option == null ? void 0 : option.member) ?? (option == null ? void 0 : option.user) ?? (option == null ? void 0 : option.role) ?? null;
      }
      getMessage(name, required = false) {
        const option = this._getTypedOption(name, "_MESSAGE", ["message"], required);
        return (option == null ? void 0 : option.message) ?? null;
      }
      getFocused(getFull = false) {
        const focusedOption = this._hoistedOptions.find((option) => option.focused);
        if (!focusedOption)
          throw new DiscordjsTypeError2(ErrorCodes2.AutocompleteInteractionOptionNoFocusedOption);
        return getFull ? focusedOption : focusedOption.value;
      }
    };
    module2.exports = CommandInteractionOptionResolver;
  }
});

// ../../node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/AutocompleteInteraction.js"(exports2, module2) {
    "use strict";
    var { InteractionResponseType, Routes: Routes3 } = require_v106();
    var BaseInteraction = require_BaseInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var AutocompleteInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.commandId = data.data.id;
        this.commandName = data.data.name;
        this.commandType = data.data.type;
        this.commandGuildId = data.data.guild_id ?? null;
        this.responded = false;
        this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
      }
      get command() {
        var _a;
        const id = this.commandId;
        return ((_a = this.guild) == null ? void 0 : _a.commands.cache.get(id)) ?? this.client.application.commands.cache.get(id) ?? null;
      }
      async respond(options) {
        if (this.responded)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes3.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.ApplicationCommandAutocompleteResult,
            data: {
              choices: options
            }
          },
          auth: false
        });
        this.responded = true;
      }
    };
    module2.exports = AutocompleteInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS({
  "../../node_modules/discord.js/src/structures/InteractionResponse.js"(exports2, module2) {
    "use strict";
    var { InteractionType } = require_v106();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var InteractionResponse = class {
      constructor(interaction, id) {
        this.interaction = interaction;
        this.id = id ?? interaction.id;
        this.client = interaction.client;
      }
      awaitMessageComponent(options = {}) {
        const _options = { ...options, max: 1 };
        return new Promise((resolve, reject) => {
          const collector = this.createMessageComponentCollector(_options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      createMessageComponentCollector(options = {}) {
        return new InteractionCollector(this.client, {
          ...options,
          interactionResponse: this,
          interactionType: InteractionType.MessageComponent
        });
      }
    };
    var InteractionCollector = require_InteractionCollector();
    module2.exports = InteractionResponse;
  }
});

// ../../node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS({
  "../../node_modules/discord.js/src/structures/interfaces/InteractionResponses.js"(exports2, module2) {
    "use strict";
    var { isJSONEncodable } = require_dist7();
    var { InteractionResponseType, MessageFlags, Routes: Routes3, InteractionType } = require_v106();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var InteractionCollector = require_InteractionCollector();
    var InteractionResponse = require_InteractionResponse();
    var MessagePayload = require_MessagePayload();
    var InteractionResponses = class {
      async deferReply(options = {}) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        this.ephemeral = options.ephemeral ?? false;
        await this.client.rest.post(Routes3.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.DeferredChannelMessageWithSource,
            data: {
              flags: options.ephemeral ? MessageFlags.Ephemeral : void 0
            }
          },
          auth: false
        });
        this.deferred = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
      }
      async reply(options) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        this.ephemeral = options.ephemeral ?? false;
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
        await this.client.rest.post(Routes3.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.ChannelMessageWithSource,
            data
          },
          files,
          auth: false
        });
        this.replied = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
      }
      fetchReply() {
        return this.webhook.fetchMessage("@original");
      }
      async editReply(options) {
        if (!this.deferred && !this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionNotReplied);
        const message = await this.webhook.editMessage("@original", options);
        this.replied = true;
        return message;
      }
      async deleteReply() {
        if (this.ephemeral)
          throw new DiscordjsError2(ErrorCodes2.InteractionEphemeralReplied);
        await this.webhook.deleteMessage("@original");
      }
      followUp(options) {
        if (!this.deferred && !this.replied)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.InteractionNotReplied));
        return this.webhook.send(options);
      }
      async deferUpdate(options = {}) {
        var _a, _b;
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes3.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.DeferredMessageUpdate
          },
          auth: false
        });
        this.deferred = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, (_b = (_a = this.message) == null ? void 0 : _a.interaction) == null ? void 0 : _b.id);
      }
      async update(options) {
        var _a;
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        let messagePayload;
        if (options instanceof MessagePayload)
          messagePayload = options;
        else
          messagePayload = MessagePayload.create(this, options);
        const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
        await this.client.rest.post(Routes3.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.UpdateMessage,
            data
          },
          files,
          auth: false
        });
        this.replied = true;
        return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, (_a = this.message.interaction) == null ? void 0 : _a.id);
      }
      async showModal(modal) {
        if (this.deferred || this.replied)
          throw new DiscordjsError2(ErrorCodes2.InteractionAlreadyReplied);
        await this.client.rest.post(Routes3.interactionCallback(this.id, this.token), {
          body: {
            type: InteractionResponseType.Modal,
            data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
          }
        });
        this.replied = true;
      }
      awaitModalSubmit(options) {
        if (typeof options.time !== "number")
          throw new DiscordjsError2(ErrorCodes2.InvalidType, "time", "number");
        const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
        return new Promise((resolve, reject) => {
          const collector = new InteractionCollector(this.client, _options);
          collector.once("end", (interactions, reason) => {
            const interaction = interactions.first();
            if (interaction)
              resolve(interaction);
            else
              reject(new DiscordjsError2(ErrorCodes2.InteractionCollectorError, reason));
          });
        });
      }
      static applyToClass(structure, ignore = []) {
        const props = [
          "deferReply",
          "reply",
          "fetchReply",
          "editReply",
          "deleteReply",
          "followUp",
          "deferUpdate",
          "update",
          "showModal",
          "awaitModalSubmit"
        ];
        for (const prop of props) {
          if (ignore.includes(prop))
            continue;
          Object.defineProperty(
            structure.prototype,
            prop,
            Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop)
          );
        }
      }
    };
    module2.exports = InteractionResponses;
  }
});

// ../../node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/MessageComponentInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var InteractionResponses = require_InteractionResponses();
    var getMessage = lazy(() => require_Message().Message);
    var MessageComponentInteraction = class extends BaseInteraction {
      constructor(client, data) {
        var _a;
        super(client, data);
        this.message = ((_a = this.channel) == null ? void 0 : _a.messages._add(data.message)) ?? new (getMessage())(client, data.message);
        this.customId = data.data.custom_id;
        this.componentType = data.data.component_type;
        this.deferred = false;
        this.ephemeral = null;
        this.replied = false;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      get component() {
        return this.message.components.flatMap((row) => row.components).find((component) => (component.customId ?? component.custom_id) === this.customId);
      }
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      deferUpdate() {
      }
      update() {
      }
      showModal() {
      }
      awaitModalSubmit() {
      }
    };
    InteractionResponses.applyToClass(MessageComponentInteraction);
    module2.exports = MessageComponentInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/ButtonInteraction.js"(exports2, module2) {
    "use strict";
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var ButtonInteraction = class extends MessageComponentInteraction {
    };
    module2.exports = ButtonInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/CommandInteraction.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Attachment = require_Attachment();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var InteractionResponses = require_InteractionResponses();
    var CommandInteraction = class extends BaseInteraction {
      constructor(client, data) {
        super(client, data);
        this.commandId = data.data.id;
        this.commandName = data.data.name;
        this.commandType = data.data.type;
        this.commandGuildId = data.data.guild_id ?? null;
        this.deferred = false;
        this.replied = false;
        this.ephemeral = null;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      get command() {
        var _a;
        const id = this.commandId;
        return ((_a = this.guild) == null ? void 0 : _a.commands.cache.get(id)) ?? this.client.application.commands.cache.get(id) ?? null;
      }
      transformResolved({ members, users, channels, roles, messages, attachments }) {
        var _a, _b, _c, _d;
        const result = {};
        if (members) {
          result.members = new Collection2();
          for (const [id, member] of Object.entries(members)) {
            const user = users[id];
            result.members.set(id, ((_a = this.guild) == null ? void 0 : _a.members._add({ user, ...member })) ?? member);
          }
        }
        if (users) {
          result.users = new Collection2();
          for (const user of Object.values(users)) {
            result.users.set(user.id, this.client.users._add(user));
          }
        }
        if (roles) {
          result.roles = new Collection2();
          for (const role of Object.values(roles)) {
            result.roles.set(role.id, ((_b = this.guild) == null ? void 0 : _b.roles._add(role)) ?? role);
          }
        }
        if (channels) {
          result.channels = new Collection2();
          for (const channel of Object.values(channels)) {
            result.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
          }
        }
        if (messages) {
          result.messages = new Collection2();
          for (const message of Object.values(messages)) {
            result.messages.set(message.id, ((_d = (_c = this.channel) == null ? void 0 : _c.messages) == null ? void 0 : _d._add(message)) ?? message);
          }
        }
        if (attachments) {
          result.attachments = new Collection2();
          for (const attachment of Object.values(attachments)) {
            const patched = new Attachment(attachment);
            result.attachments.set(attachment.id, patched);
          }
        }
        return result;
      }
      transformOption(option, resolved) {
        var _a, _b, _c, _d, _e, _f, _g;
        const result = {
          name: option.name,
          type: option.type
        };
        if ("value" in option)
          result.value = option.value;
        if ("options" in option)
          result.options = option.options.map((opt) => this.transformOption(opt, resolved));
        if (resolved) {
          const user = (_a = resolved.users) == null ? void 0 : _a[option.value];
          if (user)
            result.user = this.client.users._add(user);
          const member = (_b = resolved.members) == null ? void 0 : _b[option.value];
          if (member)
            result.member = ((_c = this.guild) == null ? void 0 : _c.members._add({ user, ...member })) ?? member;
          const channel = (_d = resolved.channels) == null ? void 0 : _d[option.value];
          if (channel)
            result.channel = this.client.channels._add(channel, this.guild) ?? channel;
          const role = (_e = resolved.roles) == null ? void 0 : _e[option.value];
          if (role)
            result.role = ((_f = this.guild) == null ? void 0 : _f.roles._add(role)) ?? role;
          const attachment = (_g = resolved.attachments) == null ? void 0 : _g[option.value];
          if (attachment)
            result.attachment = new Attachment(attachment);
        }
        return result;
      }
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      showModal() {
      }
      awaitModalSubmit() {
      }
    };
    InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
    module2.exports = CommandInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/ChatInputCommandInteraction.js"(exports2, module2) {
    "use strict";
    var CommandInteraction = require_CommandInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var ChatInputCommandInteraction = class extends CommandInteraction {
      constructor(client, data) {
        var _a;
        super(client, data);
        this.options = new CommandInteractionOptionResolver(
          this.client,
          ((_a = data.data.options) == null ? void 0 : _a.map((option) => this.transformOption(option, data.data.resolved))) ?? [],
          this.transformResolved(data.data.resolved ?? {})
        );
      }
      toString() {
        const properties = [
          this.commandName,
          this.options._group,
          this.options._subcommand,
          ...this.options._hoistedOptions.map((o) => `${o.name}:${o.value}`)
        ];
        return `/${properties.filter(Boolean).join(" ")}`;
      }
    };
    module2.exports = ChatInputCommandInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var { ApplicationCommandOptionType } = require_v106();
    var CommandInteraction = require_CommandInteraction();
    var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    var getMessage = lazy(() => require_Message().Message);
    var ContextMenuCommandInteraction = class extends CommandInteraction {
      constructor(client, data) {
        super(client, data);
        this.options = new CommandInteractionOptionResolver(
          this.client,
          this.resolveContextMenuOptions(data.data),
          this.transformResolved(data.data.resolved)
        );
        this.targetId = data.data.target_id;
      }
      resolveContextMenuOptions({ target_id, resolved }) {
        var _a, _b, _c;
        const result = [];
        if ((_a = resolved.users) == null ? void 0 : _a[target_id]) {
          result.push(
            this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved)
          );
        }
        if ((_b = resolved.messages) == null ? void 0 : _b[target_id]) {
          result.push({
            name: "message",
            type: "_MESSAGE",
            value: target_id,
            message: ((_c = this.channel) == null ? void 0 : _c.messages._add(resolved.messages[target_id])) ?? new (getMessage())(this.client, resolved.messages[target_id])
          });
        }
        return result;
      }
    };
    module2.exports = ContextMenuCommandInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    var MessageContextMenuCommandInteraction = class extends ContextMenuCommandInteraction {
      get targetMessage() {
        return this.options.getMessage("message");
      }
    };
    module2.exports = MessageContextMenuCommandInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS({
  "../../node_modules/discord.js/src/structures/ModalSubmitFields.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { ComponentType } = require_v106();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ModalSubmitFields = class {
      constructor(components) {
        this.components = components;
        this.fields = components.reduce((accumulator, next) => {
          next.components.forEach((c) => accumulator.set(c.customId, c));
          return accumulator;
        }, new Collection2());
      }
      getField(customId, type) {
        const field = this.fields.get(customId);
        if (!field)
          throw new DiscordjsTypeError2(ErrorCodes2.ModalSubmitInteractionFieldNotFound, customId);
        if (type !== void 0 && type !== field.type) {
          throw new DiscordjsTypeError2(ErrorCodes2.ModalSubmitInteractionFieldType, customId, field.type, type);
        }
        return field;
      }
      getTextInputValue(customId) {
        return this.getField(customId, ComponentType.TextInput).value;
      }
    };
    module2.exports = ModalSubmitFields;
  }
});

// ../../node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/ModalSubmitInteraction.js"(exports2, module2) {
    "use strict";
    var { lazy } = require_dist2();
    var BaseInteraction = require_BaseInteraction();
    var InteractionWebhook = require_InteractionWebhook();
    var ModalSubmitFields = require_ModalSubmitFields();
    var InteractionResponses = require_InteractionResponses();
    var getMessage = lazy(() => require_Message().Message);
    var ModalSubmitInteraction = class extends BaseInteraction {
      constructor(client, data) {
        var _a, _b;
        super(client, data);
        this.customId = data.data.custom_id;
        if ("message" in data) {
          this.message = ((_a = this.channel) == null ? void 0 : _a.messages._add(data.message)) ?? new (getMessage())(this.client, data.message);
        } else {
          this.message = null;
        }
        this.components = (_b = data.data.components) == null ? void 0 : _b.map((c) => ModalSubmitInteraction.transformComponent(c));
        this.fields = new ModalSubmitFields(this.components);
        this.deferred = false;
        this.replied = false;
        this.ephemeral = null;
        this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
      }
      static transformComponent(rawComponent) {
        var _a;
        return {
          value: rawComponent.value,
          type: rawComponent.type,
          customId: rawComponent.custom_id,
          components: (_a = rawComponent.components) == null ? void 0 : _a.map((c) => this.transformComponent(c))
        };
      }
      isFromMessage() {
        return Boolean(this.message);
      }
      deferReply() {
      }
      reply() {
      }
      fetchReply() {
      }
      editReply() {
      }
      deleteReply() {
      }
      followUp() {
      }
      deferUpdate() {
      }
      update() {
      }
    };
    InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
    module2.exports = ModalSubmitInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/SelectMenuInteraction.js"(exports2, module2) {
    "use strict";
    var MessageComponentInteraction = require_MessageComponentInteraction();
    var SelectMenuInteraction = class extends MessageComponentInteraction {
      constructor(client, data) {
        super(client, data);
        this.values = data.data.values ?? [];
      }
    };
    module2.exports = SelectMenuInteraction;
  }
});

// ../../node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS({
  "../../node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js"(exports2, module2) {
    "use strict";
    var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    var UserContextMenuCommandInteraction = class extends ContextMenuCommandInteraction {
      get targetUser() {
        return this.options.getUser("user");
      }
      get targetMember() {
        return this.options.getMember("user");
      }
    };
    module2.exports = UserContextMenuCommandInteraction;
  }
});

// ../../node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/InteractionCreate.js"(exports2, module2) {
    "use strict";
    var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
    var Action = require_Action();
    var AutocompleteInteraction = require_AutocompleteInteraction();
    var ButtonInteraction = require_ButtonInteraction();
    var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
    var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
    var ModalSubmitInteraction = require_ModalSubmitInteraction();
    var SelectMenuInteraction = require_SelectMenuInteraction();
    var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
    var Events3 = require_Events();
    var InteractionCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        let InteractionClass;
        switch (data.type) {
          case InteractionType.ApplicationCommand:
            switch (data.data.type) {
              case ApplicationCommandType.ChatInput:
                InteractionClass = ChatInputCommandInteraction;
                break;
              case ApplicationCommandType.User:
                InteractionClass = UserContextMenuCommandInteraction;
                break;
              case ApplicationCommandType.Message:
                if (channel && !channel.isTextBased())
                  return;
                InteractionClass = MessageContextMenuCommandInteraction;
                break;
              default:
                client.emit(
                  Events3.Debug,
                  `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`
                );
                return;
            }
            break;
          case InteractionType.MessageComponent:
            if (channel && !channel.isTextBased())
              return;
            switch (data.data.component_type) {
              case ComponentType.Button:
                InteractionClass = ButtonInteraction;
                break;
              case ComponentType.SelectMenu:
                InteractionClass = SelectMenuInteraction;
                break;
              default:
                client.emit(
                  Events3.Debug,
                  `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`
                );
                return;
            }
            break;
          case InteractionType.ApplicationCommandAutocomplete:
            InteractionClass = AutocompleteInteraction;
            break;
          case InteractionType.ModalSubmit:
            InteractionClass = ModalSubmitInteraction;
            break;
          default:
            client.emit(Events3.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
            return;
        }
        const interaction = new InteractionClass(client, data);
        client.emit(Events3.InteractionCreate, interaction);
      }
    };
    module2.exports = InteractionCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/InviteCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var InviteCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel)
          return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = guild.invites._add(inviteData);
        client.emit(Events3.InviteCreate, invite);
        return { invite };
      }
    };
    module2.exports = InviteCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/InviteDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Invite2 = require_Invite();
    var Events3 = require_Events();
    var InviteDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        const guild = client.guilds.cache.get(data.guild_id);
        if (!channel)
          return false;
        const inviteData = Object.assign(data, { channel, guild });
        const invite = new Invite2(client, inviteData);
        guild.invites.cache.delete(invite.code);
        client.emit(Events3.InviteDelete, invite);
        return { invite };
      }
    };
    module2.exports = InviteDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread()) {
            channel.messageCount++;
            channel.totalMessageSent++;
          }
          const existing = channel.messages.cache.get(data.id);
          if (existing)
            return { message: existing };
          const message = channel.messages._add(data);
          channel.lastMessageId = data.id;
          client.emit(Events3.MessageCreate, message);
          return { message };
        }
        return {};
      }
    };
    module2.exports = MessageCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        let message;
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread())
            channel.messageCount--;
          message = this.getMessage(data, channel);
          if (message) {
            channel.messages.cache.delete(message.id);
            client.emit(Events3.MessageDelete, message);
          }
        }
        return { message };
      }
    };
    module2.exports = MessageDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageDeleteBulk.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageDeleteBulkAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          if (channel.isThread())
            channel.messageCount -= data.ids.length;
          const ids = data.ids;
          const messages = new Collection2();
          for (const id of ids) {
            const message = this.getMessage(
              {
                id,
                guild_id: data.guild_id
              },
              channel,
              false
            );
            if (message) {
              messages.set(message.id, message);
              channel.messages.cache.delete(id);
            }
          }
          if (messages.size > 0)
            client.emit(Events3.MessageBulkDelete, messages, channel);
          return { messages };
        }
        return {};
      }
    };
    module2.exports = MessageDeleteBulkAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageReactionAdd.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var Partials = require_Partials();
    var MessageReactionAdd = class extends Action {
      handle(data, fromStructure = false) {
        if (!data.emoji)
          return false;
        const user = this.getUserFromMember(data);
        if (!user)
          return false;
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const includePartial = this.client.options.partials.includes(Partials.Reaction);
        if (message.partial && !includePartial)
          return false;
        const reaction = message.reactions._add({
          emoji: data.emoji,
          count: message.partial ? null : 0,
          me: user.id === this.client.user.id
        });
        if (!reaction)
          return false;
        reaction._add(user);
        if (fromStructure)
          return { message, reaction, user };
        this.client.emit(Events3.MessageReactionAdd, reaction, user);
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionAdd;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageReactionRemove.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageReactionRemove = class extends Action {
      handle(data) {
        if (!data.emoji)
          return false;
        const user = this.getUser(data);
        if (!user)
          return false;
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const reaction = this.getReaction(data, message, user);
        if (!reaction)
          return false;
        reaction._remove(user);
        this.client.emit(Events3.MessageReactionRemove, reaction, user);
        return { message, reaction, user };
      }
    };
    module2.exports = MessageReactionRemove;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageReactionRemoveAll = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const removed = message.reactions.cache.clone();
        message.reactions.cache.clear();
        this.client.emit(Events3.MessageReactionRemoveAll, message, removed);
        return { message };
      }
    };
    module2.exports = MessageReactionRemoveAll;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var MessageReactionRemoveEmoji = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!(channel == null ? void 0 : channel.isTextBased()))
          return false;
        const message = this.getMessage(data, channel);
        if (!message)
          return false;
        const reaction = this.getReaction(data, message);
        if (!reaction)
          return false;
        if (!message.partial)
          message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
        this.client.emit(Events3.MessageReactionRemoveEmoji, reaction);
        return { reaction };
      }
    };
    module2.exports = MessageReactionRemoveEmoji;
  }
});

// ../../node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/MessageUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var MessageUpdateAction = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (channel) {
          if (!channel.isTextBased())
            return {};
          const { id, channel_id, guild_id, author, timestamp, type } = data;
          const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
          if (message) {
            const old = message._update(data);
            return {
              old,
              updated: message
            };
          }
        }
        return {};
      }
    };
    module2.exports = MessageUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/PresenceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var PresenceUpdateAction = class extends Action {
      handle(data) {
        var _a;
        let user = this.client.users.cache.get(data.user.id);
        if (!user && data.user.username)
          user = this.client.users._add(data.user);
        if (!user)
          return;
        if (data.user.username) {
          if (!user._equals(data.user))
            this.client.actions.UserUpdate.handle(data.user);
        }
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (!guild)
          return;
        const oldPresence = ((_a = guild.presences.cache.get(user.id)) == null ? void 0 : _a._clone()) ?? null;
        let member = guild.members.cache.get(user.id);
        if (!member && data.status !== "offline") {
          member = guild.members._add({
            user,
            deaf: false,
            mute: false
          });
          this.client.emit(Events3.GuildMemberAvailable, member);
        }
        const newPresence = guild.presences._add(Object.assign(data, { guild }));
        if (this.client.listenerCount(Events3.PresenceUpdate) && !newPresence.equals(oldPresence)) {
          this.client.emit(Events3.PresenceUpdate, oldPresence, newPresence);
        }
      }
    };
    module2.exports = PresenceUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/StageInstanceCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var StageInstanceCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events3.StageInstanceCreate, stageInstance);
          return { stageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/StageInstanceDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var StageInstanceDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const stageInstance = channel.guild.stageInstances._add(data);
          if (stageInstance) {
            channel.guild.stageInstances.cache.delete(stageInstance.id);
            client.emit(Events3.StageInstanceDelete, stageInstance);
            return { stageInstance };
          }
        }
        return {};
      }
    };
    module2.exports = StageInstanceDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/StageInstanceUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var StageInstanceUpdateAction = class extends Action {
      handle(data) {
        var _a;
        const client = this.client;
        const channel = this.getChannel(data);
        if (channel) {
          const oldStageInstance = ((_a = channel.guild.stageInstances.cache.get(data.id)) == null ? void 0 : _a._clone()) ?? null;
          const newStageInstance = channel.guild.stageInstances._add(data);
          client.emit(Events3.StageInstanceUpdate, oldStageInstance, newStageInstance);
          return { oldStageInstance, newStageInstance };
        }
        return {};
      }
    };
    module2.exports = StageInstanceUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ThreadCreate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadCreateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const existing = client.channels.cache.has(data.id);
        const thread = client.channels._add(data);
        if (!existing && thread) {
          client.emit(Events3.ThreadCreate, thread, data.newly_created ?? false);
        }
        return { thread };
      }
    };
    module2.exports = ThreadCreateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ThreadDelete.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadDeleteAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          client.channels._remove(thread.id);
          client.emit(Events3.ThreadDelete, thread);
        }
        return { thread };
      }
    };
    module2.exports = ThreadDeleteAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ThreadListSync.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadListSyncAction = class extends Action {
      handle(data) {
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (!guild)
          return {};
        if (data.channel_ids) {
          for (const id of data.channel_ids) {
            const channel = client.channels.resolve(id);
            if (channel)
              this.removeStale(channel);
          }
        } else {
          for (const channel of guild.channels.cache.values()) {
            this.removeStale(channel);
          }
        }
        const syncedThreads = data.threads.reduce((coll, rawThread) => {
          const thread = client.channels._add(rawThread);
          return coll.set(thread.id, thread);
        }, new Collection2());
        for (const rawMember of Object.values(data.members)) {
          const thread = client.channels.cache.get(rawMember.id);
          if (thread) {
            thread.members._add(rawMember);
          }
        }
        client.emit(Events3.ThreadListSync, syncedThreads, guild);
        return {
          syncedThreads
        };
      }
      removeStale(channel) {
        var _a;
        (_a = channel.threads) == null ? void 0 : _a.cache.forEach((thread) => {
          if (!thread.archived) {
            this.client.channels._remove(thread.id);
          }
        });
      }
    };
    module2.exports = ThreadListSyncAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadMemberUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          const member = thread.members.cache.get(data.user_id);
          if (!member) {
            const newMember = thread.members._add(data);
            return { newMember };
          }
          const old = member._update(data);
          client.emit(Events3.ThreadMemberUpdate, old, member);
        }
        return {};
      }
    };
    module2.exports = ThreadMemberUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Action = require_Action();
    var Events3 = require_Events();
    var ThreadMembersUpdateAction = class extends Action {
      handle(data) {
        var _a, _b;
        const client = this.client;
        const thread = client.channels.cache.get(data.id);
        if (thread) {
          thread.memberCount = data.member_count;
          const addedMembers = new Collection2();
          const removedMembers = new Collection2();
          (_a = data.added_members) == null ? void 0 : _a.reduce(
            (_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)),
            addedMembers
          );
          (_b = data.removed_member_ids) == null ? void 0 : _b.reduce((removedMembersIds, removedMembersId) => {
            const threadMember = this.getThreadMember(removedMembersId, thread.members);
            if (threadMember)
              removedMembersIds.set(threadMember.id, threadMember);
            thread.members.cache.delete(removedMembersId);
            return removedMembersIds;
          }, removedMembers);
          if (addedMembers.size === 0 && removedMembers.size === 0) {
            return {};
          }
          client.emit(Events3.ThreadMembersUpdate, addedMembers, removedMembers, thread);
        }
        return {};
      }
    };
    module2.exports = ThreadMembersUpdateAction;
  }
});

// ../../node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS({
  "../../node_modules/discord.js/src/structures/Typing.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var Typing = class extends Base {
      constructor(channel, user, data) {
        super(channel.client);
        this.channel = channel;
        this.user = user;
        this._patch(data);
      }
      _patch(data) {
        if ("timestamp" in data) {
          this.startedTimestamp = data.timestamp * 1e3;
        }
      }
      inGuild() {
        return this.guild !== null;
      }
      get startedAt() {
        return new Date(this.startedTimestamp);
      }
      get guild() {
        return this.channel.guild ?? null;
      }
      get member() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.members.resolve(this.user)) ?? null;
      }
    };
    module2.exports = Typing;
  }
});

// ../../node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS({
  "../../node_modules/discord.js/src/client/actions/TypingStart.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Typing = require_Typing();
    var Events3 = require_Events();
    var TypingStart = class extends Action {
      handle(data) {
        const channel = this.getChannel(data);
        if (!channel)
          return;
        if (!channel.isTextBased()) {
          this.client.emit(Events3.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
          return;
        }
        const user = this.getUserFromMember(data);
        if (user) {
          this.client.emit(Events3.TypingStart, new Typing(channel, user, data));
        }
      }
    };
    module2.exports = TypingStart;
  }
});

// ../../node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/UserUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var UserUpdateAction = class extends Action {
      handle(data) {
        const client = this.client;
        const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
        const oldUser = newUser._update(data);
        if (!oldUser.equals(newUser)) {
          client.emit(Events3.UserUpdate, oldUser, newUser);
          return {
            old: oldUser,
            updated: newUser
          };
        }
        return {
          old: null,
          updated: null
        };
      }
    };
    module2.exports = UserUpdateAction;
  }
});

// ../../node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/VoiceStateUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var VoiceState = require_VoiceState();
    var Events3 = require_Events();
    var VoiceStateUpdate = class extends Action {
      handle(data) {
        var _a, _b;
        const client = this.client;
        const guild = client.guilds.cache.get(data.guild_id);
        if (guild) {
          const oldState = ((_a = guild.voiceStates.cache.get(data.user_id)) == null ? void 0 : _a._clone()) ?? new VoiceState(guild, { user_id: data.user_id });
          const newState = guild.voiceStates._add(data);
          let member = guild.members.cache.get(data.user_id);
          if (member && data.member) {
            member._patch(data.member);
          } else if (((_b = data.member) == null ? void 0 : _b.user) && data.member.joined_at) {
            member = guild.members._add(data.member);
          }
          if ((member == null ? void 0 : member.user.id) === client.user.id) {
            client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
            client.voice.onVoiceStateUpdate(data);
          }
          client.emit(Events3.VoiceStateUpdate, oldState, newState);
        }
      }
    };
    module2.exports = VoiceStateUpdate;
  }
});

// ../../node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS({
  "../../node_modules/discord.js/src/client/actions/WebhooksUpdate.js"(exports2, module2) {
    "use strict";
    var Action = require_Action();
    var Events3 = require_Events();
    var WebhooksUpdate = class extends Action {
      handle(data) {
        const client = this.client;
        const channel = client.channels.cache.get(data.channel_id);
        if (channel)
          client.emit(Events3.WebhooksUpdate, channel);
      }
    };
    module2.exports = WebhooksUpdate;
  }
});

// ../../node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS({
  "../../node_modules/discord.js/src/client/actions/ActionsManager.js"(exports2, module2) {
    "use strict";
    var ActionsManager2 = class {
      constructor(client) {
        this.client = client;
        this.register(require_ApplicationCommandPermissionsUpdate());
        this.register(require_ChannelCreate());
        this.register(require_ChannelDelete());
        this.register(require_ChannelUpdate());
        this.register(require_GuildBanAdd());
        this.register(require_GuildBanRemove());
        this.register(require_GuildChannelsPositionUpdate());
        this.register(require_GuildDelete());
        this.register(require_GuildEmojiCreate());
        this.register(require_GuildEmojiDelete());
        this.register(require_GuildEmojiUpdate());
        this.register(require_GuildEmojisUpdate());
        this.register(require_GuildIntegrationsUpdate());
        this.register(require_GuildMemberRemove());
        this.register(require_GuildMemberUpdate());
        this.register(require_GuildRoleCreate());
        this.register(require_GuildRoleDelete());
        this.register(require_GuildRoleUpdate());
        this.register(require_GuildRolesPositionUpdate());
        this.register(require_GuildScheduledEventCreate());
        this.register(require_GuildScheduledEventDelete());
        this.register(require_GuildScheduledEventUpdate());
        this.register(require_GuildScheduledEventUserAdd());
        this.register(require_GuildScheduledEventUserRemove());
        this.register(require_GuildStickerCreate());
        this.register(require_GuildStickerDelete());
        this.register(require_GuildStickerUpdate());
        this.register(require_GuildStickersUpdate());
        this.register(require_GuildUpdate());
        this.register(require_InteractionCreate());
        this.register(require_InviteCreate());
        this.register(require_InviteDelete());
        this.register(require_MessageCreate());
        this.register(require_MessageDelete());
        this.register(require_MessageDeleteBulk());
        this.register(require_MessageReactionAdd());
        this.register(require_MessageReactionRemove());
        this.register(require_MessageReactionRemoveAll());
        this.register(require_MessageReactionRemoveEmoji());
        this.register(require_MessageUpdate());
        this.register(require_PresenceUpdate());
        this.register(require_StageInstanceCreate());
        this.register(require_StageInstanceDelete());
        this.register(require_StageInstanceUpdate());
        this.register(require_ThreadCreate());
        this.register(require_ThreadDelete());
        this.register(require_ThreadListSync());
        this.register(require_ThreadMemberUpdate());
        this.register(require_ThreadMembersUpdate());
        this.register(require_TypingStart());
        this.register(require_UserUpdate());
        this.register(require_VoiceStateUpdate());
        this.register(require_WebhooksUpdate());
      }
      register(Action) {
        this[Action.name.replace(/Action$/, "")] = new Action(this.client);
      }
    };
    module2.exports = ActionsManager2;
  }
});

// ../../node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS({
  "../../node_modules/discord.js/src/client/voice/ClientVoiceManager.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    var ClientVoiceManager2 = class {
      constructor(client) {
        Object.defineProperty(this, "client", { value: client });
        this.adapters = /* @__PURE__ */ new Map();
        client.on(Events3.ShardDisconnect, (_, shardId) => {
          var _a;
          for (const [guildId, adapter] of this.adapters.entries()) {
            if (((_a = client.guilds.cache.get(guildId)) == null ? void 0 : _a.shardId) === shardId) {
              adapter.destroy();
            }
          }
        });
      }
      onVoiceServer(payload) {
        var _a;
        (_a = this.adapters.get(payload.guild_id)) == null ? void 0 : _a.onVoiceServerUpdate(payload);
      }
      onVoiceStateUpdate(payload) {
        var _a, _b;
        if (payload.guild_id && payload.session_id && payload.user_id === ((_a = this.client.user) == null ? void 0 : _a.id)) {
          (_b = this.adapters.get(payload.guild_id)) == null ? void 0 : _b.onVoiceStateUpdate(payload);
        }
      }
    };
    module2.exports = ClientVoiceManager2;
  }
});

// ../../node_modules/ws/lib/constants.js
var require_constants3 = __commonJS({
  "../../node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// ../../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../../node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants3();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../../node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../../node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants3();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../../node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// ../../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../../node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants3();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(options = {}) {
        super();
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
          }
          if (compressed) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          }
        } else {
          this._loop = false;
          return error(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
          }
        } else if (this._masked) {
          this._loop = false;
          return error(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(
                error(
                  RangeError,
                  "Max payload size exceeded",
                  false,
                  1009,
                  "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                )
              );
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data, true);
          } else {
            const buf = concat(fragments, messageLength);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              this._loop = false;
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("message", buf, false);
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else if (data.length === 1) {
            return error(
              RangeError,
              "invalid payload length 1",
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
            }
            const buf = data.slice(2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              return error(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
            }
            this.emit("conclude", code, buf);
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(
        prefix ? `Invalid WebSocket frame: ${message}` : message
      );
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// ../../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../../node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants3();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            randomFillSync(mask, 0, 4);
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask)
          return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking)
          return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false
            }),
            cb
          );
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// ../../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../../node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants3();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      get target() {
        return this[kTarget];
      }
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      get code() {
        return this[kCode];
      }
      get reason() {
        return this[kReason];
      }
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      get error() {
        return this[kError];
      }
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      addEventListener(type, listener, options = {}) {
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event2 = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event2[kTarget] = this;
            listener.call(this, event2);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event2 = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event2[kTarget] = this;
            listener.call(this, event2);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event2 = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event2[kTarget] = this;
            listener.call(this, event2);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event2 = new Event("open");
            event2[kTarget] = this;
            listener.call(this, event2);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = listener;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
  }
});

// ../../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../../node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse2(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions2) {
      return Object.keys(extensions2).map((extension) => {
        let configurations = extensions2[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values))
                values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse2 };
  }
});

// ../../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../../node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants3();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse2 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get isPaused() {
        return this._paused;
      }
      get onclose() {
        return null;
      }
      get onerror() {
        return null;
      }
      get onopen() {
        return null;
      }
      get onmessage() {
        return null;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(
          this._socket.destroy.bind(this._socket),
          closeTimeout
        );
      }
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain)
          this._socket.resume();
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute])
              return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function")
            return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
        websocket._url = address;
      }
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost)
              delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted])
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        if (res.headers.upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions2;
          try {
            extensions2 = parse2(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions2);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions2[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      req.end();
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused)
        websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../../node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "../../node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data))
          ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close2() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close2() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused)
          ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open2() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// ../../node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "../../node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse2(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse2 };
  }
});

// ../../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../../node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket = require_websocket();
    var { GUID, kWebSocket } = require_constants3();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = {
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const version2 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (req.headers.upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!key || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version2 !== 8 && version2 !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions2[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req, socket, head, cb);
      }
      completeUpgrade(extensions2, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate.extensionName]) {
          const params = extensions2[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event2 of Object.keys(map))
        server.on(event2, map[event2]);
      return function removeListeners() {
        for (const event2 of Object.keys(map)) {
          server.removeListener(event2, map[event2]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
  }
});

// ../../node_modules/ws/index.js
var require_ws = __commonJS({
  "../../node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    WebSocket.WebSocket = WebSocket;
    WebSocket.WebSocketServer = WebSocket.Server;
    module2.exports = WebSocket;
  }
});

// ../../node_modules/discord.js/src/WebSocket.js
var require_WebSocket = __commonJS({
  "../../node_modules/discord.js/src/WebSocket.js"(exports2) {
    "use strict";
    var erlpack;
    var { Buffer: Buffer5 } = require("buffer");
    try {
      erlpack = require("erlpack");
      if (!erlpack.pack)
        erlpack = null;
    } catch {
    }
    exports2.WebSocket = require_ws();
    var ab = new TextDecoder();
    exports2.encoding = erlpack ? "etf" : "json";
    exports2.pack = erlpack ? erlpack.pack : JSON.stringify;
    exports2.unpack = (data, type) => {
      if (exports2.encoding === "json" || type === "json") {
        if (typeof data !== "string") {
          data = ab.decode(data);
        }
        return JSON.parse(data);
      }
      if (!Buffer5.isBuffer(data))
        data = Buffer5.from(new Uint8Array(data));
      return erlpack.unpack(data);
    };
    exports2.create = (gateway, query = {}, ...args) => {
      const [g, q] = gateway.split("?");
      query.encoding = exports2.encoding;
      query = new URLSearchParams(query);
      if (q)
        new URLSearchParams(q).forEach((v, k) => query.set(k, v));
      const ws = new exports2.WebSocket(`${g}?${query}`, ...args);
      return ws;
    };
    for (const state of ["CONNECTING", "OPEN", "CLOSING", "CLOSED"])
      exports2[state] = exports2.WebSocket[state];
  }
});

// ../../node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS({
  "../../node_modules/discord.js/src/util/WebSocketShardEvents.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Close: "close",
      Destroyed: "destroyed",
      InvalidSession: "invalidSession",
      Ready: "ready",
      Resumed: "resumed",
      AllReady: "allReady"
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/WebSocketShard.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var { setTimeout: setTimeout2, setInterval, clearTimeout: clearTimeout2, clearInterval } = require("timers");
    var { GatewayDispatchEvents, GatewayIntentBits, GatewayOpcodes } = require_v106();
    var WebSocket = require_WebSocket();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var WebSocketShardEvents = require_WebSocketShardEvents();
    var STATUS_KEYS = Object.keys(Status2);
    var CONNECTION_STATE = Object.keys(WebSocket.WebSocket);
    var zlib;
    try {
      zlib = require("zlib-sync");
    } catch {
    }
    var WebSocketShard = class extends EventEmitter {
      constructor(manager, id) {
        super();
        this.manager = manager;
        this.id = id;
        this.status = Status2.Idle;
        this.sequence = -1;
        this.closeSequence = 0;
        this.sessionId = null;
        this.ping = -1;
        this.lastPingTimestamp = -1;
        this.lastHeartbeatAcked = true;
        this.closeEmitted = false;
        Object.defineProperty(this, "ratelimit", {
          value: {
            queue: [],
            total: 120,
            remaining: 120,
            time: 6e4,
            timer: null
          }
        });
        Object.defineProperty(this, "connection", { value: null, writable: true });
        Object.defineProperty(this, "inflate", { value: null, writable: true });
        Object.defineProperty(this, "helloTimeout", { value: null, writable: true });
        Object.defineProperty(this, "wsCloseTimeout", { value: null, writable: true });
        Object.defineProperty(this, "eventsAttached", { value: false, writable: true });
        Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
        Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
        Object.defineProperty(this, "connectedAt", { value: 0, writable: true });
      }
      debug(message) {
        this.manager.debug(message, this);
      }
      connect() {
        var _a;
        const { gateway, client } = this.manager;
        if (((_a = this.connection) == null ? void 0 : _a.readyState) === WebSocket.OPEN && this.status === Status2.Ready) {
          return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
          var _a2;
          const cleanup = () => {
            this.removeListener(WebSocketShardEvents.Close, onClose);
            this.removeListener(WebSocketShardEvents.Ready, onReady);
            this.removeListener(WebSocketShardEvents.Resumed, onResumed);
            this.removeListener(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);
            this.removeListener(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);
          };
          const onReady = () => {
            cleanup();
            resolve();
          };
          const onResumed = () => {
            cleanup();
            resolve();
          };
          const onClose = (event2) => {
            cleanup();
            reject(event2);
          };
          const onInvalidOrDestroyed = () => {
            cleanup();
            reject();
          };
          this.once(WebSocketShardEvents.Ready, onReady);
          this.once(WebSocketShardEvents.Resumed, onResumed);
          this.once(WebSocketShardEvents.Close, onClose);
          this.once(WebSocketShardEvents.InvalidSession, onInvalidOrDestroyed);
          this.once(WebSocketShardEvents.Destroyed, onInvalidOrDestroyed);
          if (((_a2 = this.connection) == null ? void 0 : _a2.readyState) === WebSocket.OPEN) {
            this.debug("An open connection was found, attempting an immediate identify.");
            this.identify();
            return;
          }
          if (this.connection) {
            this.debug(`A connection object was found. Cleaning up before continuing.
    State: ${CONNECTION_STATE[this.connection.readyState]}`);
            this.destroy({ emit: false });
          }
          const wsQuery = { v: client.options.ws.version };
          if (zlib) {
            this.inflate = new zlib.Inflate({
              chunkSize: 65535,
              flush: zlib.Z_SYNC_FLUSH,
              to: WebSocket.encoding === "json" ? "string" : ""
            });
            wsQuery.compress = "zlib-stream";
          }
          this.debug(
            `[CONNECT]
    Gateway    : ${gateway}
    Version    : ${client.options.ws.version}
    Encoding   : ${WebSocket.encoding}
    Compression: ${zlib ? "zlib-stream" : "none"}`
          );
          this.status = this.status === Status2.Disconnected ? Status2.Reconnecting : Status2.Connecting;
          this.setHelloTimeout();
          this.connectedAt = Date.now();
          const ws = this.connection = WebSocket.create(gateway, wsQuery, { handshakeTimeout: 3e4 });
          ws.onopen = this.onOpen.bind(this);
          ws.onmessage = this.onMessage.bind(this);
          ws.onerror = this.onError.bind(this);
          ws.onclose = this.onClose.bind(this);
        });
      }
      onOpen() {
        this.debug(`[CONNECTED] Took ${Date.now() - this.connectedAt}ms`);
        this.status = Status2.Nearly;
      }
      onMessage({ data }) {
        let raw;
        if (data instanceof ArrayBuffer)
          data = new Uint8Array(data);
        if (zlib) {
          const l = data.length;
          const flush = l >= 4 && data[l - 4] === 0 && data[l - 3] === 0 && data[l - 2] === 255 && data[l - 1] === 255;
          this.inflate.push(data, flush && zlib.Z_SYNC_FLUSH);
          if (!flush)
            return;
          raw = this.inflate.result;
        } else {
          raw = data;
        }
        let packet;
        try {
          packet = WebSocket.unpack(raw);
        } catch (err) {
          this.manager.client.emit(Events3.ShardError, err, this.id);
          return;
        }
        this.manager.client.emit(Events3.Raw, packet, this.id);
        if (packet.op === GatewayOpcodes.Dispatch)
          this.manager.emit(packet.t, packet.d, this.id);
        this.onPacket(packet);
      }
      onError(event2) {
        const error = (event2 == null ? void 0 : event2.error) ?? event2;
        if (!error)
          return;
        this.manager.client.emit(Events3.ShardError, error, this.id);
      }
      onClose(event2) {
        this.closeEmitted = true;
        if (this.sequence !== -1)
          this.closeSequence = this.sequence;
        this.sequence = -1;
        this.setHeartbeatTimer(-1);
        this.setHelloTimeout(-1);
        this.setWsCloseTimeout(-1);
        if (this.connection)
          this._cleanupConnection();
        this.status = Status2.Disconnected;
        this.emitClose(event2);
      }
      emitClose(event2 = {
        code: 1011,
        reason: "INTERNAL_ERROR",
        wasClean: false
      }) {
        this.debug(`[CLOSE]
    Event Code: ${event2.code}
    Clean     : ${event2.wasClean}
    Reason    : ${event2.reason ?? "No reason received"}`);
        this.emit(WebSocketShardEvents.Close, event2);
      }
      onPacket(packet) {
        if (!packet) {
          this.debug(`Received broken packet: '${packet}'.`);
          return;
        }
        switch (packet.t) {
          case GatewayDispatchEvents.Ready:
            this.emit(WebSocketShardEvents.Ready);
            this.sessionId = packet.d.session_id;
            this.expectedGuilds = new Set(packet.d.guilds.map((d) => d.id));
            this.status = Status2.WaitingForGuilds;
            this.debug(`[READY] Session ${this.sessionId}.`);
            this.lastHeartbeatAcked = true;
            this.sendHeartbeat("ReadyHeartbeat");
            break;
          case GatewayDispatchEvents.Resumed: {
            this.emit(WebSocketShardEvents.Resumed);
            this.status = Status2.Ready;
            const replayed = packet.s - this.closeSequence;
            this.debug(`[RESUMED] Session ${this.sessionId} | Replayed ${replayed} events.`);
            this.lastHeartbeatAcked = true;
            this.sendHeartbeat("ResumeHeartbeat");
            break;
          }
        }
        if (packet.s > this.sequence)
          this.sequence = packet.s;
        switch (packet.op) {
          case GatewayOpcodes.Hello:
            this.setHelloTimeout(-1);
            this.setHeartbeatTimer(packet.d.heartbeat_interval);
            this.identify();
            break;
          case GatewayOpcodes.Reconnect:
            this.debug("[RECONNECT] Discord asked us to reconnect");
            this.destroy({ closeCode: 4e3 });
            break;
          case GatewayOpcodes.InvalidSession:
            this.debug(`[INVALID SESSION] Resumable: ${packet.d}.`);
            if (packet.d) {
              this.identifyResume();
              return;
            }
            this.sequence = -1;
            this.sessionId = null;
            this.status = Status2.Reconnecting;
            this.emit(WebSocketShardEvents.InvalidSession);
            break;
          case GatewayOpcodes.HeartbeatAck:
            this.ackHeartbeat();
            break;
          case GatewayOpcodes.Heartbeat:
            this.sendHeartbeat("HeartbeatRequest", true);
            break;
          default:
            this.manager.handlePacket(packet, this);
            if (this.status === Status2.WaitingForGuilds && packet.t === GatewayDispatchEvents.GuildCreate) {
              this.expectedGuilds.delete(packet.d.id);
              this.checkReady();
            }
        }
      }
      checkReady() {
        if (this.readyTimeout) {
          clearTimeout2(this.readyTimeout);
          this.readyTimeout = null;
        }
        if (!this.expectedGuilds.size) {
          this.debug("Shard received all its guilds. Marking as fully ready.");
          this.status = Status2.Ready;
          this.emit(WebSocketShardEvents.AllReady);
          return;
        }
        const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
        const { waitGuildTimeout } = this.manager.client.options;
        this.readyTimeout = setTimeout2(
          () => {
            this.debug(
              `Shard ${hasGuildsIntent ? "did" : "will"} not receive any more guild packets${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ""}.
Unavailable guild count: ${this.expectedGuilds.size}`
            );
            this.readyTimeout = null;
            this.status = Status2.Ready;
            this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
          },
          hasGuildsIntent ? waitGuildTimeout : 0
        ).unref();
      }
      setHelloTimeout(time) {
        if (time === -1) {
          if (this.helloTimeout) {
            this.debug("Clearing the HELLO timeout.");
            clearTimeout2(this.helloTimeout);
            this.helloTimeout = null;
          }
          return;
        }
        this.debug("Setting a HELLO timeout for 20s.");
        this.helloTimeout = setTimeout2(() => {
          this.debug("Did not receive HELLO in time. Destroying and connecting again.");
          this.destroy({ reset: true, closeCode: 4009 });
        }, 2e4).unref();
      }
      setWsCloseTimeout(time) {
        if (this.wsCloseTimeout) {
          this.debug("[WebSocket] Clearing the close timeout.");
          clearTimeout2(this.wsCloseTimeout);
        }
        if (time === -1) {
          this.wsCloseTimeout = null;
          return;
        }
        this.wsCloseTimeout = setTimeout2(() => {
          var _a;
          this.setWsCloseTimeout(-1);
          this.debug(`[WebSocket] Close Emitted: ${this.closeEmitted}`);
          if (this.closeEmitted) {
            this.debug(
              `[WebSocket] was closed. | WS State: ${CONNECTION_STATE[((_a = this.connection) == null ? void 0 : _a.readyState) ?? WebSocket.CLOSED]} | Close Emitted: ${this.closeEmitted}`
            );
            this.closeEmitted = false;
            return;
          }
          this.debug(
            `[WebSocket] did not close properly, assuming a zombie connection.
Emitting close and reconnecting again.`
          );
          this.emitClose();
          this.closeEmitted = false;
        }, time).unref();
      }
      setHeartbeatTimer(time) {
        if (time === -1) {
          if (this.heartbeatInterval) {
            this.debug("Clearing the heartbeat interval.");
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }
          return;
        }
        this.debug(`Setting a heartbeat interval for ${time}ms.`);
        if (this.heartbeatInterval)
          clearInterval(this.heartbeatInterval);
        this.heartbeatInterval = setInterval(() => this.sendHeartbeat(), time).unref();
      }
      sendHeartbeat(tag = "HeartbeatTimer", ignoreHeartbeatAck = [Status2.WaitingForGuilds, Status2.Identifying, Status2.Resuming].includes(this.status)) {
        if (ignoreHeartbeatAck && !this.lastHeartbeatAcked) {
          this.debug(`[${tag}] Didn't process heartbeat ack yet but we are still connected. Sending one now.`);
        } else if (!this.lastHeartbeatAcked) {
          this.debug(
            `[${tag}] Didn't receive a heartbeat ack last time, assuming zombie connection. Destroying and reconnecting.
    Status          : ${STATUS_KEYS[this.status]}
    Sequence        : ${this.sequence}
    Connection State: ${this.connection ? CONNECTION_STATE[this.connection.readyState] : "No Connection??"}`
          );
          this.destroy({ reset: true, closeCode: 4009 });
          return;
        }
        this.debug(`[${tag}] Sending a heartbeat.`);
        this.lastHeartbeatAcked = false;
        this.lastPingTimestamp = Date.now();
        this.send({ op: GatewayOpcodes.Heartbeat, d: this.sequence }, true);
      }
      ackHeartbeat() {
        this.lastHeartbeatAcked = true;
        const latency = Date.now() - this.lastPingTimestamp;
        this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`);
        this.ping = latency;
      }
      identify() {
        return this.sessionId ? this.identifyResume() : this.identifyNew();
      }
      identifyNew() {
        const { client } = this.manager;
        if (!client.token) {
          this.debug("[IDENTIFY] No token available to identify a new session.");
          return;
        }
        this.status = Status2.Identifying;
        const d = {
          ...client.options.ws,
          intents: client.options.intents.bitfield,
          token: client.token,
          shard: [this.id, Number(client.options.shardCount)]
        };
        this.debug(`[IDENTIFY] Shard ${this.id}/${client.options.shardCount} with intents: ${d.intents}`);
        this.send({ op: GatewayOpcodes.Identify, d }, true);
      }
      identifyResume() {
        if (!this.sessionId) {
          this.debug("[RESUME] No session id was present; identifying as a new session.");
          this.identifyNew();
          return;
        }
        this.status = Status2.Resuming;
        this.debug(`[RESUME] Session ${this.sessionId}, sequence ${this.closeSequence}`);
        const d = {
          token: this.manager.client.token,
          session_id: this.sessionId,
          seq: this.closeSequence
        };
        this.send({ op: GatewayOpcodes.Resume, d }, true);
      }
      send(data, important = false) {
        this.ratelimit.queue[important ? "unshift" : "push"](data);
        this.processQueue();
      }
      _send(data) {
        var _a;
        if (((_a = this.connection) == null ? void 0 : _a.readyState) !== WebSocket.OPEN) {
          this.debug(`Tried to send packet '${JSON.stringify(data)}' but no WebSocket is available!`);
          this.destroy({ closeCode: 4e3 });
          return;
        }
        this.connection.send(WebSocket.pack(data), (err) => {
          if (err)
            this.manager.client.emit(Events3.ShardError, err, this.id);
        });
      }
      processQueue() {
        if (this.ratelimit.remaining === 0)
          return;
        if (this.ratelimit.queue.length === 0)
          return;
        if (this.ratelimit.remaining === this.ratelimit.total) {
          this.ratelimit.timer = setTimeout2(() => {
            this.ratelimit.remaining = this.ratelimit.total;
            this.processQueue();
          }, this.ratelimit.time).unref();
        }
        while (this.ratelimit.remaining > 0) {
          const item = this.ratelimit.queue.shift();
          if (!item)
            return;
          this._send(item);
          this.ratelimit.remaining--;
        }
      }
      destroy({ closeCode = 1e3, reset = false, emit = true, log = true } = {}) {
        var _a, _b, _c;
        if (log) {
          this.debug(`[DESTROY]
    Close Code    : ${closeCode}
    Reset         : ${reset}
    Emit DESTROYED: ${emit}`);
        }
        this.setHeartbeatTimer(-1);
        this.setHelloTimeout(-1);
        this.debug(
          `[WebSocket] Destroy: Attempting to close the WebSocket. | WS State: ${CONNECTION_STATE[((_a = this.connection) == null ? void 0 : _a.readyState) ?? WebSocket.CLOSED]}`
        );
        if (this.connection) {
          if (this.connection.readyState === WebSocket.OPEN) {
            this.connection.close(closeCode);
            this.debug(`[WebSocket] Close: Tried closing. | WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
          } else {
            this.debug(`WS State: ${CONNECTION_STATE[this.connection.readyState]}`);
            this._cleanupConnection();
            try {
              this.connection.close(closeCode);
            } catch (err) {
              this.debug(
                `[WebSocket] Close: Something went wrong while closing the WebSocket: ${err.message || err}. Forcefully terminating the connection | WS State: ${CONNECTION_STATE[this.connection.readyState]}`
              );
              this.connection.terminate();
            }
            if (emit)
              this._emitDestroyed();
          }
        } else if (emit) {
          this._emitDestroyed();
        }
        if (((_b = this.connection) == null ? void 0 : _b.readyState) === WebSocket.CLOSING || ((_c = this.connection) == null ? void 0 : _c.readyState) === WebSocket.CLOSED) {
          this.closeEmitted = false;
          this.debug(
            `[WebSocket] Adding a WebSocket close timeout to ensure a correct WS reconnect.
        Timeout: ${this.manager.client.options.closeTimeout}ms`
          );
          this.setWsCloseTimeout(this.manager.client.options.closeTimeout);
        }
        this.connection = null;
        this.status = Status2.Disconnected;
        if (this.sequence !== -1)
          this.closeSequence = this.sequence;
        if (reset) {
          this.sequence = -1;
          this.sessionId = null;
        }
        this.ratelimit.remaining = this.ratelimit.total;
        this.ratelimit.queue.length = 0;
        if (this.ratelimit.timer) {
          clearTimeout2(this.ratelimit.timer);
          this.ratelimit.timer = null;
        }
      }
      _cleanupConnection() {
        this.connection.onopen = this.connection.onclose = this.connection.onmessage = null;
        this.connection.onerror = () => null;
      }
      _emitDestroyed() {
        this.emit(WebSocketShardEvents.Destroyed);
      }
    };
    module2.exports = WebSocketShard;
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ChannelDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, { d: data }) => {
      const channel = client.channels.cache.get(data.channel_id);
      const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      if (channel) {
        channel.lastPinTimestamp = time;
        client.emit(Events3.ChannelPinsUpdate, channel, time);
      }
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events3.ChannelUpdate, old, updated);
      }
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanAdd.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildBanRemove.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    var Status2 = require_Status();
    module2.exports = (client, { d: data }, shard) => {
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (!guild.available && !data.unavailable) {
          guild._patch(data);
        }
      } else {
        data.shardId = shard.id;
        guild = client.guilds._add(data);
        if (client.ws.status === Status2.Ready) {
          client.emit(Events3.GuildCreate, guild);
        }
      }
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildEmojisUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildIntegrationsUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var Events3 = require_Events();
    module2.exports = (client, { d: data }) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const members = new Collection2();
      for (const member of data.members)
        members.set(member.user.id, guild.members._add(member));
      if (data.presences) {
        for (const presence of data.presences)
          guild.presences._add(Object.assign(presence, { guild }));
      }
      client.emit(Events3.GuildMembersChunk, members, guild, {
        count: data.chunk_count,
        index: data.chunk_index,
        nonce: data.nonce
      });
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    var Status2 = require_Status();
    module2.exports = (client, { d: data }, shard) => {
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        guild.memberCount++;
        const member = guild.members._add(data);
        if (shard.status === Status2.Ready) {
          client.emit(Events3.GuildMemberAdd, member);
        }
      }
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberRemove.handle(packet.d, shard);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet, shard) => {
      client.actions.GuildMemberUpdate.handle(packet.d, shard);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildRoleUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserAdd.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildScheduledEventUserRemove.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildStickersUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.GuildUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InteractionCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.InviteDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageDeleteBulk.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionAdd.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemove.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveAll.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.MessageReactionRemoveEmoji.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events3.MessageUpdate, old, updated);
      }
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.PresenceUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS({
  "../../node_modules/discord.js/src/structures/ClientUser.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var User = require_User();
    var DataResolver2 = require_DataResolver();
    var ClientUser = class extends User {
      _patch(data) {
        super._patch(data);
        if ("verified" in data) {
          this.verified = data.verified;
        }
        if ("mfa_enabled" in data) {
          this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
        } else {
          this.mfaEnabled ?? (this.mfaEnabled = null);
        }
        if ("token" in data)
          this.client.token = data.token;
      }
      get presence() {
        return this.client.presence;
      }
      async edit(data) {
        if (typeof data.avatar !== "undefined")
          data.avatar = await DataResolver2.resolveImage(data.avatar);
        const newData = await this.client.rest.patch(Routes3.user(), { body: data });
        this.client.token = newData.token;
        this.client.rest.setToken(newData.token);
        const { updated } = this.client.actions.UserUpdate.handle(newData);
        return updated ?? this;
      }
      setUsername(username) {
        return this.edit({ username });
      }
      setAvatar(avatar) {
        return this.edit({ avatar });
      }
      setPresence(data) {
        return this.client.presence.set(data);
      }
      setStatus(status, shardId) {
        return this.setPresence({ status, shardId });
      }
      setActivity(name, options = {}) {
        if (!name)
          return this.setPresence({ activities: [], shardId: options.shardId });
        const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
        return this.setPresence({ activities: [activity], shardId: activity.shardId });
      }
      setAFK(afk = true, shardId) {
        return this.setPresence({ afk, shardId });
      }
    };
    module2.exports = ClientUser;
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/READY.js"(exports2, module2) {
    "use strict";
    var ClientApplication = require_ClientApplication();
    var ClientUser;
    module2.exports = (client, { d: data }, shard) => {
      if (client.user) {
        client.user._patch(data.user);
      } else {
        ClientUser ?? (ClientUser = require_ClientUser());
        client.user = new ClientUser(client, data.user);
        client.users.cache.set(client.user.id, client.user);
      }
      for (const guild of data.guilds) {
        guild.shardId = shard.id;
        client.guilds._add(guild);
      }
      if (client.application) {
        client.application._patch(data.application);
      } else {
        client.application = new ClientApplication(client, data.application);
      }
      shard.checkReady();
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/RESUMED.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet, shard) => {
      const replayed = shard.sequence - shard.closeSequence;
      client.emit(Events3.ShardResume, shard.id, replayed);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.StageInstanceUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadCreate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadDelete.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadListSync.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMembersUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.ThreadMemberUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js"(exports2, module2) {
    "use strict";
    var Events3 = require_Events();
    module2.exports = (client, packet) => {
      const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
      if (old && updated) {
        client.emit(Events3.ThreadUpdate, old, updated);
      }
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.TypingStart.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.UserUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
      client.voice.onVoiceServer(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.VoiceStateUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js"(exports2, module2) {
    "use strict";
    module2.exports = (client, packet) => {
      client.actions.WebhooksUpdate.handle(packet.d);
    };
  }
});

// ../../node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/handlers/index.js"(exports2, module2) {
    "use strict";
    var handlers = Object.fromEntries([
      ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
      ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
      ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
      ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
      ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
      ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
      ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
      ["GUILD_CREATE", require_GUILD_CREATE()],
      ["GUILD_DELETE", require_GUILD_DELETE()],
      ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
      ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
      ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
      ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
      ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
      ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
      ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
      ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
      ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
      ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
      ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
      ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
      ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
      ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
      ["GUILD_UPDATE", require_GUILD_UPDATE()],
      ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
      ["INVITE_CREATE", require_INVITE_CREATE()],
      ["INVITE_DELETE", require_INVITE_DELETE()],
      ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
      ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
      ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
      ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
      ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
      ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
      ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
      ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
      ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
      ["READY", require_READY()],
      ["RESUMED", require_RESUMED()],
      ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
      ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
      ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
      ["THREAD_CREATE", require_THREAD_CREATE()],
      ["THREAD_DELETE", require_THREAD_DELETE()],
      ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
      ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
      ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
      ["THREAD_UPDATE", require_THREAD_UPDATE()],
      ["TYPING_START", require_TYPING_START()],
      ["USER_UPDATE", require_USER_UPDATE()],
      ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
      ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
      ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
    ]);
    module2.exports = handlers;
  }
});

// ../../node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS({
  "../../node_modules/discord.js/src/client/websocket/WebSocketManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var { setImmediate: setImmediate2 } = require("timers");
    var { setTimeout: sleep } = require("timers/promises");
    var { Collection: Collection2 } = require_dist();
    var { GatewayCloseCodes, GatewayDispatchEvents, Routes: Routes3 } = require_v106();
    var WebSocketShard = require_WebSocketShard();
    var PacketHandlers = require_handlers();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Events3 = require_Events();
    var Status2 = require_Status();
    var WebSocketShardEvents = require_WebSocketShardEvents();
    var BeforeReadyWhitelist = [
      GatewayDispatchEvents.Ready,
      GatewayDispatchEvents.Resumed,
      GatewayDispatchEvents.GuildCreate,
      GatewayDispatchEvents.GuildDelete,
      GatewayDispatchEvents.GuildMembersChunk,
      GatewayDispatchEvents.GuildMemberAdd,
      GatewayDispatchEvents.GuildMemberRemove
    ];
    var unrecoverableErrorCodeMap = {
      [GatewayCloseCodes.AuthenticationFailed]: ErrorCodes2.TokenInvalid,
      [GatewayCloseCodes.InvalidShard]: ErrorCodes2.ShardingInvalid,
      [GatewayCloseCodes.ShardingRequired]: ErrorCodes2.ShardingRequired,
      [GatewayCloseCodes.InvalidIntents]: ErrorCodes2.InvalidIntents,
      [GatewayCloseCodes.DisallowedIntents]: ErrorCodes2.DisallowedIntents
    };
    var UNRESUMABLE_CLOSE_CODES = [1e3, GatewayCloseCodes.AlreadyAuthenticated, GatewayCloseCodes.InvalidSeq];
    var WebSocketManager2 = class extends EventEmitter {
      constructor(client) {
        super();
        Object.defineProperty(this, "client", { value: client });
        this.gateway = null;
        this.totalShards = this.client.options.shards.length;
        this.shards = new Collection2();
        Object.defineProperty(this, "shardQueue", { value: /* @__PURE__ */ new Set(), writable: true });
        Object.defineProperty(this, "packetQueue", { value: [] });
        this.status = Status2.Idle;
        this.destroyed = false;
        this.reconnecting = false;
      }
      get ping() {
        const sum = this.shards.reduce((a, b) => a + b.ping, 0);
        return sum / this.shards.size;
      }
      debug(message, shard) {
        this.client.emit(Events3.Debug, `[WS => ${shard ? `Shard ${shard.id}` : "Manager"}] ${message}`);
      }
      async connect() {
        const invalidToken = new DiscordjsError2(ErrorCodes2.TokenInvalid);
        const {
          url: gatewayURL,
          shards: recommendedShards,
          session_start_limit: sessionStartLimit
        } = await this.client.rest.get(Routes3.gatewayBot()).catch((error) => {
          throw error.status === 401 ? invalidToken : error;
        });
        const { total, remaining } = sessionStartLimit;
        this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
        this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
        this.gateway = `${gatewayURL}/`;
        let { shards } = this.client.options;
        if (shards === "auto") {
          this.debug(`Using the recommended shard count provided by Discord: ${recommendedShards}`);
          this.totalShards = this.client.options.shardCount = recommendedShards;
          shards = this.client.options.shards = Array.from({ length: recommendedShards }, (_, i) => i);
        }
        this.totalShards = shards.length;
        this.debug(`Spawning shards: ${shards.join(", ")}`);
        this.shardQueue = new Set(shards.map((id) => new WebSocketShard(this, id)));
        return this.createShards();
      }
      async createShards() {
        if (!this.shardQueue.size)
          return false;
        const [shard] = this.shardQueue;
        this.shardQueue.delete(shard);
        if (!shard.eventsAttached) {
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events3.ShardReady, shard.id, unavailableGuilds);
            if (!this.shardQueue.size)
              this.reconnecting = false;
            this.checkShardsReady();
          });
          shard.on(WebSocketShardEvents.Close, (event2) => {
            if (event2.code === 1e3 ? this.destroyed : event2.code in unrecoverableErrorCodeMap) {
              this.client.emit(Events3.ShardDisconnect, event2, shard.id);
              this.debug(GatewayCloseCodes[event2.code], shard);
              return;
            }
            if (UNRESUMABLE_CLOSE_CODES.includes(event2.code)) {
              shard.sessionId = null;
            }
            this.client.emit(Events3.ShardReconnecting, shard.id);
            this.shardQueue.add(shard);
            if (shard.sessionId)
              this.debug(`Session id is present, attempting an immediate reconnect...`, shard);
            this.reconnect();
          });
          shard.on(WebSocketShardEvents.InvalidSession, () => {
            this.client.emit(Events3.ShardReconnecting, shard.id);
          });
          shard.on(WebSocketShardEvents.Destroyed, () => {
            this.debug("Shard was destroyed but no WebSocket connection was present! Reconnecting...", shard);
            this.client.emit(Events3.ShardReconnecting, shard.id);
            this.shardQueue.add(shard);
            this.reconnect();
          });
          shard.eventsAttached = true;
        }
        this.shards.set(shard.id, shard);
        try {
          await shard.connect();
        } catch (error) {
          if ((error == null ? void 0 : error.code) && error.code in unrecoverableErrorCodeMap) {
            throw new DiscordjsError2(unrecoverableErrorCodeMap[error.code]);
          } else if (!error || error.code) {
            this.debug("Failed to connect to the gateway, requeueing...", shard);
            this.shardQueue.add(shard);
          } else {
            throw error;
          }
        }
        if (this.shardQueue.size) {
          this.debug(`Shard Queue Size: ${this.shardQueue.size}; continuing in 5 seconds...`);
          await sleep(5e3);
          return this.createShards();
        }
        return true;
      }
      async reconnect() {
        if (this.reconnecting || this.status !== Status2.Ready)
          return false;
        this.reconnecting = true;
        try {
          await this.createShards();
        } catch (error) {
          this.debug(`Couldn't reconnect or fetch information about the gateway. ${error}`);
          if (error.httpStatus !== 401) {
            this.debug(`Possible network error occurred. Retrying in 5s...`);
            await sleep(5e3);
            this.reconnecting = false;
            return this.reconnect();
          }
          if (this.client.listenerCount(Events3.Invalidated)) {
            this.client.emit(Events3.Invalidated);
            this.destroy();
          } else {
            this.client.destroy();
          }
        } finally {
          this.reconnecting = false;
        }
        return true;
      }
      broadcast(packet) {
        for (const shard of this.shards.values())
          shard.send(packet);
      }
      destroy() {
        if (this.destroyed)
          return;
        this.debug(`Manager was destroyed. Called by:
${new Error().stack}`);
        this.destroyed = true;
        this.shardQueue.clear();
        for (const shard of this.shards.values())
          shard.destroy({ closeCode: 1e3, reset: true, emit: false, log: false });
      }
      handlePacket(packet, shard) {
        if (packet && this.status !== Status2.Ready) {
          if (!BeforeReadyWhitelist.includes(packet.t)) {
            this.packetQueue.push({ packet, shard });
            return false;
          }
        }
        if (this.packetQueue.length) {
          const item = this.packetQueue.shift();
          setImmediate2(() => {
            this.handlePacket(item.packet, item.shard);
          }).unref();
        }
        if (packet && PacketHandlers[packet.t]) {
          PacketHandlers[packet.t](this.client, packet, shard);
        }
        return true;
      }
      checkShardsReady() {
        if (this.status === Status2.Ready)
          return;
        if (this.shards.size !== this.totalShards || this.shards.some((s) => s.status !== Status2.Ready)) {
          return;
        }
        this.triggerClientReady();
      }
      triggerClientReady() {
        this.status = Status2.Ready;
        this.client.readyTimestamp = Date.now();
        this.client.emit(Events3.ClientReady, this.client);
        this.handlePacket();
      }
    };
    module2.exports = WebSocketManager2;
  }
});

// ../../node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS({
  "../../node_modules/discord.js/src/managers/BaseGuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var GuildEmoji = require_GuildEmoji();
    var ReactionEmoji = require_ReactionEmoji();
    var { parseEmoji } = require_Util();
    var BaseGuildEmojiManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, GuildEmoji, iterable);
      }
      resolve(emoji) {
        if (emoji instanceof ReactionEmoji)
          return super.resolve(emoji.id);
        return super.resolve(emoji);
      }
      resolveId(emoji) {
        if (emoji instanceof ReactionEmoji)
          return emoji.id;
        return super.resolveId(emoji);
      }
      resolveIdentifier(emoji) {
        const emojiResolvable = this.resolve(emoji);
        if (emojiResolvable)
          return emojiResolvable.identifier;
        if (emoji instanceof ReactionEmoji)
          return emoji.identifier;
        if (typeof emoji === "string") {
          const res = parseEmoji(emoji);
          if (res == null ? void 0 : res.name.length) {
            emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
          }
          if (!emoji.includes("%"))
            return encodeURIComponent(emoji);
          return emoji;
        }
        return null;
      }
    };
    module2.exports = BaseGuildEmojiManager2;
  }
});

// ../../node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS({
  "../../node_modules/discord.js/src/managers/ChannelManager.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { BaseChannel } = require_BaseChannel();
    var { createChannel } = require_Channels();
    var { ThreadChannelTypes } = require_Constants();
    var Events3 = require_Events();
    var cacheWarningEmitted = false;
    var ChannelManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, BaseChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === void 0 || this._cache.maxSize === Infinity;
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process3.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      _add(data, guild, { cache = true, allowUnknownGuild = false, fromInteraction = false } = {}) {
        var _a, _b, _c;
        const existing = this.cache.get(data.id);
        if (existing) {
          if (cache)
            existing._patch(data, fromInteraction);
          (_a = guild == null ? void 0 : guild.channels) == null ? void 0 : _a._add(existing);
          if (ThreadChannelTypes.includes(existing.type)) {
            (_c = (_b = existing.parent) == null ? void 0 : _b.threads) == null ? void 0 : _c._add(existing);
          }
          return existing;
        }
        const channel = createChannel(this.client, data, guild, { allowUnknownGuild, fromInteraction });
        if (!channel) {
          this.client.emit(Events3.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
          return null;
        }
        if (cache && !allowUnknownGuild)
          this.cache.set(channel.id, channel);
        return channel;
      }
      _remove(id) {
        var _a, _b, _c, _d;
        const channel = this.cache.get(id);
        (_a = channel == null ? void 0 : channel.guild) == null ? void 0 : _a.channels.cache.delete(id);
        for (const [code, invite] of ((_b = channel == null ? void 0 : channel.guild) == null ? void 0 : _b.invites.cache) ?? []) {
          if (invite.channelId === id)
            channel.guild.invites.cache.delete(code);
        }
        (_d = (_c = channel == null ? void 0 : channel.parent) == null ? void 0 : _c.threads) == null ? void 0 : _d.cache.delete(id);
        this.cache.delete(id);
      }
      async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.channel(id));
        return this._add(data, null, { cache, allowUnknownGuild });
      }
    };
    module2.exports = ChannelManager2;
  }
});

// ../../node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS({
  "../../node_modules/discord.js/src/structures/Integration.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var Base = require_Base();
    var IntegrationApplication = require_IntegrationApplication();
    var Integration = class extends Base {
      constructor(client, data, guild) {
        super(client);
        this.guild = guild;
        this.id = data.id;
        this.name = data.name;
        this.type = data.type;
        this.enabled = data.enabled ?? null;
        if ("syncing" in data) {
          this.syncing = data.syncing;
        } else {
          this.syncing ?? (this.syncing = null);
        }
        this.role = this.guild.roles.resolve(data.role_id);
        if ("enable_emoticons" in data) {
          this.enableEmoticons = data.enable_emoticons;
        } else {
          this.enableEmoticons ?? (this.enableEmoticons = null);
        }
        if (data.user) {
          this.user = this.client.users._add(data.user);
        } else {
          this.user ?? (this.user = null);
        }
        this.account = data.account;
        if ("synced_at" in data) {
          this.syncedTimestamp = Date.parse(data.synced_at);
        } else {
          this.syncedTimestamp ?? (this.syncedTimestamp = null);
        }
        if ("subscriber_count" in data) {
          this.subscriberCount = data.subscriber_count;
        } else {
          this.subscriberCount ?? (this.subscriberCount = null);
        }
        if ("revoked" in data) {
          this.revoked = data.revoked;
        } else {
          this.revoked ?? (this.revoked = null);
        }
        this._patch(data);
      }
      get syncedAt() {
        return this.syncedTimestamp && new Date(this.syncedTimestamp);
      }
      get roles() {
        const roles = this.guild.roles.cache;
        return roles.filter((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.integrationId) === this.id;
        });
      }
      _patch(data) {
        if ("expire_behavior" in data) {
          this.expireBehavior = data.expire_behavior;
        } else {
          this.expireBehavior ?? (this.expireBehavior = null);
        }
        if ("expire_grace_period" in data) {
          this.expireGracePeriod = data.expire_grace_period;
        } else {
          this.expireGracePeriod ?? (this.expireGracePeriod = null);
        }
        if ("application" in data) {
          if (this.application) {
            this.application._patch(data.application);
          } else {
            this.application = new IntegrationApplication(this.client, data.application);
          }
        } else {
          this.application ?? (this.application = null);
        }
        if ("scopes" in data) {
          this.scopes = data.scopes;
        } else {
          this.scopes ?? (this.scopes = []);
        }
      }
      async delete(reason) {
        await this.client.rest.delete(Routes3.guildIntegration(this.guild.id, this.id), { reason });
        return this;
      }
      toJSON() {
        return super.toJSON({
          role: "roleId",
          guild: "guildId",
          user: "userId"
        });
      }
    };
    module2.exports = Integration;
  }
});

// ../../node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS({
  "../../node_modules/discord.js/src/structures/StageInstance.js"(exports2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var StageInstance = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this._patch(data);
      }
      _patch(data) {
        if ("guild_id" in data) {
          this.guildId = data.guild_id;
        }
        if ("channel_id" in data) {
          this.channelId = data.channel_id;
        }
        if ("topic" in data) {
          this.topic = data.topic;
        }
        if ("privacy_level" in data) {
          this.privacyLevel = data.privacy_level;
        }
        if ("discoverable_disabled" in data) {
          this.discoverableDisabled = data.discoverable_disabled;
        } else {
          this.discoverableDisabled ?? (this.discoverableDisabled = null);
        }
        if ("guild_scheduled_event_id" in data) {
          this.guildScheduledEventId = data.guild_scheduled_event_id;
        } else {
          this.guildScheduledEventId ?? (this.guildScheduledEventId = null);
        }
      }
      get channel() {
        return this.client.channels.resolve(this.channelId);
      }
      get guild() {
        return this.client.guilds.resolve(this.guildId);
      }
      get guildScheduledEvent() {
        var _a;
        return ((_a = this.guild) == null ? void 0 : _a.scheduledEvents.resolve(this.guildScheduledEventId)) ?? null;
      }
      edit(options) {
        return this.guild.stageInstances.edit(this.channelId, options);
      }
      async delete() {
        await this.guild.stageInstances.delete(this.channelId);
        const clone = this._clone();
        return clone;
      }
      setTopic(topic) {
        return this.guild.stageInstances.edit(this.channelId, { topic });
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
    };
    exports2.StageInstance = StageInstance;
  }
});

// ../../node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildAuditLogsEntry.js"(exports2, module2) {
    "use strict";
    var { DiscordSnowflake } = require_dist3();
    var { AuditLogOptionsType, AuditLogEvent } = require_v106();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var Integration = require_Integration();
    var Invite2 = require_Invite();
    var { StageInstance } = require_StageInstance();
    var { Sticker: Sticker2 } = require_Sticker();
    var Webhook2 = require_Webhook();
    var Partials = require_Partials();
    var { flatten } = require_Util();
    var Targets = {
      All: "All",
      Guild: "Guild",
      GuildScheduledEvent: "GuildScheduledEvent",
      Channel: "Channel",
      User: "User",
      Role: "Role",
      Invite: "Invite",
      Webhook: "Webhook",
      Emoji: "Emoji",
      Message: "Message",
      Integration: "Integration",
      StageInstance: "StageInstance",
      Sticker: "Sticker",
      Thread: "Thread",
      ApplicationCommand: "ApplicationCommand",
      Unknown: "Unknown"
    };
    var _GuildAuditLogsEntry = class {
      constructor(logs, guild, data) {
        var _a, _b, _c, _d, _e;
        this.targetType = _GuildAuditLogsEntry.targetType(data.action_type);
        const targetType = this.targetType;
        this.actionType = _GuildAuditLogsEntry.actionType(data.action_type);
        this.action = data.action_type;
        this.reason = data.reason ?? null;
        this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) : null;
        this.changes = ((_a = data.changes) == null ? void 0 : _a.map((c) => ({ key: c.key, old: c.old_value, new: c.new_value }))) ?? [];
        this.id = data.id;
        this.extra = null;
        switch (data.action_type) {
          case AuditLogEvent.MemberPrune:
            this.extra = {
              removed: Number(data.options.members_removed),
              days: Number(data.options.delete_member_days)
            };
            break;
          case AuditLogEvent.MemberMove:
          case AuditLogEvent.MessageDelete:
          case AuditLogEvent.MessageBulkDelete:
            this.extra = {
              channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              count: Number(data.options.count)
            };
            break;
          case AuditLogEvent.MessagePin:
          case AuditLogEvent.MessageUnpin:
            this.extra = {
              channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
              messageId: data.options.message_id
            };
            break;
          case AuditLogEvent.MemberDisconnect:
            this.extra = {
              count: Number(data.options.count)
            };
            break;
          case AuditLogEvent.ChannelOverwriteCreate:
          case AuditLogEvent.ChannelOverwriteUpdate:
          case AuditLogEvent.ChannelOverwriteDelete:
            switch (data.options.type) {
              case AuditLogOptionsType.Role:
                this.extra = guild.roles.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  name: data.options.role_name,
                  type: AuditLogOptionsType.Role
                };
                break;
              case AuditLogOptionsType.Member:
                this.extra = guild.members.cache.get(data.options.id) ?? {
                  id: data.options.id,
                  type: AuditLogOptionsType.Member
                };
                break;
              default:
                break;
            }
            break;
          case AuditLogEvent.StageInstanceCreate:
          case AuditLogEvent.StageInstanceDelete:
          case AuditLogEvent.StageInstanceUpdate:
            this.extra = {
              channel: guild.client.channels.cache.get((_b = data.options) == null ? void 0 : _b.channel_id) ?? { id: (_c = data.options) == null ? void 0 : _c.channel_id }
            };
            break;
          case AuditLogEvent.ApplicationCommandPermissionUpdate:
            this.extra = {
              applicationId: data.options.application_id
            };
            break;
          default:
            break;
        }
        this.target = null;
        if (targetType === Targets.Unknown) {
          this.target = this.changes.reduce((o, c) => {
            o[c.key] = c.new ?? c.old;
            return o;
          }, {});
          this.target.id = data.target_id;
        } else if (targetType === Targets.User && data.target_id) {
          this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id);
        } else if (targetType === Targets.Guild) {
          this.target = guild.client.guilds.cache.get(data.target_id);
        } else if (targetType === Targets.Webhook) {
          this.target = logs.webhooks.get(data.target_id) ?? new Webhook2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              {
                id: data.target_id,
                guild_id: guild.id
              }
            )
          );
        } else if (targetType === Targets.Invite) {
          let change = this.changes.find((c) => c.key === "code");
          change = change.new ?? change.old;
          this.target = guild.invites.cache.get(change) ?? new Invite2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { guild }
            )
          );
        } else if (targetType === Targets.Message) {
          this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id);
        } else if (targetType === Targets.Integration) {
          this.target = logs.integrations.get(data.target_id) ?? new Integration(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id }
            ),
            guild
          );
        } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
          this.target = guild.channels.cache.get(data.target_id) ?? this.changes.reduce(
            (o, c) => {
              o[c.key] = c.new ?? c.old;
              return o;
            },
            { id: data.target_id }
          );
        } else if (targetType === Targets.StageInstance) {
          this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              {
                id: data.target_id,
                channel_id: (_d = data.options) == null ? void 0 : _d.channel_id,
                guild_id: guild.id
              }
            )
          );
        } else if (targetType === Targets.Sticker) {
          this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker2(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id }
            )
          );
        } else if (targetType === Targets.GuildScheduledEvent) {
          this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(
            guild.client,
            this.changes.reduce(
              (o, c) => {
                o[c.key] = c.new ?? c.old;
                return o;
              },
              { id: data.target_id, guild_id: guild.id }
            )
          );
        } else if (targetType === Targets.ApplicationCommand) {
          this.target = logs.applicationCommands.get(data.target_id) ?? { id: data.target_id };
        } else if (data.target_id) {
          this.target = ((_e = guild[`${targetType.toLowerCase()}s`]) == null ? void 0 : _e.cache.get(data.target_id)) ?? { id: data.target_id };
        }
      }
      static targetType(target) {
        if (target < 10)
          return Targets.Guild;
        if (target < 20)
          return Targets.Channel;
        if (target < 30)
          return Targets.User;
        if (target < 40)
          return Targets.Role;
        if (target < 50)
          return Targets.Invite;
        if (target < 60)
          return Targets.Webhook;
        if (target < 70)
          return Targets.Emoji;
        if (target < 80)
          return Targets.Message;
        if (target < 83)
          return Targets.Integration;
        if (target < 86)
          return Targets.StageInstance;
        if (target < 100)
          return Targets.Sticker;
        if (target < 110)
          return Targets.GuildScheduledEvent;
        if (target < 120)
          return Targets.Thread;
        if (target < 130)
          return Targets.ApplicationCommand;
        return Targets.Unknown;
      }
      static actionType(action) {
        if ([
          AuditLogEvent.ChannelCreate,
          AuditLogEvent.ChannelOverwriteCreate,
          AuditLogEvent.MemberBanRemove,
          AuditLogEvent.BotAdd,
          AuditLogEvent.RoleCreate,
          AuditLogEvent.InviteCreate,
          AuditLogEvent.WebhookCreate,
          AuditLogEvent.EmojiCreate,
          AuditLogEvent.MessagePin,
          AuditLogEvent.IntegrationCreate,
          AuditLogEvent.StageInstanceCreate,
          AuditLogEvent.StickerCreate,
          AuditLogEvent.GuildScheduledEventCreate,
          AuditLogEvent.ThreadCreate
        ].includes(action)) {
          return "Create";
        }
        if ([
          AuditLogEvent.ChannelDelete,
          AuditLogEvent.ChannelOverwriteDelete,
          AuditLogEvent.MemberKick,
          AuditLogEvent.MemberPrune,
          AuditLogEvent.MemberBanAdd,
          AuditLogEvent.MemberDisconnect,
          AuditLogEvent.RoleDelete,
          AuditLogEvent.InviteDelete,
          AuditLogEvent.WebhookDelete,
          AuditLogEvent.EmojiDelete,
          AuditLogEvent.MessageDelete,
          AuditLogEvent.MessageBulkDelete,
          AuditLogEvent.MessageUnpin,
          AuditLogEvent.IntegrationDelete,
          AuditLogEvent.StageInstanceDelete,
          AuditLogEvent.StickerDelete,
          AuditLogEvent.GuildScheduledEventDelete,
          AuditLogEvent.ThreadDelete
        ].includes(action)) {
          return "Delete";
        }
        if ([
          AuditLogEvent.GuildUpdate,
          AuditLogEvent.ChannelUpdate,
          AuditLogEvent.ChannelOverwriteUpdate,
          AuditLogEvent.MemberUpdate,
          AuditLogEvent.MemberRoleUpdate,
          AuditLogEvent.MemberMove,
          AuditLogEvent.RoleUpdate,
          AuditLogEvent.InviteUpdate,
          AuditLogEvent.WebhookUpdate,
          AuditLogEvent.EmojiUpdate,
          AuditLogEvent.IntegrationUpdate,
          AuditLogEvent.StageInstanceUpdate,
          AuditLogEvent.StickerUpdate,
          AuditLogEvent.GuildScheduledEventUpdate,
          AuditLogEvent.ThreadUpdate,
          AuditLogEvent.ApplicationCommandPermissionUpdate
        ].includes(action)) {
          return "Update";
        }
        return "All";
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      toJSON() {
        return flatten(this, { createdTimestamp: true });
      }
    };
    var GuildAuditLogsEntry = _GuildAuditLogsEntry;
    __publicField(GuildAuditLogsEntry, "Targets", Targets);
    module2.exports = GuildAuditLogsEntry;
  }
});

// ../../node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildAuditLogs.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var ApplicationCommand = require_ApplicationCommand();
    var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var { flatten } = require_Util();
    var GuildAuditLogs = class {
      constructor(guild, data) {
        if (data.users)
          for (const user of data.users)
            guild.client.users._add(user);
        if (data.threads)
          for (const thread of data.threads)
            guild.client.channels._add(thread, guild);
        this.webhooks = new Collection2();
        if (data.webhooks) {
          for (const hook of data.webhooks) {
            this.webhooks.set(hook.id, new Webhook2(guild.client, hook));
          }
        }
        this.integrations = new Collection2();
        if (data.integrations) {
          for (const integration of data.integrations) {
            this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
          }
        }
        this.guildScheduledEvents = data.guild_scheduled_events.reduce(
          (guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)),
          new Collection2()
        );
        this.applicationCommands = new Collection2();
        if (data.application_commands) {
          for (const command2 of data.application_commands) {
            this.applicationCommands.set(command2.id, new ApplicationCommand(guild.client, command2, guild));
          }
        }
        this.entries = new Collection2();
        for (const item of data.audit_log_entries) {
          const entry = new GuildAuditLogsEntry(this, guild, item);
          this.entries.set(entry.id, entry);
        }
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = GuildAuditLogs;
  }
});

// ../../node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildPreviewEmoji.js"(exports2, module2) {
    "use strict";
    var BaseGuildEmoji = require_BaseGuildEmoji();
    var GuildPreviewEmoji = class extends BaseGuildEmoji {
      constructor(client, data, guild) {
        super(client, data, guild);
        this.roles = data.roles;
      }
    };
    module2.exports = GuildPreviewEmoji;
  }
});

// ../../node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS({
  "../../node_modules/discord.js/src/structures/GuildPreview.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes3 } = require_v106();
    var Base = require_Base();
    var GuildPreviewEmoji = require_GuildPreviewEmoji();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildPreview2 = class extends Base {
      constructor(client, data) {
        super(client);
        if (!data)
          return;
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("icon" in data) {
          this.icon = data.icon;
        }
        if ("splash" in data) {
          this.splash = data.splash;
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("features" in data) {
          this.features = data.features;
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        }
        if ("description" in data) {
          this.description = data.description;
        } else {
          this.description ?? (this.description = null);
        }
        if (!this.emojis) {
          this.emojis = new Collection2();
        } else {
          this.emojis.clear();
        }
        for (const emoji of data.emojis) {
          this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
        }
        this.stickers = data.stickers.reduce(
          (stickers, sticker) => stickers.set(sticker.id, new Sticker2(this.client, sticker)),
          new Collection2()
        );
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      splashURL(options = {}) {
        return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
      }
      discoverySplashURL(options = {}) {
        return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
      }
      iconURL(options = {}) {
        return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
      }
      async fetch() {
        const data = await this.client.rest.get(Routes3.guildPreview(this.id));
        this._patch(data);
        return this;
      }
      toString() {
        return this.name;
      }
      toJSON() {
        const json = super.toJSON();
        json.iconURL = this.iconURL();
        json.splashURL = this.splashURL();
        return json;
      }
    };
    module2.exports = GuildPreview2;
  }
});

// ../../node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildApplicationCommandManager.js"(exports2, module2) {
    "use strict";
    var ApplicationCommandManager = require_ApplicationCommandManager();
    var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    var GuildApplicationCommandManager = class extends ApplicationCommandManager {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
        this.permissions = new ApplicationCommandPermissionsManager(this);
      }
    };
    module2.exports = GuildApplicationCommandManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildBanManager.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildBan = require_GuildBan();
    var { GuildMember } = require_GuildMember();
    var deprecationEmittedForDeleteMessageDays = false;
    var GuildBanManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildBan, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      resolve(ban) {
        return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
      }
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const { user, cache, force, limit, before, after } = options;
        const resolvedUser = this.client.users.resolveId(user ?? options);
        if (resolvedUser)
          return this._fetchSingle({ user: resolvedUser, cache, force });
        if (!before && !after && !limit && typeof cache === "undefined") {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.FetchBanResolveId));
        }
        return this._fetchMany(options);
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.guildBan(this.guild.id, user));
        return this._add(data, cache);
      }
      async _fetchMany(options = {}) {
        const data = await this.client.rest.get(Routes3.guildBans(this.guild.id), {
          query: makeURLSearchParams2(options)
        });
        return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection2());
      }
      async create(user, options = {}) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.BanResolveId, true);
        if (typeof options.deleteMessageDays !== "undefined" && !deprecationEmittedForDeleteMessageDays) {
          process3.emitWarning(
            "The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.",
            "DeprecationWarning"
          );
          deprecationEmittedForDeleteMessageDays = true;
        }
        await this.client.rest.put(Routes3.guildBan(this.guild.id, id), {
          body: {
            delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : void 0)
          },
          reason: options.reason
        });
        if (user instanceof GuildMember)
          return user;
        const _user = this.client.users.resolve(id);
        if (_user) {
          return this.guild.members.resolve(_user) ?? _user;
        }
        return id;
      }
      async remove(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.BanResolveId);
        await this.client.rest.delete(Routes3.guildBan(this.guild.id, id), { reason });
        return this.client.users.resolve(user);
      }
    };
    module2.exports = GuildBanManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildChannelManager.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { Collection: Collection2 } = require_dist();
    var { ChannelType, Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var GuildTextThreadManager = require_GuildTextThreadManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildChannel = require_GuildChannel();
    var PermissionOverwrites = require_PermissionOverwrites();
    var ThreadChannel = require_ThreadChannel();
    var Webhook2 = require_Webhook();
    var ChannelFlagsBitField = require_ChannelFlagsBitField();
    var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
    var { ThreadChannelTypes } = require_Constants();
    var DataResolver2 = require_DataResolver();
    var { setPosition } = require_Util();
    var cacheWarningEmitted = false;
    var GuildChannelManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildChannel, iterable);
        const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === void 0 || this._cache.maxSize === Infinity;
        if (!cacheWarningEmitted && !defaultCaching) {
          cacheWarningEmitted = true;
          process3.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      get channelCountWithoutThreads() {
        return this.cache.reduce((acc, channel) => {
          if (ThreadChannelTypes.includes(channel.type))
            return acc;
          return ++acc;
        }, 0);
      }
      _add(channel) {
        const existing = this.cache.get(channel.id);
        if (existing)
          return existing;
        this.cache.set(channel.id, channel);
        return channel;
      }
      resolve(channel) {
        if (channel instanceof ThreadChannel)
          return super.resolve(channel.id);
        return super.resolve(channel);
      }
      resolveId(channel) {
        if (channel instanceof ThreadChannel)
          return super.resolveId(channel.id);
        return super.resolveId(channel);
      }
      async create({
        name,
        type,
        topic,
        nsfw,
        bitrate,
        userLimit,
        parent,
        permissionOverwrites,
        position,
        rateLimitPerUser,
        rtcRegion,
        videoQualityMode,
        availableTags,
        defaultReactionEmoji,
        defaultAutoArchiveDuration,
        defaultSortOrder,
        reason
      }) {
        parent && (parent = this.client.channels.resolveId(parent));
        permissionOverwrites && (permissionOverwrites = permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild)));
        const data = await this.client.rest.post(Routes3.guildChannels(this.guild.id), {
          body: {
            name,
            topic,
            type,
            nsfw,
            bitrate,
            user_limit: userLimit,
            parent_id: parent,
            position,
            permission_overwrites: permissionOverwrites,
            rate_limit_per_user: rateLimitPerUser,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            available_tags: availableTags == null ? void 0 : availableTags.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
            default_auto_archive_duration: defaultAutoArchiveDuration,
            default_sort_order: defaultSortOrder
          },
          reason
        });
        return this.client.actions.ChannelCreate.handle(data).channel;
      }
      async createWebhook({ channel, name, avatar, reason }) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        if (typeof avatar === "string" && !avatar.startsWith("data:")) {
          avatar = await DataResolver2.resolveImage(avatar);
        }
        const data = await this.client.rest.post(Routes3.channelWebhooks(id), {
          body: {
            name,
            avatar
          },
          reason
        });
        return new Webhook2(this.client, data);
      }
      async edit(channel, data) {
        var _a, _b;
        channel = this.resolve(channel);
        if (!channel)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const parent = data.parent && this.client.channels.resolveId(data.parent);
        if (typeof data.position !== "undefined") {
          await this.setPosition(channel, data.position, { position: data.position, reason: data.reason });
        }
        let permission_overwrites = (_a = data.permissionOverwrites) == null ? void 0 : _a.map((o) => PermissionOverwrites.resolve(o, this.guild));
        if (data.lockPermissions) {
          if (parent) {
            const newParent = this.guild.channels.resolve(parent);
            if ((newParent == null ? void 0 : newParent.type) === ChannelType.GuildCategory) {
              permission_overwrites = newParent.permissionOverwrites.cache.map(
                (o) => PermissionOverwrites.resolve(o, this.guild)
              );
            }
          } else if (channel.parent) {
            permission_overwrites = channel.parent.permissionOverwrites.cache.map(
              (o) => PermissionOverwrites.resolve(o, this.guild)
            );
          }
        }
        const newData = await this.client.rest.patch(Routes3.channel(channel.id), {
          body: {
            name: (data.name ?? channel.name).trim(),
            type: data.type,
            topic: data.topic,
            nsfw: data.nsfw,
            bitrate: data.bitrate ?? channel.bitrate,
            user_limit: data.userLimit ?? channel.userLimit,
            rtc_region: "rtcRegion" in data ? data.rtcRegion : channel.rtcRegion,
            video_quality_mode: data.videoQualityMode,
            parent_id: parent,
            lock_permissions: data.lockPermissions,
            rate_limit_per_user: data.rateLimitPerUser,
            default_auto_archive_duration: data.defaultAutoArchiveDuration,
            permission_overwrites,
            available_tags: (_b = data.availableTags) == null ? void 0 : _b.map((availableTag) => transformGuildForumTag(availableTag)),
            default_reaction_emoji: data.defaultReactionEmoji && transformGuildDefaultReaction(data.defaultReactionEmoji),
            default_thread_rate_limit_per_user: data.defaultThreadRateLimitPerUser,
            flags: "flags" in data ? ChannelFlagsBitField.resolve(data.flags) : void 0,
            default_sort_order: data.defaultSortOrder
          },
          reason: data.reason
        });
        return this.client.actions.ChannelUpdate.handle(newData).updated;
      }
      async setPosition(channel, position, { relative, reason } = {}) {
        channel = this.resolve(channel);
        if (!channel)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const updatedChannels = await setPosition(
          channel,
          position,
          relative,
          this.guild._sortedChannels(channel),
          this.client,
          Routes3.guildChannels(this.guild.id),
          reason
        );
        this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: updatedChannels
        });
        return channel;
      }
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        if (id) {
          const data2 = await this.client.rest.get(Routes3.channel(id));
          if (this.guild.id !== data2.guild_id)
            throw new DiscordjsError2(ErrorCodes2.GuildChannelUnowned);
          return this.client.channels._add(data2, this.guild, { cache });
        }
        const data = await this.client.rest.get(Routes3.guildChannels(this.guild.id));
        const channels = new Collection2();
        for (const channel of data)
          channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
        return channels;
      }
      async fetchWebhooks(channel) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        const data = await this.client.rest.get(Routes3.channelWebhooks(id));
        return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook2(this.client, hook)), new Collection2());
      }
      async setPositions(channelPositions) {
        channelPositions = channelPositions.map((r) => ({
          id: this.client.channels.resolveId(r.channel),
          position: r.position,
          lock_permissions: r.lockPermissions,
          parent_id: typeof r.parent !== "undefined" ? this.resolveId(r.parent) : void 0
        }));
        await this.client.rest.patch(Routes3.guildChannels(this.guild.id), { body: channelPositions });
        return this.client.actions.GuildChannelsPositionUpdate.handle({
          guild_id: this.guild.id,
          channels: channelPositions
        }).guild;
      }
      async fetchActiveThreads(cache = true) {
        const raw = await this.client.rest.get(Routes3.guildActiveThreads(this.guild.id));
        return GuildTextThreadManager._mapThreads(raw, this.client, { guild: this.guild, cache });
      }
      async delete(channel, reason) {
        const id = this.resolveId(channel);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "channel", "GuildChannelResolvable");
        await this.client.rest.delete(Routes3.channel(id), { reason });
        this.client.actions.ChannelDelete.handle({ id });
      }
    };
    module2.exports = GuildChannelManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildEmojiManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3, PermissionFlagsBits: PermissionFlagsBits4 } = require_v106();
    var BaseGuildEmojiManager2 = require_BaseGuildEmojiManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var DataResolver2 = require_DataResolver();
    var GuildEmojiManager = class extends BaseGuildEmojiManager2 {
      constructor(guild, iterable) {
        super(guild.client, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      async create({ attachment, name, roles, reason }) {
        attachment = await DataResolver2.resolveImage(attachment);
        if (!attachment)
          throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
        const body = { image: attachment, name };
        if (roles) {
          if (!Array.isArray(roles) && !(roles instanceof Collection2)) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "options.roles",
              "Array or Collection of Roles or Snowflakes",
              true
            );
          }
          body.roles = [];
          for (const role of roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "options.roles", role);
            }
            body.roles.push(resolvedRole);
          }
        }
        const emoji = await this.client.rest.post(Routes3.guildEmojis(this.guild.id), { body, reason });
        return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
      }
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const emoji = await this.client.rest.get(Routes3.guildEmoji(this.guild.id, id));
          return this._add(emoji, cache);
        }
        const data = await this.client.rest.get(Routes3.guildEmojis(this.guild.id));
        const emojis = new Collection2();
        for (const emoji of data)
          emojis.set(emoji.id, this._add(emoji, cache));
        return emojis;
      }
      async delete(emoji, reason) {
        const id = this.resolveId(emoji);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        await this.client.rest.delete(Routes3.guildEmoji(this.guild.id, id), { reason });
      }
      async edit(emoji, data) {
        var _a;
        const id = this.resolveId(emoji);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        const roles = (_a = data.roles) == null ? void 0 : _a.map((r) => this.guild.roles.resolveId(r));
        const newData = await this.client.rest.patch(Routes3.guildEmoji(this.guild.id, id), {
          body: {
            name: data.name,
            roles
          },
          reason: data.reason
        });
        const existing = this.cache.get(id);
        if (existing) {
          const clone = existing._clone();
          clone._patch(newData);
          return clone;
        }
        return this._add(newData);
      }
      async fetchAuthor(emoji) {
        emoji = this.resolve(emoji);
        if (!emoji)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "emoji", "EmojiResolvable", true);
        if (emoji.managed) {
          throw new DiscordjsError2(ErrorCodes2.EmojiManaged);
        }
        const { me } = this.guild.members;
        if (!me)
          throw new DiscordjsError2(ErrorCodes2.GuildUncachedMe);
        if (!me.permissions.has(PermissionFlagsBits4.ManageEmojisAndStickers)) {
          throw new DiscordjsError2(ErrorCodes2.MissingManageEmojisAndStickersPermission, this.guild);
        }
        const data = await this.client.rest.get(Routes3.guildEmoji(this.guild.id, emoji.id));
        emoji._patch(data);
        return emoji.author;
      }
    };
    module2.exports = GuildEmojiManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildInviteManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Invite2 = require_Invite();
    var DataResolver2 = require_DataResolver();
    var GuildInviteManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Invite2, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.code, extras: [this.guild] });
      }
      fetch(options) {
        if (!options)
          return this._fetchMany();
        if (typeof options === "string") {
          const code = DataResolver2.resolveInviteCode(options);
          if (!code)
            return Promise.reject(new DiscordjsError2(ErrorCodes2.InviteResolveCode));
          return this._fetchSingle({ code, cache: true });
        }
        if (!options.code) {
          if (options.channelId) {
            const id = this.guild.channels.resolveId(options.channelId);
            if (!id)
              return Promise.reject(new DiscordjsError2(ErrorCodes2.GuildChannelResolve));
            return this._fetchChannelMany(id, options.cache);
          }
          if ("cache" in options)
            return this._fetchMany(options.cache);
          return Promise.reject(new DiscordjsError2(ErrorCodes2.InviteResolveCode));
        }
        return this._fetchSingle({
          ...options,
          code: DataResolver2.resolveInviteCode(options.code)
        });
      }
      async _fetchSingle({ code, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(code);
          if (existing)
            return existing;
        }
        const invites = await this._fetchMany(cache);
        const invite = invites.get(code);
        if (!invite)
          throw new DiscordjsError2(ErrorCodes2.InviteNotFound);
        return invite;
      }
      async _fetchMany(cache) {
        const data = await this.client.rest.get(Routes3.guildInvites(this.guild.id));
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      async _fetchChannelMany(channelId, cache) {
        const data = await this.client.rest.get(Routes3.channelInvites(channelId));
        return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection2());
      }
      async create(channel, { temporary, maxAge, maxUses, unique: unique2, targetUser, targetApplication, targetType, reason } = {}) {
        const id = this.guild.channels.resolveId(channel);
        if (!id)
          throw new DiscordjsError2(ErrorCodes2.GuildChannelResolve);
        const invite = await this.client.rest.post(Routes3.channelInvites(id), {
          body: {
            temporary,
            max_age: maxAge,
            max_uses: maxUses,
            unique: unique2,
            target_user_id: this.client.users.resolveId(targetUser),
            target_application_id: (targetApplication == null ? void 0 : targetApplication.id) ?? (targetApplication == null ? void 0 : targetApplication.applicationId) ?? targetApplication,
            target_type: targetType
          },
          reason
        });
        return new Invite2(this.client, invite);
      }
      async delete(invite, reason) {
        const code = DataResolver2.resolveInviteCode(invite);
        await this.client.rest.delete(Routes3.invite(code), { reason });
      }
    };
    module2.exports = GuildInviteManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildMemberManager.js"(exports2, module2) {
    "use strict";
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("timers");
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { DiscordSnowflake } = require_dist3();
    var { Routes: Routes3, GatewayOpcodes } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    var { GuildMember } = require_GuildMember();
    var { Role } = require_Role();
    var Events3 = require_Events();
    var Partials = require_Partials();
    var GuildMemberManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildMember, iterable);
        this.guild = guild;
      }
      _add(data, cache = true) {
        return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
      }
      resolve(member) {
        const memberResolvable = super.resolve(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        if (userResolvable)
          return super.resolve(userResolvable);
        return null;
      }
      resolveId(member) {
        const memberResolvable = super.resolveId(member);
        if (memberResolvable)
          return memberResolvable;
        const userResolvable = this.client.users.resolveId(member);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
      async add(user, options) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
        if (!options.force) {
          const cachedUser = this.cache.get(userId);
          if (cachedUser)
            return cachedUser;
        }
        const resolvedOptions = {
          access_token: options.accessToken,
          nick: options.nick,
          mute: options.mute,
          deaf: options.deaf
        };
        if (options.roles) {
          if (!Array.isArray(options.roles) && !(options.roles instanceof Collection2)) {
            throw new DiscordjsTypeError2(
              ErrorCodes2.InvalidType,
              "options.roles",
              "Array or Collection of Roles or Snowflakes",
              true
            );
          }
          const resolvedRoles = [];
          for (const role of options.roles.values()) {
            const resolvedRole = this.guild.roles.resolveId(role);
            if (!resolvedRole) {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array or Collection", "options.roles", role);
            }
            resolvedRoles.push(resolvedRole);
          }
          resolvedOptions.roles = resolvedRoles;
        }
        const data = await this.client.rest.put(Routes3.guildMember(this.guild.id, userId), { body: resolvedOptions });
        return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
      }
      get me() {
        return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
      }
      fetch(options) {
        if (!options)
          return this._fetchMany();
        const user = this.client.users.resolveId(options);
        if (user)
          return this._fetchSingle({ user, cache: true });
        if (options.user) {
          if (Array.isArray(options.user)) {
            options.user = options.user.map((u) => this.client.users.resolveId(u));
            return this._fetchMany(options);
          } else {
            options.user = this.client.users.resolveId(options.user);
          }
          if (!options.limit && !options.withPresences)
            return this._fetchSingle(options);
        }
        return this._fetchMany(options);
      }
      fetchMe(options) {
        return this.fetch({ ...options, user: this.client.user.id });
      }
      async search({ query, limit, cache = true } = {}) {
        const data = await this.client.rest.get(Routes3.guildMembersSearch(this.guild.id), {
          query: makeURLSearchParams2({ query, limit })
        });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      async list({ after, limit, cache = true } = {}) {
        const query = makeURLSearchParams2({ limit, after });
        const data = await this.client.rest.get(Routes3.guildMembers(this.guild.id), { query });
        return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection2());
      }
      async edit(user, { reason, ...data }) {
        var _a;
        const id = this.client.users.resolveId(user);
        if (!id)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
        if (data.channel) {
          data.channel = this.guild.channels.resolve(data.channel);
          if (!(data.channel instanceof BaseGuildVoiceChannel)) {
            throw new DiscordjsError2(ErrorCodes2.GuildVoiceChannelResolve);
          }
          data.channel_id = data.channel.id;
          data.channel = void 0;
        } else if (data.channel === null) {
          data.channel_id = null;
          data.channel = void 0;
        }
        data.roles && (data.roles = data.roles.map((role) => role instanceof Role ? role.id : role));
        if (typeof data.communicationDisabledUntil !== "undefined") {
          data.communication_disabled_until = data.communicationDisabledUntil != null ? new Date(data.communicationDisabledUntil).toISOString() : data.communicationDisabledUntil;
        }
        let endpoint;
        if (id === this.client.user.id) {
          const keys = Object.keys(data);
          if (keys.length === 1 && keys[0] === "nick")
            endpoint = Routes3.guildMember(this.guild.id);
          else
            endpoint = Routes3.guildMember(this.guild.id, id);
        } else {
          endpoint = Routes3.guildMember(this.guild.id, id);
        }
        const d = await this.client.rest.patch(endpoint, { body: data, reason });
        const clone = (_a = this.cache.get(id)) == null ? void 0 : _a._clone();
        clone == null ? void 0 : clone._patch(d);
        return clone ?? this._add(d, false);
      }
      async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
        if (typeof days !== "number")
          throw new DiscordjsTypeError2(ErrorCodes2.PruneDaysType);
        const query = { days };
        const resolvedRoles = [];
        for (const role of roles) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidElement, "Array", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        if (resolvedRoles.length) {
          query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
        }
        const endpoint = Routes3.guildPrune(this.guild.id);
        const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams2(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
        return pruned;
      }
      async kick(user, reason) {
        const id = this.client.users.resolveId(user);
        if (!id)
          return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable"));
        await this.client.rest.delete(Routes3.guildMember(this.guild.id, id), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
      }
      ban(user, options) {
        return this.guild.bans.create(user, options);
      }
      unban(user, reason) {
        return this.guild.bans.remove(user, reason);
      }
      async addRole(options) {
        const { user, role, reason } = options;
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.rest.put(Routes3.guildMemberRole(this.guild.id, userId, roleId), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
      async removeRole(options) {
        const { user, role, reason } = options;
        const userId = this.guild.members.resolveId(user);
        const roleId = this.guild.roles.resolveId(role);
        await this.client.rest.delete(Routes3.guildMemberRole(this.guild.id, userId, roleId), { reason });
        return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
      }
      async _fetchSingle({ user, cache, force = false }) {
        if (!force) {
          const existing = this.cache.get(user);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.guildMember(this.guild.id, user));
        return this._add(data, cache);
      }
      _fetchMany({
        limit = 0,
        withPresences: presences = false,
        user: user_ids,
        query,
        time = 12e4,
        nonce = DiscordSnowflake.generate().toString()
      } = {}) {
        return new Promise((resolve, reject) => {
          if (!query && !user_ids)
            query = "";
          if (nonce.length > 32)
            throw new DiscordjsRangeError2(ErrorCodes2.MemberFetchNonceLength);
          this.guild.shard.send({
            op: GatewayOpcodes.RequestGuildMembers,
            d: {
              guild_id: this.guild.id,
              presences,
              user_ids,
              query,
              nonce,
              limit
            }
          });
          const fetchedMembers = new Collection2();
          let i = 0;
          const handler = (members, _, chunk) => {
            timeout.refresh();
            if (chunk.nonce !== nonce)
              return;
            i++;
            for (const member of members.values()) {
              fetchedMembers.set(member.id, member);
            }
            if (members.size < 1e3 || limit && fetchedMembers.size >= limit || i === chunk.count) {
              clearTimeout2(timeout);
              this.client.removeListener(Events3.GuildMembersChunk, handler);
              this.client.decrementMaxListeners();
              let fetched = fetchedMembers;
              if (user_ids && !Array.isArray(user_ids) && fetched.size)
                fetched = fetched.first();
              resolve(fetched);
            }
          };
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events3.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            reject(new DiscordjsError2(ErrorCodes2.GuildMembersTimeout));
          }, time).unref();
          this.client.incrementMaxListeners();
          this.client.on(Events3.GuildMembersChunk, handler);
        });
      }
    };
    module2.exports = GuildMemberManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildScheduledEventManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { GuildScheduledEventEntityType, Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { GuildScheduledEvent } = require_GuildScheduledEvent();
    var DataResolver2 = require_DataResolver();
    var GuildScheduledEventManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, GuildScheduledEvent, iterable);
        this.guild = guild;
      }
      async create(options) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        let entity_metadata, channel_id;
        if (entityType === GuildScheduledEventEntityType.External) {
          channel_id = typeof channel === "undefined" ? channel : null;
          entity_metadata = { location: entityMetadata == null ? void 0 : entityMetadata.location };
        } else {
          channel_id = this.guild.channels.resolveId(channel);
          if (!channel_id)
            throw new DiscordjsError2(ErrorCodes2.GuildVoiceChannelResolve);
          entity_metadata = typeof entityMetadata === "undefined" ? entityMetadata : null;
        }
        const data = await this.client.rest.post(Routes3.guildScheduledEvents(this.guild.id), {
          body: {
            channel_id,
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: new Date(scheduledStartTime).toISOString(),
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            entity_metadata,
            image: image && await DataResolver2.resolveImage(image)
          },
          reason
        });
        return this._add(data);
      }
      async fetch(options = {}) {
        const id = this.resolveId(options.guildScheduledEvent ?? options);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const data2 = await this.client.rest.get(Routes3.guildScheduledEvent(this.guild.id, id), {
            query: makeURLSearchParams2({ with_user_count: options.withUserCount ?? true })
          });
          return this._add(data2, options.cache);
        }
        const data = await this.client.rest.get(Routes3.guildScheduledEvents(this.guild.id), {
          query: makeURLSearchParams2({ with_user_count: options.withUserCount ?? true })
        });
        return data.reduce(
          (coll, rawGuildScheduledEventData) => coll.set(
            rawGuildScheduledEventData.id,
            this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)
          ),
          new Collection2()
        );
      }
      async edit(guildScheduledEvent, options) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let {
          privacyLevel,
          entityType,
          channel,
          status,
          name,
          scheduledStartTime,
          description,
          scheduledEndTime,
          entityMetadata,
          reason,
          image
        } = options;
        let entity_metadata;
        if (entityMetadata) {
          entity_metadata = {
            location: entityMetadata.location
          };
        }
        const data = await this.client.rest.patch(Routes3.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
          body: {
            channel_id: typeof channel === "undefined" ? channel : this.guild.channels.resolveId(channel),
            name,
            privacy_level: privacyLevel,
            scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : void 0,
            scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
            description,
            entity_type: entityType,
            status,
            image: image && await DataResolver2.resolveImage(image),
            entity_metadata
          },
          reason
        });
        return this._add(data);
      }
      async delete(guildScheduledEvent) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        await this.client.rest.delete(Routes3.guildScheduledEvent(this.guild.id, guildScheduledEventId));
      }
      async fetchSubscribers(guildScheduledEvent, options = {}) {
        const guildScheduledEventId = this.resolveId(guildScheduledEvent);
        if (!guildScheduledEventId)
          throw new DiscordjsError2(ErrorCodes2.GuildScheduledEventResolve);
        const query = makeURLSearchParams2({
          limit: options.limit,
          with_member: options.withMember,
          before: options.before,
          after: options.after
        });
        const data = await this.client.rest.get(Routes3.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
          query
        });
        return data.reduce(
          (coll, rawData) => coll.set(rawData.user.id, {
            guildScheduledEventId: rawData.guild_scheduled_event_id,
            user: this.client.users._add(rawData.user),
            member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
          }),
          new Collection2()
        );
      }
    };
    module2.exports = GuildScheduledEventManager;
  }
});

// ../../node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildStickerManager.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var MessagePayload = require_MessagePayload();
    var { Sticker: Sticker2 } = require_Sticker();
    var GuildStickerManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Sticker2, iterable);
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      async create({ file, name, tags, description, reason } = {}) {
        const resolvedFile = await MessagePayload.resolveFile(file);
        if (!resolvedFile)
          throw new DiscordjsTypeError2(ErrorCodes2.ReqResourceType);
        file = { ...resolvedFile, key: "file" };
        const body = { name, tags, description: description ?? "" };
        const sticker = await this.client.rest.post(Routes3.guildStickers(this.guild.id), {
          appendToFormData: true,
          body,
          files: [file],
          reason
        });
        return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
      }
      async edit(sticker, data = {}) {
        const stickerId = this.resolveId(sticker);
        if (!stickerId)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        const d = await this.client.rest.patch(Routes3.guildSticker(this.guild.id, stickerId), {
          body: data,
          reason: data.reason
        });
        const existing = this.cache.get(stickerId);
        if (existing) {
          const clone = existing._clone();
          clone._patch(d);
          return clone;
        }
        return this._add(d);
      }
      async delete(sticker, reason) {
        sticker = this.resolveId(sticker);
        if (!sticker)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        await this.client.rest.delete(Routes3.guildSticker(this.guild.id, sticker), { reason });
      }
      async fetch(id, { cache = true, force = false } = {}) {
        if (id) {
          if (!force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const sticker = await this.client.rest.get(Routes3.guildSticker(this.guild.id, id));
          return this._add(sticker, cache);
        }
        const data = await this.client.rest.get(Routes3.guildStickers(this.guild.id));
        return new Collection2(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
      }
      async fetchUser(sticker) {
        sticker = this.resolve(sticker);
        if (!sticker)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "sticker", "StickerResolvable");
        const data = await this.client.rest.get(Routes3.guildSticker(this.guild.id, sticker.id));
        sticker._patch(data);
        return sticker.user;
      }
    };
    module2.exports = GuildStickerManager;
  }
});

// ../../node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/ActivityFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { ActivityFlags } = require_v106();
    var BitField = require_BitField();
    var ActivityFlagsBitField = class extends BitField {
    };
    __publicField(ActivityFlagsBitField, "Flags", ActivityFlags);
    module2.exports = ActivityFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS({
  "../../node_modules/discord.js/src/structures/Presence.js"(exports2) {
    "use strict";
    var Base = require_Base();
    var { Emoji } = require_Emoji();
    var ActivityFlagsBitField = require_ActivityFlagsBitField();
    var { flatten } = require_Util();
    var Presence = class extends Base {
      constructor(client, data = {}) {
        super(client);
        this.userId = data.user.id;
        this.guild = data.guild ?? null;
        this._patch(data);
      }
      get user() {
        return this.client.users.resolve(this.userId);
      }
      get member() {
        return this.guild.members.resolve(this.userId);
      }
      _patch(data) {
        if ("status" in data) {
          this.status = data.status;
        } else {
          this.status ?? (this.status = "offline");
        }
        if ("activities" in data) {
          this.activities = data.activities.map((activity) => new Activity(this, activity));
        } else {
          this.activities ?? (this.activities = []);
        }
        if ("client_status" in data) {
          this.clientStatus = data.client_status;
        } else {
          this.clientStatus ?? (this.clientStatus = null);
        }
        return this;
      }
      _clone() {
        const clone = Object.assign(Object.create(this), this);
        clone.activities = this.activities.map((activity) => activity._clone());
        return clone;
      }
      equals(presence) {
        var _a, _b, _c, _d, _e, _f;
        return this === presence || presence && this.status === presence.status && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index])) && ((_a = this.clientStatus) == null ? void 0 : _a.web) === ((_b = presence.clientStatus) == null ? void 0 : _b.web) && ((_c = this.clientStatus) == null ? void 0 : _c.mobile) === ((_d = presence.clientStatus) == null ? void 0 : _d.mobile) && ((_e = this.clientStatus) == null ? void 0 : _e.desktop) === ((_f = presence.clientStatus) == null ? void 0 : _f.desktop);
      }
      toJSON() {
        return flatten(this);
      }
    };
    var Activity = class {
      constructor(presence, data) {
        Object.defineProperty(this, "presence", { value: presence });
        this.name = data.name;
        this.type = data.type;
        this.url = data.url ?? null;
        this.details = data.details ?? null;
        this.state = data.state ?? null;
        this.applicationId = data.application_id ?? null;
        this.timestamps = data.timestamps ? {
          start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
          end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
        } : null;
        this.party = data.party ?? null;
        this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
        this.flags = new ActivityFlagsBitField(data.flags).freeze();
        this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
        this.buttons = data.buttons ?? [];
        this.createdTimestamp = data.created_at;
      }
      equals(activity) {
        return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details;
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      toString() {
        return this.name;
      }
      _clone() {
        return Object.assign(Object.create(this), this);
      }
    };
    var RichPresenceAssets = class {
      constructor(activity, assets) {
        Object.defineProperty(this, "activity", { value: activity });
        this.largeText = assets.large_text ?? null;
        this.smallText = assets.small_text ?? null;
        this.largeImage = assets.large_image ?? null;
        this.smallImage = assets.small_image ?? null;
      }
      smallImageURL(options = {}) {
        if (!this.smallImage)
          return null;
        if (this.smallImage.includes(":")) {
          const [platform, id] = this.smallImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
      }
      largeImageURL(options = {}) {
        if (!this.largeImage)
          return null;
        if (this.largeImage.includes(":")) {
          const [platform, id] = this.largeImage.split(":");
          switch (platform) {
            case "mp":
              return `https://media.discordapp.net/${id}`;
            default:
              return null;
          }
        }
        return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
      }
    };
    exports2.Presence = Presence;
    exports2.Activity = Activity;
    exports2.RichPresenceAssets = RichPresenceAssets;
  }
});

// ../../node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS({
  "../../node_modules/discord.js/src/managers/PresenceManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var { Presence } = require_Presence();
    var PresenceManager = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Presence, iterable);
      }
      _add(data, cache) {
        return super._add(data, cache, { id: data.user.id });
      }
      resolve(presence) {
        const presenceResolvable = super.resolve(presence);
        if (presenceResolvable)
          return presenceResolvable;
        const UserResolvable = this.client.users.resolveId(presence);
        return super.resolve(UserResolvable);
      }
      resolveId(presence) {
        const presenceResolvable = super.resolveId(presence);
        if (presenceResolvable)
          return presenceResolvable;
        const userResolvable = this.client.users.resolveId(presence);
        return this.cache.has(userResolvable) ? userResolvable : null;
      }
    };
    module2.exports = PresenceManager;
  }
});

// ../../node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS({
  "../../node_modules/discord.js/src/managers/RoleManager.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var PermissionsBitField5 = require_PermissionsBitField();
    var { setPosition, resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var RoleManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, Role, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process3.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
        this.guild = guild;
      }
      _add(data, cache) {
        return super._add(data, cache, { extras: [this.guild] });
      }
      async fetch(id, { cache = true, force = false } = {}) {
        if (id && !force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.guildRoles(this.guild.id));
        const roles = new Collection2();
        for (const role of data)
          roles.set(role.id, this._add(role, cache));
        return id ? roles.get(id) ?? null : roles;
      }
      async create(options = {}) {
        var _a;
        let { name, color, hoist, permissions: permissions2, position, mentionable, reason, icon, unicodeEmoji } = options;
        color && (color = resolveColor(color));
        if (typeof permissions2 !== "undefined")
          permissions2 = new PermissionsBitField5(permissions2);
        if (icon) {
          const guildEmojiURL = (_a = this.guild.emojis.resolve(icon)) == null ? void 0 : _a.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string")
            icon = void 0;
        }
        const data = await this.client.rest.post(Routes3.guildRoles(this.guild.id), {
          body: {
            name,
            color,
            hoist,
            permissions: permissions2,
            mentionable,
            icon,
            unicode_emoji: unicodeEmoji
          },
          reason
        });
        const { role } = this.client.actions.GuildRoleCreate.handle({
          guild_id: this.guild.id,
          role: data
        });
        if (position)
          return this.setPosition(role, position, { reason });
        return role;
      }
      async edit(role, data) {
        var _a;
        role = this.resolve(role);
        if (!role)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "RoleResolvable");
        if (typeof data.position === "number") {
          await this.setPosition(role, data.position, { reason: data.reason });
        }
        let icon = data.icon;
        if (icon) {
          const guildEmojiURL = (_a = this.guild.emojis.resolve(icon)) == null ? void 0 : _a.url;
          icon = guildEmojiURL ? await DataResolver2.resolveImage(guildEmojiURL) : await DataResolver2.resolveImage(icon);
          if (typeof icon !== "string")
            icon = void 0;
        }
        const body = {
          name: data.name,
          color: typeof data.color === "undefined" ? void 0 : resolveColor(data.color),
          hoist: data.hoist,
          permissions: typeof data.permissions === "undefined" ? void 0 : new PermissionsBitField5(data.permissions),
          mentionable: data.mentionable,
          icon,
          unicode_emoji: data.unicodeEmoji
        };
        const d = await this.client.rest.patch(Routes3.guildRole(this.guild.id, role.id), { body, reason: data.reason });
        const clone = role._clone();
        clone._patch(d);
        return clone;
      }
      async delete(role, reason) {
        const id = this.resolveId(role);
        await this.client.rest.delete(Routes3.guildRole(this.guild.id, id), { reason });
        this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
      }
      async setPosition(role, position, { relative, reason } = {}) {
        role = this.resolve(role);
        if (!role)
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "RoleResolvable");
        const updatedRoles = await setPosition(
          role,
          position,
          relative,
          this.guild._sortedRoles(),
          this.client,
          Routes3.guildRoles(this.guild.id),
          reason
        );
        this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: updatedRoles
        });
        return role;
      }
      async setPositions(rolePositions) {
        rolePositions = rolePositions.map((o) => ({
          id: this.resolveId(o.role),
          position: o.position
        }));
        await this.client.rest.patch(Routes3.guildRoles(this.guild.id), { body: rolePositions });
        return this.client.actions.GuildRolesPositionUpdate.handle({
          guild_id: this.guild.id,
          roles: rolePositions
        }).guild;
      }
      comparePositions(role1, role2) {
        const resolvedRole1 = this.resolve(role1);
        const resolvedRole2 = this.resolve(role2);
        if (!resolvedRole1 || !resolvedRole2) {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "role", "Role nor a Snowflake");
        }
        if (resolvedRole1.position === resolvedRole2.position) {
          return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
        }
        return resolvedRole1.position - resolvedRole2.position;
      }
      botRoleFor(user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          return null;
        return this.cache.find((role) => {
          var _a;
          return ((_a = role.tags) == null ? void 0 : _a.botId) === userId;
        }) ?? null;
      }
      get everyone() {
        return this.cache.get(this.guild.id);
      }
      get premiumSubscriberRole() {
        return this.cache.find((role) => {
          var _a;
          return (_a = role.tags) == null ? void 0 : _a.premiumSubscriberRole;
        }) ?? null;
      }
      get highest() {
        return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
      }
    };
    module2.exports = RoleManager;
  }
});

// ../../node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS({
  "../../node_modules/discord.js/src/managers/StageInstanceManager.js"(exports2, module2) {
    "use strict";
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsTypeError: DiscordjsTypeError2, DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { StageInstance } = require_StageInstance();
    var StageInstanceManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, StageInstance, iterable);
        this.guild = guild;
      }
      async create(channel, options) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        let { topic, privacyLevel, sendStartNotification } = options;
        const data = await this.client.rest.post(Routes3.stageInstances(), {
          body: {
            channel_id: channelId,
            topic,
            privacy_level: privacyLevel,
            send_start_notification: sendStartNotification
          }
        });
        return this._add(data);
      }
      async fetch(channel, { cache = true, force = false } = {}) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        if (!force) {
          const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
          if (existing)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.stageInstance(channelId));
        return this._add(data, cache);
      }
      async edit(channel, options) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "options", "object", true);
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        let { topic, privacyLevel } = options;
        const data = await this.client.rest.patch(Routes3.stageInstance(channelId), {
          body: {
            topic,
            privacy_level: privacyLevel
          }
        });
        if (this.cache.has(data.id)) {
          const clone = this.cache.get(data.id)._clone();
          clone._patch(data);
          return clone;
        }
        return this._add(data);
      }
      async delete(channel) {
        const channelId = this.guild.channels.resolveId(channel);
        if (!channelId)
          throw new DiscordjsError2(ErrorCodes2.StageChannelResolve);
        await this.client.rest.delete(Routes3.stageInstance(channelId));
      }
    };
    module2.exports = StageInstanceManager;
  }
});

// ../../node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS({
  "../../node_modules/discord.js/src/managers/VoiceStateManager.js"(exports2, module2) {
    "use strict";
    var CachedManager = require_CachedManager();
    var VoiceState = require_VoiceState();
    var VoiceStateManager = class extends CachedManager {
      constructor(guild, iterable) {
        super(guild.client, VoiceState, iterable);
        this.guild = guild;
      }
      _add(data, cache = true) {
        const existing = this.cache.get(data.user_id);
        if (existing)
          return existing._patch(data);
        const entry = new this.holds(this.guild, data);
        if (cache)
          this.cache.set(data.user_id, entry);
        return entry;
      }
    };
    module2.exports = VoiceStateManager;
  }
});

// ../../node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/SystemChannelFlagsBitField.js"(exports2, module2) {
    "use strict";
    var { GuildSystemChannelFlags } = require_v106();
    var BitField = require_BitField();
    var SystemChannelFlagsBitField = class extends BitField {
    };
    __publicField(SystemChannelFlagsBitField, "Flags", GuildSystemChannelFlags);
    module2.exports = SystemChannelFlagsBitField;
  }
});

// ../../node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS({
  "../../node_modules/discord.js/src/structures/Guild.js"(exports2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { ChannelType, GuildPremiumTier, Routes: Routes3, GuildFeature } = require_v106();
    var AnonymousGuild = require_AnonymousGuild();
    var GuildAuditLogs = require_GuildAuditLogs();
    var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    var GuildPreview2 = require_GuildPreview();
    var GuildTemplate2 = require_GuildTemplate();
    var Integration = require_Integration();
    var Webhook2 = require_Webhook();
    var WelcomeScreen = require_WelcomeScreen();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
    var GuildBanManager = require_GuildBanManager();
    var GuildChannelManager = require_GuildChannelManager();
    var GuildEmojiManager = require_GuildEmojiManager();
    var GuildInviteManager = require_GuildInviteManager();
    var GuildMemberManager = require_GuildMemberManager();
    var GuildScheduledEventManager = require_GuildScheduledEventManager();
    var GuildStickerManager = require_GuildStickerManager();
    var PresenceManager = require_PresenceManager();
    var RoleManager = require_RoleManager();
    var StageInstanceManager = require_StageInstanceManager();
    var VoiceStateManager = require_VoiceStateManager();
    var DataResolver2 = require_DataResolver();
    var Status2 = require_Status();
    var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    var { discordSort } = require_Util();
    var Guild = class extends AnonymousGuild {
      constructor(client, data) {
        super(client, data, false);
        this.commands = new GuildApplicationCommandManager(this);
        this.members = new GuildMemberManager(this);
        this.channels = new GuildChannelManager(this);
        this.bans = new GuildBanManager(this);
        this.roles = new RoleManager(this);
        this.presences = new PresenceManager(this.client);
        this.voiceStates = new VoiceStateManager(this);
        this.stageInstances = new StageInstanceManager(this);
        this.invites = new GuildInviteManager(this);
        this.scheduledEvents = new GuildScheduledEventManager(this);
        if (!data)
          return;
        if (data.unavailable) {
          this.available = false;
        } else {
          this._patch(data);
          if (!data.channels)
            this.available = false;
        }
        this.shardId = data.shardId;
      }
      get shard() {
        return this.client.ws.shards.get(this.shardId);
      }
      _patch(data) {
        super._patch(data);
        this.id = data.id;
        if ("name" in data)
          this.name = data.name;
        if ("icon" in data)
          this.icon = data.icon;
        if ("unavailable" in data) {
          this.available = !data.unavailable;
        } else {
          this.available ?? (this.available = true);
        }
        if ("discovery_splash" in data) {
          this.discoverySplash = data.discovery_splash;
        }
        if ("member_count" in data) {
          this.memberCount = data.member_count;
        }
        if ("large" in data) {
          this.large = Boolean(data.large);
        }
        if ("premium_progress_bar_enabled" in data) {
          this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
        }
        if ("application_id" in data) {
          this.applicationId = data.application_id;
        }
        if ("afk_timeout" in data) {
          this.afkTimeout = data.afk_timeout;
        }
        if ("afk_channel_id" in data) {
          this.afkChannelId = data.afk_channel_id;
        }
        if ("system_channel_id" in data) {
          this.systemChannelId = data.system_channel_id;
        }
        if ("premium_tier" in data) {
          this.premiumTier = data.premium_tier;
        }
        if ("widget_enabled" in data) {
          this.widgetEnabled = data.widget_enabled;
        } else {
          this.widgetEnabled ?? (this.widgetEnabled = null);
        }
        if ("widget_channel_id" in data) {
          this.widgetChannelId = data.widget_channel_id;
        } else {
          this.widgetChannelId ?? (this.widgetChannelId = null);
        }
        if ("explicit_content_filter" in data) {
          this.explicitContentFilter = data.explicit_content_filter;
        }
        if ("mfa_level" in data) {
          this.mfaLevel = data.mfa_level;
        }
        if ("joined_at" in data) {
          this.joinedTimestamp = Date.parse(data.joined_at);
        }
        if ("default_message_notifications" in data) {
          this.defaultMessageNotifications = data.default_message_notifications;
        }
        if ("system_channel_flags" in data) {
          this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
        }
        if ("max_members" in data) {
          this.maximumMembers = data.max_members;
        } else {
          this.maximumMembers ?? (this.maximumMembers = null);
        }
        if ("max_presences" in data) {
          this.maximumPresences = data.max_presences;
        } else {
          this.maximumPresences ?? (this.maximumPresences = null);
        }
        if ("max_video_channel_users" in data) {
          this.maxVideoChannelUsers = data.max_video_channel_users;
        } else {
          this.maxVideoChannelUsers ?? (this.maxVideoChannelUsers = null);
        }
        if ("approximate_member_count" in data) {
          this.approximateMemberCount = data.approximate_member_count;
        } else {
          this.approximateMemberCount ?? (this.approximateMemberCount = null);
        }
        if ("approximate_presence_count" in data) {
          this.approximatePresenceCount = data.approximate_presence_count;
        } else {
          this.approximatePresenceCount ?? (this.approximatePresenceCount = null);
        }
        this.vanityURLUses ?? (this.vanityURLUses = null);
        if ("rules_channel_id" in data) {
          this.rulesChannelId = data.rules_channel_id;
        }
        if ("public_updates_channel_id" in data) {
          this.publicUpdatesChannelId = data.public_updates_channel_id;
        }
        if ("preferred_locale" in data) {
          this.preferredLocale = data.preferred_locale;
        }
        if (data.channels) {
          this.channels.cache.clear();
          for (const rawChannel of data.channels) {
            this.client.channels._add(rawChannel, this);
          }
        }
        if (data.threads) {
          for (const rawThread of data.threads) {
            this.client.channels._add(rawThread, this);
          }
        }
        if (data.roles) {
          this.roles.cache.clear();
          for (const role of data.roles)
            this.roles._add(role);
        }
        if (data.members) {
          this.members.cache.clear();
          for (const guildUser of data.members)
            this.members._add(guildUser);
        }
        if ("owner_id" in data) {
          this.ownerId = data.owner_id;
        }
        if (data.presences) {
          for (const presence of data.presences) {
            this.presences._add(Object.assign(presence, { guild: this }));
          }
        }
        if (data.stage_instances) {
          this.stageInstances.cache.clear();
          for (const stageInstance of data.stage_instances) {
            this.stageInstances._add(stageInstance);
          }
        }
        if (data.guild_scheduled_events) {
          this.scheduledEvents.cache.clear();
          for (const scheduledEvent of data.guild_scheduled_events) {
            this.scheduledEvents._add(scheduledEvent);
          }
        }
        if (data.voice_states) {
          this.voiceStates.cache.clear();
          for (const voiceState of data.voice_states) {
            this.voiceStates._add(voiceState);
          }
        }
        if (!this.emojis) {
          this.emojis = new GuildEmojiManager(this);
          if (data.emojis)
            for (const emoji of data.emojis)
              this.emojis._add(emoji);
        } else if (data.emojis) {
          this.client.actions.GuildEmojisUpdate.handle({
            guild_id: this.id,
            emojis: data.emojis
          });
        }
        if (!this.stickers) {
          this.stickers = new GuildStickerManager(this);
          if (data.stickers)
            for (const sticker of data.stickers)
              this.stickers._add(sticker);
        } else if (data.stickers) {
          this.client.actions.GuildStickersUpdate.handle({
            guild_id: this.id,
            stickers: data.stickers
          });
        }
      }
      get joinedAt() {
        return new Date(this.joinedTimestamp);
      }
      discoverySplashURL(options = {}) {
        return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
      }
      async fetchOwner(options) {
        if (!this.ownerId) {
          throw new DiscordjsError2(ErrorCodes2.FetchOwnerId);
        }
        const member = await this.members.fetch({ ...options, user: this.ownerId });
        return member;
      }
      get afkChannel() {
        return this.client.channels.resolve(this.afkChannelId);
      }
      get systemChannel() {
        return this.client.channels.resolve(this.systemChannelId);
      }
      get widgetChannel() {
        return this.client.channels.resolve(this.widgetChannelId);
      }
      get rulesChannel() {
        return this.client.channels.resolve(this.rulesChannelId);
      }
      get publicUpdatesChannel() {
        return this.client.channels.resolve(this.publicUpdatesChannelId);
      }
      get maximumBitrate() {
        if (this.features.includes(GuildFeature.VIPRegions)) {
          return 384e3;
        }
        switch (this.premiumTier) {
          case GuildPremiumTier.Tier1:
            return 128e3;
          case GuildPremiumTier.Tier2:
            return 256e3;
          case GuildPremiumTier.Tier3:
            return 384e3;
          default:
            return 96e3;
        }
      }
      async fetchIntegrations() {
        const data = await this.client.rest.get(Routes3.guildIntegrations(this.id));
        return data.reduce(
          (collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)),
          new Collection2()
        );
      }
      async fetchTemplates() {
        const templates = await this.client.rest.get(Routes3.guildTemplates(this.id));
        return templates.reduce((col, data) => col.set(data.code, new GuildTemplate2(this.client, data)), new Collection2());
      }
      async fetchWelcomeScreen() {
        const data = await this.client.rest.get(Routes3.guildWelcomeScreen(this.id));
        return new WelcomeScreen(this, data);
      }
      async createTemplate(name, description) {
        const data = await this.client.rest.post(Routes3.guildTemplates(this.id), { body: { name, description } });
        return new GuildTemplate2(this.client, data);
      }
      async fetchPreview() {
        const data = await this.client.rest.get(Routes3.guildPreview(this.id));
        return new GuildPreview2(this.client, data);
      }
      async fetchVanityData() {
        if (!this.features.includes(GuildFeature.VanityURL)) {
          throw new DiscordjsError2(ErrorCodes2.VanityURL);
        }
        const data = await this.client.rest.get(Routes3.guildVanityUrl(this.id));
        this.vanityURLCode = data.code;
        this.vanityURLUses = data.uses;
        return data;
      }
      async fetchWebhooks() {
        const apiHooks = await this.client.rest.get(Routes3.guildWebhooks(this.id));
        const hooks = new Collection2();
        for (const hook of apiHooks)
          hooks.set(hook.id, new Webhook2(this.client, hook));
        return hooks;
      }
      fetchWidget() {
        return this.client.fetchGuildWidget(this.id);
      }
      async fetchWidgetSettings() {
        const data = await this.client.rest.get(Routes3.guildWidgetSettings(this.id));
        this.widgetEnabled = data.enabled;
        this.widgetChannelId = data.channel_id;
        return {
          enabled: data.enabled,
          channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
        };
      }
      async fetchAuditLogs(options = {}) {
        if (options.before && options.before instanceof GuildAuditLogsEntry)
          options.before = options.before.id;
        const query = makeURLSearchParams2({
          before: options.before,
          limit: options.limit,
          action_type: options.type
        });
        if (options.user) {
          const id = this.client.users.resolveId(options.user);
          if (!id)
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "user", "UserResolvable");
          query.set("user_id", id);
        }
        const data = await this.client.rest.get(Routes3.guildAuditLog(this.id), { query });
        return new GuildAuditLogs(this, data);
      }
      async edit(data) {
        const _data = {};
        if (data.name)
          _data.name = data.name;
        if (typeof data.verificationLevel !== "undefined") {
          _data.verification_level = data.verificationLevel;
        }
        if (typeof data.afkChannel !== "undefined") {
          _data.afk_channel_id = this.client.channels.resolveId(data.afkChannel);
        }
        if (typeof data.systemChannel !== "undefined") {
          _data.system_channel_id = this.client.channels.resolveId(data.systemChannel);
        }
        if (data.afkTimeout)
          _data.afk_timeout = Number(data.afkTimeout);
        if (typeof data.icon !== "undefined")
          _data.icon = await DataResolver2.resolveImage(data.icon);
        if (data.owner)
          _data.owner_id = this.client.users.resolveId(data.owner);
        if (typeof data.splash !== "undefined")
          _data.splash = await DataResolver2.resolveImage(data.splash);
        if (typeof data.discoverySplash !== "undefined") {
          _data.discovery_splash = await DataResolver2.resolveImage(data.discoverySplash);
        }
        if (typeof data.banner !== "undefined")
          _data.banner = await DataResolver2.resolveImage(data.banner);
        if (typeof data.explicitContentFilter !== "undefined") {
          _data.explicit_content_filter = data.explicitContentFilter;
        }
        if (typeof data.defaultMessageNotifications !== "undefined") {
          _data.default_message_notifications = data.defaultMessageNotifications;
        }
        if (typeof data.systemChannelFlags !== "undefined") {
          _data.system_channel_flags = SystemChannelFlagsBitField.resolve(data.systemChannelFlags);
        }
        if (typeof data.rulesChannel !== "undefined") {
          _data.rules_channel_id = this.client.channels.resolveId(data.rulesChannel);
        }
        if (typeof data.publicUpdatesChannel !== "undefined") {
          _data.public_updates_channel_id = this.client.channels.resolveId(data.publicUpdatesChannel);
        }
        if (typeof data.features !== "undefined") {
          _data.features = data.features;
        }
        if (typeof data.description !== "undefined") {
          _data.description = data.description;
        }
        if (typeof data.preferredLocale !== "undefined")
          _data.preferred_locale = data.preferredLocale;
        if ("premiumProgressBarEnabled" in data)
          _data.premium_progress_bar_enabled = data.premiumProgressBarEnabled;
        const newData = await this.client.rest.patch(Routes3.guild(this.id), { body: _data, reason: data.reason });
        return this.client.actions.GuildUpdate.handle(newData).updated;
      }
      async editWelcomeScreen(data) {
        const { enabled, description, welcomeChannels } = data;
        const welcome_channels = welcomeChannels == null ? void 0 : welcomeChannels.map((welcomeChannelData) => {
          const emoji = this.emojis.resolve(welcomeChannelData.emoji);
          return {
            emoji_id: emoji == null ? void 0 : emoji.id,
            emoji_name: (emoji == null ? void 0 : emoji.name) ?? welcomeChannelData.emoji,
            channel_id: this.channels.resolveId(welcomeChannelData.channel),
            description: welcomeChannelData.description
          };
        });
        const patchData = await this.client.rest.patch(Routes3.guildWelcomeScreen(this.id), {
          body: {
            welcome_channels,
            description,
            enabled
          }
        });
        return new WelcomeScreen(this, patchData);
      }
      setExplicitContentFilter(explicitContentFilter, reason) {
        return this.edit({ explicitContentFilter, reason });
      }
      setDefaultMessageNotifications(defaultMessageNotifications, reason) {
        return this.edit({ defaultMessageNotifications, reason });
      }
      setSystemChannelFlags(systemChannelFlags, reason) {
        return this.edit({ systemChannelFlags, reason });
      }
      setName(name, reason) {
        return this.edit({ name, reason });
      }
      setVerificationLevel(verificationLevel, reason) {
        return this.edit({ verificationLevel, reason });
      }
      setAFKChannel(afkChannel, reason) {
        return this.edit({ afkChannel, reason });
      }
      setSystemChannel(systemChannel, reason) {
        return this.edit({ systemChannel, reason });
      }
      setAFKTimeout(afkTimeout, reason) {
        return this.edit({ afkTimeout, reason });
      }
      setIcon(icon, reason) {
        return this.edit({ icon, reason });
      }
      setOwner(owner, reason) {
        return this.edit({ owner, reason });
      }
      setSplash(splash, reason) {
        return this.edit({ splash, reason });
      }
      setDiscoverySplash(discoverySplash, reason) {
        return this.edit({ discoverySplash, reason });
      }
      setBanner(banner, reason) {
        return this.edit({ banner, reason });
      }
      setRulesChannel(rulesChannel, reason) {
        return this.edit({ rulesChannel, reason });
      }
      setPublicUpdatesChannel(publicUpdatesChannel, reason) {
        return this.edit({ publicUpdatesChannel, reason });
      }
      setPreferredLocale(preferredLocale, reason) {
        return this.edit({ preferredLocale, reason });
      }
      setPremiumProgressBarEnabled(enabled = true, reason) {
        return this.edit({ premiumProgressBarEnabled: enabled, reason });
      }
      async setWidgetSettings(settings2, reason) {
        await this.client.rest.patch(Routes3.guildWidgetSettings(this.id), {
          body: {
            enabled: settings2.enabled,
            channel_id: this.channels.resolveId(settings2.channel)
          },
          reason
        });
        return this;
      }
      async setMFALevel(level, reason) {
        await this.client.rest.post(Routes3.guildMFA(this.id), {
          body: {
            level
          },
          reason
        });
        return this;
      }
      async leave() {
        if (this.ownerId === this.client.user.id)
          throw new DiscordjsError2(ErrorCodes2.GuildOwned);
        await this.client.rest.delete(Routes3.userGuild(this.id));
        return this;
      }
      async delete() {
        await this.client.rest.delete(Routes3.guild(this.id));
        return this;
      }
      equals(guild) {
        return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
      }
      toJSON() {
        const json = super.toJSON({
          available: false,
          createdTimestamp: true,
          nameAcronym: true,
          presences: false,
          voiceStates: false
        });
        json.iconURL = this.iconURL();
        json.splashURL = this.splashURL();
        json.discoverySplashURL = this.discoverySplashURL();
        json.bannerURL = this.bannerURL();
        return json;
      }
      get voiceAdapterCreator() {
        return (methods) => {
          this.client.voice.adapters.set(this.id, methods);
          return {
            sendPayload: (data) => {
              if (this.shard.status !== Status2.Ready)
                return false;
              this.shard.send(data);
              return true;
            },
            destroy: () => {
              this.client.voice.adapters.delete(this.id);
            }
          };
        };
      }
      _sortedRoles() {
        return discordSort(this.roles.cache);
      }
      _sortedChannels(channel) {
        const category = channel.type === ChannelType.GuildCategory;
        const channelTypes = [ChannelType.GuildText, ChannelType.GuildAnnouncement];
        return discordSort(
          this.channels.cache.filter(
            (c) => (channelTypes.includes(channel.type) ? channelTypes.includes(c.type) : c.type === channel.type) && (category || c.parent === channel.parent)
          )
        );
      }
    };
    exports2.Guild = Guild;
  }
});

// ../../node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS({
  "../../node_modules/discord.js/src/structures/OAuth2Guild.js"(exports2, module2) {
    "use strict";
    var BaseGuild = require_BaseGuild();
    var PermissionsBitField5 = require_PermissionsBitField();
    var OAuth2Guild = class extends BaseGuild {
      constructor(client, data) {
        super(client, data);
        this.owner = data.owner;
        this.permissions = new PermissionsBitField5(BigInt(data.permissions)).freeze();
      }
    };
    module2.exports = OAuth2Guild;
  }
});

// ../../node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS({
  "../../node_modules/discord.js/src/managers/GuildManager.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("timers");
    var { Collection: Collection2 } = require_dist();
    var { makeURLSearchParams: makeURLSearchParams2 } = require_dist5();
    var { Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { Guild } = require_Guild();
    var GuildChannel = require_GuildChannel();
    var GuildEmoji = require_GuildEmoji();
    var { GuildMember } = require_GuildMember();
    var Invite2 = require_Invite();
    var OAuth2Guild = require_OAuth2Guild();
    var { Role } = require_Role();
    var DataResolver2 = require_DataResolver();
    var Events3 = require_Events();
    var PermissionsBitField5 = require_PermissionsBitField();
    var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    var { resolveColor } = require_Util();
    var cacheWarningEmitted = false;
    var GuildManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, Guild, iterable);
        if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
          cacheWarningEmitted = true;
          process3.emitWarning(
            `Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`,
            "UnsupportedCacheOverwriteWarning"
          );
        }
      }
      resolve(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolve(guild.guild);
        }
        return super.resolve(guild);
      }
      resolveId(guild) {
        if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite2 && guild.guild) {
          return super.resolveId(guild.guild.id);
        }
        return super.resolveId(guild);
      }
      async create({
        name,
        afkChannelId,
        afkTimeout,
        channels = [],
        defaultMessageNotifications,
        explicitContentFilter,
        icon = null,
        roles = [],
        systemChannelId,
        systemChannelFlags,
        verificationLevel
      }) {
        icon = await DataResolver2.resolveImage(icon);
        for (const channel of channels) {
          channel.parent_id = channel.parentId;
          delete channel.parentId;
          channel.user_limit = channel.userLimit;
          delete channel.userLimit;
          channel.rate_limit_per_user = channel.rateLimitPerUser;
          delete channel.rateLimitPerUser;
          channel.rtc_region = channel.rtcRegion;
          delete channel.rtcRegion;
          channel.video_quality_mode = channel.videoQualityMode;
          delete channel.videoQualityMode;
          if (!channel.permissionOverwrites)
            continue;
          for (const overwrite of channel.permissionOverwrites) {
            overwrite.allow && (overwrite.allow = PermissionsBitField5.resolve(overwrite.allow).toString());
            overwrite.deny && (overwrite.deny = PermissionsBitField5.resolve(overwrite.deny).toString());
          }
          channel.permission_overwrites = channel.permissionOverwrites;
          delete channel.permissionOverwrites;
        }
        for (const role of roles) {
          role.color && (role.color = resolveColor(role.color));
          role.permissions && (role.permissions = PermissionsBitField5.resolve(role.permissions).toString());
        }
        systemChannelFlags && (systemChannelFlags = SystemChannelFlagsBitField.resolve(systemChannelFlags));
        const data = await this.client.rest.post(Routes3.guilds(), {
          body: {
            name,
            icon,
            verification_level: verificationLevel,
            default_message_notifications: defaultMessageNotifications,
            explicit_content_filter: explicitContentFilter,
            roles,
            channels,
            afk_channel_id: afkChannelId,
            afk_timeout: afkTimeout,
            system_channel_id: systemChannelId,
            system_channel_flags: systemChannelFlags
          }
        });
        if (this.client.guilds.cache.has(data.id))
          return this.client.guilds.cache.get(data.id);
        return new Promise((resolve) => {
          const handleGuild = (guild) => {
            if (guild.id === data.id) {
              clearTimeout2(timeout);
              this.client.removeListener(Events3.GuildCreate, handleGuild);
              this.client.decrementMaxListeners();
              resolve(guild);
            }
          };
          this.client.incrementMaxListeners();
          this.client.on(Events3.GuildCreate, handleGuild);
          const timeout = setTimeout2(() => {
            this.client.removeListener(Events3.GuildCreate, handleGuild);
            this.client.decrementMaxListeners();
            resolve(this.client.guilds._add(data));
          }, 1e4).unref();
        });
      }
      async fetch(options = {}) {
        const id = this.resolveId(options) ?? this.resolveId(options.guild);
        if (id) {
          if (!options.force) {
            const existing = this.cache.get(id);
            if (existing)
              return existing;
          }
          const data2 = await this.client.rest.get(Routes3.guild(id), {
            query: makeURLSearchParams2({ with_counts: options.withCounts ?? true })
          });
          return this._add(data2, options.cache);
        }
        const data = await this.client.rest.get(Routes3.userGuilds(), { query: makeURLSearchParams2(options) });
        return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection2());
      }
    };
    module2.exports = GuildManager2;
  }
});

// ../../node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS({
  "../../node_modules/discord.js/src/managers/UserManager.js"(exports2, module2) {
    "use strict";
    var { ChannelType, Routes: Routes3 } = require_v106();
    var CachedManager = require_CachedManager();
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { GuildMember } = require_GuildMember();
    var { Message } = require_Message();
    var ThreadMember = require_ThreadMember();
    var User = require_User();
    var UserManager2 = class extends CachedManager {
      constructor(client, iterable) {
        super(client, User, iterable);
      }
      dmChannel(userId) {
        return this.client.channels.cache.find((c) => c.type === ChannelType.DM && c.recipientId === userId) ?? null;
      }
      async createDM(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const dmChannel = this.dmChannel(id);
          if (dmChannel && !dmChannel.partial)
            return dmChannel;
        }
        const data = await this.client.rest.post(Routes3.userChannels(), { body: { recipient_id: id } });
        return this.client.channels._add(data, null, { cache });
      }
      async deleteDM(user) {
        const id = this.resolveId(user);
        const dmChannel = this.dmChannel(id);
        if (!dmChannel)
          throw new DiscordjsError2(ErrorCodes2.UserNoDMChannel);
        await this.client.rest.delete(Routes3.channel(dmChannel.id));
        this.client.channels._remove(dmChannel.id);
        return dmChannel;
      }
      async fetch(user, { cache = true, force = false } = {}) {
        const id = this.resolveId(user);
        if (!force) {
          const existing = this.cache.get(id);
          if (existing && !existing.partial)
            return existing;
        }
        const data = await this.client.rest.get(Routes3.user(id));
        return this._add(data, cache);
      }
      async fetchFlags(user, options) {
        return (await this.fetch(user, options)).flags;
      }
      async send(user, options) {
        return (await this.createDM(user)).send(options);
      }
      resolve(user) {
        if (user instanceof GuildMember || user instanceof ThreadMember)
          return user.user;
        if (user instanceof Message)
          return user.author;
        return super.resolve(user);
      }
      resolveId(user) {
        if (user instanceof ThreadMember)
          return user.id;
        if (user instanceof GuildMember)
          return user.user.id;
        if (user instanceof Message)
          return user.author.id;
        return super.resolveId(user);
      }
    };
    module2.exports = UserManager2;
  }
});

// ../../node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS({
  "../../node_modules/discord.js/src/sharding/ShardClientUtil.js"(exports2, module2) {
    "use strict";
    var process3 = require("process");
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Events3 = require_Events();
    var { makeError, makePlainError } = require_Util();
    var ShardClientUtil2 = class {
      constructor(client, mode) {
        this.client = client;
        this.mode = mode;
        this.parentPort = null;
        if (mode === "process") {
          process3.on("message", this._handleMessage.bind(this));
          client.on("ready", () => {
            process3.send({ _ready: true });
          });
          client.on("disconnect", () => {
            process3.send({ _disconnect: true });
          });
          client.on("reconnecting", () => {
            process3.send({ _reconnecting: true });
          });
        } else if (mode === "worker") {
          this.parentPort = require("worker_threads").parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on("ready", () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on("disconnect", () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on("reconnecting", () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
        }
      }
      get ids() {
        return this.client.options.shards;
      }
      get count() {
        return this.client.options.shardCount;
      }
      send(message) {
        return new Promise((resolve, reject) => {
          if (this.mode === "process") {
            process3.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
          } else if (this.mode === "worker") {
            this.parentPort.postMessage(message);
            resolve();
          }
        });
      }
      fetchClientValues(prop, shard) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process3;
          const listener = (message) => {
            if ((message == null ? void 0 : message._sFetchProp) !== prop || message._sFetchPropShard !== shard)
              return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      broadcastEval(script2, options = {}) {
        return new Promise((resolve, reject) => {
          const parent = this.parentPort ?? process3;
          if (typeof script2 !== "function") {
            reject(new DiscordjsTypeError2(ErrorCodes2.ShardingInvalidEvalBroadcast));
            return;
          }
          script2 = `(${script2})(this, ${JSON.stringify(options.context)})`;
          const listener = (message) => {
            if ((message == null ? void 0 : message._sEval) !== script2 || message._sEvalShard !== options.shard)
              return;
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(parent);
          parent.on("message", listener);
          this.send({ _sEval: script2, _sEvalShard: options.shard }).catch((err) => {
            parent.removeListener("message", listener);
            this.decrementMaxListeners(parent);
            reject(err);
          });
        });
      }
      respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
      }
      async _handleMessage(message) {
        if (!message)
          return;
        if (message._fetchProp) {
          try {
            const props = message._fetchProp.split(".");
            let value = this.client;
            for (const prop of props)
              value = value[prop];
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
          } catch (err) {
            this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
          }
        } else if (message._eval) {
          try {
            this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
          } catch (err) {
            this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
          }
        }
      }
      _respond(type, message) {
        this.send(message).catch((err) => {
          const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
          error.stack = err.stack;
          this.client.emit(Events3.Error, error);
        });
      }
      static singleton(client, mode) {
        if (!this._singleton) {
          this._singleton = new this(client, mode);
        } else {
          client.emit(
            Events3.Warn,
            "Multiple clients created in child process/worker; only the first will handle sharding helpers."
          );
        }
        return this._singleton;
      }
      static shardIdForGuildId(guildId, shardCount) {
        const shard = Number(BigInt(guildId) >> 22n) % shardCount;
        if (shard < 0)
          throw new DiscordjsError2(ErrorCodes2.ShardingShardMiscalculation, shard, guildId, shardCount);
        return shard;
      }
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = ShardClientUtil2;
  }
});

// ../../node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS({
  "../../node_modules/discord.js/src/structures/ClientPresence.js"(exports2, module2) {
    "use strict";
    var { GatewayOpcodes } = require_v106();
    var { Presence } = require_Presence();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ClientPresence2 = class extends Presence {
      constructor(client, data = {}) {
        super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
      }
      set(presence) {
        const packet = this._parse(presence);
        this._patch(packet);
        if (typeof presence.shardId === "undefined") {
          this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        } else if (Array.isArray(presence.shardId)) {
          for (const shardId of presence.shardId) {
            this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
          }
        } else {
          this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
        return this;
      }
      _parse({ status, since, afk, activities }) {
        const data = {
          activities: [],
          afk: typeof afk === "boolean" ? afk : false,
          since: typeof since === "number" && !Number.isNaN(since) ? since : null,
          status: status ?? this.status
        };
        if (activities == null ? void 0 : activities.length) {
          for (const [i, activity] of activities.entries()) {
            if (typeof activity.name !== "string") {
              throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `activities[${i}].name`, "string");
            }
            activity.type ?? (activity.type = 0);
            data.activities.push({
              type: activity.type,
              name: activity.name,
              url: activity.url
            });
          }
        } else if (!activities && (status || afk || since) && this.activities.length) {
          data.activities.push(
            ...this.activities.map((a) => ({
              name: a.name,
              type: a.type,
              url: a.url ?? void 0
            }))
          );
        }
        return data;
      }
    };
    module2.exports = ClientPresence2;
  }
});

// ../../node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS({
  "../../node_modules/discord.js/src/structures/StickerPack.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { DiscordSnowflake } = require_dist3();
    var Base = require_Base();
    var { Sticker: Sticker2 } = require_Sticker();
    var StickerPack2 = class extends Base {
      constructor(client, pack) {
        super(client);
        this.id = pack.id;
        this.stickers = new Collection2(pack.stickers.map((s) => [s.id, new Sticker2(client, s)]));
        this.name = pack.name;
        this.skuId = pack.sku_id;
        this.coverStickerId = pack.cover_sticker_id ?? null;
        this.description = pack.description;
        this.bannerId = pack.banner_asset_id ?? null;
      }
      get createdTimestamp() {
        return DiscordSnowflake.timestampFrom(this.id);
      }
      get createdAt() {
        return new Date(this.createdTimestamp);
      }
      get coverSticker() {
        return this.coverStickerId && this.stickers.get(this.coverStickerId);
      }
      bannerURL(options = {}) {
        return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
      }
    };
    module2.exports = StickerPack2;
  }
});

// ../../node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS({
  "../../node_modules/discord.js/src/structures/VoiceRegion.js"(exports2, module2) {
    "use strict";
    var { flatten } = require_Util();
    var VoiceRegion2 = class {
      constructor(data) {
        this.id = data.id;
        this.name = data.name;
        this.deprecated = data.deprecated;
        this.optimal = data.optimal;
        this.custom = data.custom;
      }
      toJSON() {
        return flatten(this);
      }
    };
    module2.exports = VoiceRegion2;
  }
});

// ../../node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS({
  "../../node_modules/discord.js/src/structures/WidgetMember.js"(exports2, module2) {
    "use strict";
    var Base = require_Base();
    var WidgetMember = class extends Base {
      constructor(client, data) {
        super(client);
        this.id = data.id;
        this.username = data.username;
        this.discriminator = data.discriminator;
        this.avatar = data.avatar;
        this.status = data.status;
        this.deaf = data.deaf ?? null;
        this.mute = data.mute ?? null;
        this.selfDeaf = data.self_deaf ?? null;
        this.selfMute = data.self_mute ?? null;
        this.suppress = data.suppress ?? null;
        this.channelId = data.channel_id ?? null;
        this.avatarURL = data.avatar_url;
        this.activity = data.activity ?? null;
      }
    };
    module2.exports = WidgetMember;
  }
});

// ../../node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS({
  "../../node_modules/discord.js/src/structures/Widget.js"(exports2, module2) {
    "use strict";
    var { Collection: Collection2 } = require_dist();
    var { Routes: Routes3 } = require_v106();
    var Base = require_Base();
    var WidgetMember = require_WidgetMember();
    var Widget2 = class extends Base {
      constructor(client, data) {
        super(client);
        this._patch(data);
      }
      _patch(data) {
        this.id = data.id;
        if ("name" in data) {
          this.name = data.name;
        }
        if ("instant_invite" in data) {
          this.instantInvite = data.instant_invite;
        }
        this.channels = new Collection2();
        for (const channel of data.channels) {
          this.channels.set(channel.id, channel);
        }
        this.members = new Collection2();
        for (const member of data.members) {
          this.members.set(member.id, new WidgetMember(this.client, member));
        }
        if ("presence_count" in data) {
          this.presenceCount = data.presence_count;
        }
      }
      async fetch() {
        const data = await this.client.rest.get(Routes3.guildWidgetJSON(this.id));
        this._patch(data);
        return this;
      }
    };
    module2.exports = Widget2;
  }
});

// ../../node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS({
  "../../node_modules/discord.js/src/util/IntentsBitField.js"(exports2, module2) {
    "use strict";
    var { GatewayIntentBits } = require_v106();
    var BitField = require_BitField();
    var IntentsBitField2 = class extends BitField {
    };
    __publicField(IntentsBitField2, "Flags", GatewayIntentBits);
    module2.exports = IntentsBitField2;
  }
});

// ../../node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS({
  "../../node_modules/discord.js/src/util/Sweepers.js"(exports2, module2) {
    "use strict";
    var { setInterval, clearInterval } = require("timers");
    var { ThreadChannelTypes, SweeperKeys } = require_Constants();
    var Events3 = require_Events();
    var { DiscordjsTypeError: DiscordjsTypeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var Sweepers2 = class {
      constructor(client, options) {
        Object.defineProperty(this, "client", { value: client });
        this.options = options;
        this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
        for (const key of SweeperKeys) {
          if (!(key in options))
            continue;
          this._validateProperties(key);
          const clonedOptions = { ...this.options[key] };
          if (!("filter" in clonedOptions)) {
            switch (key) {
              case "invites":
                clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
                break;
              case "messages":
                clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
                break;
              case "threads":
                clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
            }
          }
          this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
        }
      }
      sweepApplicationCommands(filter) {
        var _a;
        const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
        const globalCommands = ((_a = this.client.application) == null ? void 0 : _a.commands.cache.sweep(filter)) ?? 0;
        this.client.emit(
          Events3.CacheSweep,
          `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`
        );
        return guildCommands + globalCommands;
      }
      sweepBans(filter) {
        return this._sweepGuildDirectProp("bans", filter).items;
      }
      sweepEmojis(filter) {
        return this._sweepGuildDirectProp("emojis", filter).items;
      }
      sweepInvites(filter) {
        return this._sweepGuildDirectProp("invites", filter).items;
      }
      sweepGuildMembers(filter) {
        return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
      }
      sweepMessages(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isTextBased())
            continue;
          channels++;
          messages += channel.messages.cache.sweep(filter);
        }
        this.client.emit(Events3.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
        return messages;
      }
      sweepPresences(filter) {
        return this._sweepGuildDirectProp("presences", filter).items;
      }
      sweepReactions(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let channels = 0;
        let messages = 0;
        let reactions = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!channel.isTextBased())
            continue;
          channels++;
          for (const message of channel.messages.cache.values()) {
            messages++;
            reactions += message.reactions.cache.sweep(filter);
          }
        }
        this.client.emit(
          Events3.CacheSweep,
          `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`
        );
        return reactions;
      }
      sweepStageInstances(filter) {
        return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
      }
      sweepStickers(filter) {
        return this._sweepGuildDirectProp("stickers", filter).items;
      }
      sweepThreadMembers(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let threads = 0;
        let members = 0;
        for (const channel of this.client.channels.cache.values()) {
          if (!ThreadChannelTypes.includes(channel.type))
            continue;
          threads++;
          members += channel.members.cache.sweep(filter);
        }
        this.client.emit(Events3.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
        return members;
      }
      sweepThreads(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let threads = 0;
        for (const [key, val] of this.client.channels.cache.entries()) {
          if (!ThreadChannelTypes.includes(val.type))
            continue;
          if (filter(val, key, this.client.channels.cache)) {
            threads++;
            this.client.channels._remove(key);
          }
        }
        this.client.emit(Events3.CacheSweep, `Swept ${threads} threads.`);
        return threads;
      }
      sweepUsers(filter) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        const users = this.client.users.cache.sweep(filter);
        this.client.emit(Events3.CacheSweep, `Swept ${users} users.`);
        return users;
      }
      sweepVoiceStates(filter) {
        return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
      }
      destroy() {
        for (const key of SweeperKeys) {
          if (this.intervals[key])
            clearInterval(this.intervals[key]);
        }
      }
      static filterByLifetime({
        lifetime = 14400,
        getComparisonTimestamp = (e) => e == null ? void 0 : e.createdTimestamp,
        excludeFromSweep = () => false
      } = {}) {
        if (typeof lifetime !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "lifetime", "number");
        }
        if (typeof getComparisonTimestamp !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "getComparisonTimestamp", "function");
        }
        if (typeof excludeFromSweep !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "excludeFromSweep", "function");
        }
        return () => {
          if (lifetime <= 0)
            return null;
          const lifetimeMs = lifetime * 1e3;
          const now = Date.now();
          return (entry, key, coll) => {
            if (excludeFromSweep(entry, key, coll)) {
              return false;
            }
            const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
            if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
              return false;
            return now - comparisonTimestamp > lifetimeMs;
          };
        };
      }
      static archivedThreadSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (e) => e.archiveTimestamp,
          excludeFromSweep: (e) => !e.archived
        });
      }
      static expiredInviteSweepFilter(lifetime = 14400) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (i) => i.expiresTimestamp
        });
      }
      static outdatedMessageSweepFilter(lifetime = 3600) {
        return this.filterByLifetime({
          lifetime,
          getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
        });
      }
      _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
        if (typeof filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, "filter", "function");
        }
        let guilds = 0;
        let items = 0;
        for (const guild of this.client.guilds.cache.values()) {
          const { cache } = guild[key];
          guilds++;
          items += cache.sweep(filter);
        }
        if (emit) {
          this.client.emit(Events3.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
        }
        return { guilds, items };
      }
      _validateProperties(key) {
        const props = this.options[key];
        if (typeof props !== "object") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}`, "object", true);
        }
        if (typeof props.interval !== "number") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.interval`, "number");
        }
        if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
          if (typeof props.lifetime !== "number") {
            throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.lifetime`, "number");
          }
          return;
        }
        if (typeof props.filter !== "function") {
          throw new DiscordjsTypeError2(ErrorCodes2.InvalidType, `sweepers.${key}.filter`, "function");
        }
      }
      _initInterval(intervalKey, sweepKey, opts) {
        if (opts.interval <= 0 || opts.interval === Infinity)
          return;
        this.intervals[intervalKey] = setInterval(() => {
          const sweepFn = opts.filter();
          if (sweepFn === null)
            return;
          if (typeof sweepFn !== "function")
            throw new DiscordjsTypeError2(ErrorCodes2.SweepFilterReturn);
          this[sweepKey](sweepFn);
        }, opts.interval * 1e3).unref();
      }
    };
    module2.exports = Sweepers2;
  }
});

// ../../node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS({
  "../../node_modules/discord.js/src/client/Client.js"(exports, module) {
    "use strict";
    var process = require("process");
    var { Collection } = require_dist();
    var { makeURLSearchParams } = require_dist5();
    var { OAuth2Scopes, Routes } = require_v106();
    var BaseClient = require_BaseClient();
    var ActionsManager = require_ActionsManager();
    var ClientVoiceManager = require_ClientVoiceManager();
    var WebSocketManager = require_WebSocketManager();
    var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
    var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    var ChannelManager = require_ChannelManager();
    var GuildManager = require_GuildManager();
    var UserManager = require_UserManager();
    var ShardClientUtil = require_ShardClientUtil();
    var ClientPresence = require_ClientPresence();
    var GuildPreview = require_GuildPreview();
    var GuildTemplate = require_GuildTemplate();
    var Invite = require_Invite();
    var { Sticker } = require_Sticker();
    var StickerPack = require_StickerPack();
    var VoiceRegion = require_VoiceRegion();
    var Webhook = require_Webhook();
    var Widget = require_Widget();
    var DataResolver = require_DataResolver();
    var Events = require_Events();
    var IntentsBitField = require_IntentsBitField();
    var Options = require_Options();
    var PermissionsBitField = require_PermissionsBitField();
    var Status = require_Status();
    var Sweepers = require_Sweepers();
    var Client = class extends BaseClient {
      constructor(options) {
        super(options);
        const data = require("worker_threads").workerData ?? process.env;
        const defaults = Options.createDefault();
        if (this.options.shards === defaults.shards) {
          if ("SHARDS" in data) {
            this.options.shards = JSON.parse(data.SHARDS);
          }
        }
        if (this.options.shardCount === defaults.shardCount) {
          if ("SHARD_COUNT" in data) {
            this.options.shardCount = Number(data.SHARD_COUNT);
          } else if (Array.isArray(this.options.shards)) {
            this.options.shardCount = this.options.shards.length;
          }
        }
        const typeofShards = typeof this.options.shards;
        if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
          this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
        }
        if (typeofShards === "number")
          this.options.shards = [this.options.shards];
        if (Array.isArray(this.options.shards)) {
          this.options.shards = [
            ...new Set(
              this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0))
            )
          ];
        }
        this._validateOptions();
        this.ws = new WebSocketManager(this);
        this.actions = new ActionsManager(this);
        this.voice = new ClientVoiceManager(this);
        this.shard = process.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process.env.SHARDING_MANAGER_MODE) : null;
        this.users = new UserManager(this);
        this.guilds = new GuildManager(this);
        this.channels = new ChannelManager(this);
        this.sweepers = new Sweepers(this, this.options.sweepers);
        this.presence = new ClientPresence(this, this.options.presence);
        Object.defineProperty(this, "token", { writable: true });
        if (!this.token && "DISCORD_TOKEN" in process.env) {
          this.token = process.env.DISCORD_TOKEN;
        } else {
          this.token = null;
        }
        this.user = null;
        this.application = null;
        this.readyTimestamp = null;
      }
      get emojis() {
        const emojis = new BaseGuildEmojiManager(this);
        for (const guild of this.guilds.cache.values()) {
          if (guild.available)
            for (const emoji of guild.emojis.cache.values())
              emojis.cache.set(emoji.id, emoji);
        }
        return emojis;
      }
      get readyAt() {
        return this.readyTimestamp && new Date(this.readyTimestamp);
      }
      get uptime() {
        return this.readyTimestamp && Date.now() - this.readyTimestamp;
      }
      async login(token = this.token) {
        if (!token || typeof token !== "string")
          throw new DiscordjsError(ErrorCodes.TokenInvalid);
        this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
        this.rest.setToken(token);
        this.emit(
          Events.Debug,
          `Provided token: ${token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".")}`
        );
        if (this.options.presence) {
          this.options.ws.presence = this.presence._parse(this.options.presence);
        }
        this.emit(Events.Debug, "Preparing to connect to the gateway...");
        try {
          await this.ws.connect();
          return this.token;
        } catch (error) {
          this.destroy();
          throw error;
        }
      }
      isReady() {
        return this.ws.status === Status.Ready;
      }
      destroy() {
        super.destroy();
        this.sweepers.destroy();
        this.ws.destroy();
        this.token = null;
        this.rest.setToken(null);
      }
      async fetchInvite(invite, options) {
        const code = DataResolver.resolveInviteCode(invite);
        const query = makeURLSearchParams({
          with_counts: true,
          with_expiration: true,
          guild_scheduled_event_id: options == null ? void 0 : options.guildScheduledEventId
        });
        const data = await this.rest.get(Routes.invite(code), { query });
        return new Invite(this, data);
      }
      async fetchGuildTemplate(template) {
        const code = DataResolver.resolveGuildTemplateCode(template);
        const data = await this.rest.get(Routes.template(code));
        return new GuildTemplate(this, data);
      }
      async fetchWebhook(id, token) {
        const data = await this.rest.get(Routes.webhook(id, token), { auth: typeof token === "undefined" });
        return new Webhook(this, { token, ...data });
      }
      async fetchVoiceRegions() {
        const apiRegions = await this.rest.get(Routes.voiceRegions());
        const regions = new Collection();
        for (const region of apiRegions)
          regions.set(region.id, new VoiceRegion(region));
        return regions;
      }
      async fetchSticker(id) {
        const data = await this.rest.get(Routes.sticker(id));
        return new Sticker(this, data);
      }
      async fetchPremiumStickerPacks() {
        const data = await this.rest.get(Routes.nitroStickerPacks());
        return new Collection(data.sticker_packs.map((p) => [p.id, new StickerPack(this, p)]));
      }
      async fetchGuildPreview(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
        const data = await this.rest.get(Routes.guildPreview(id));
        return new GuildPreview(this, data);
      }
      async fetchGuildWidget(guild) {
        const id = this.guilds.resolveId(guild);
        if (!id)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
        const data = await this.rest.get(Routes.guildWidgetJSON(id));
        return new Widget(this, data);
      }
      generateInvite(options = {}) {
        if (typeof options !== "object")
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
        if (!this.application)
          throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
        const { scopes } = options;
        if (typeof scopes === "undefined") {
          throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
        }
        if (!Array.isArray(scopes)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
        }
        if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
        }
        const validScopes = Object.values(OAuth2Scopes);
        const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
        if (invalidScope) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
        }
        const query = makeURLSearchParams({
          client_id: this.application.id,
          scope: scopes.join(" "),
          disable_guild_select: options.disableGuildSelect
        });
        if (options.permissions) {
          const permissions2 = PermissionsBitField.resolve(options.permissions);
          if (permissions2)
            query.set("permissions", permissions2.toString());
        }
        if (options.guild) {
          const guildId = this.guilds.resolveId(options.guild);
          if (!guildId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
          query.set("guild_id", guildId);
        }
        return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
      }
      toJSON() {
        return super.toJSON({
          actions: false,
          presence: false
        });
      }
      _eval(script) {
        return eval(script);
      }
      _validateOptions(options = this.options) {
        if (typeof options.intents === "undefined") {
          throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
        } else {
          options.intents = new IntentsBitField(options.intents).freeze();
        }
        if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
        }
        if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
        }
        if (options.shards && !options.shards.length)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
        if (typeof options.makeCache !== "function") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
        }
        if (typeof options.sweepers !== "object" || options.sweepers === null) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
        }
        if (!Array.isArray(options.partials)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
        }
        if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
        }
        if (typeof options.failIfNotExists !== "boolean") {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
        }
      }
    };
    module.exports = Client;
  }
});

// ../../node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS({
  "../../node_modules/discord.js/src/util/ShardEvents.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Death: "death",
      Disconnect: "disconnect",
      Error: "error",
      Message: "message",
      Ready: "ready",
      Reconnecting: "reconnecting",
      Spawn: "spawn"
    };
  }
});

// ../../node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS({
  "../../node_modules/discord.js/src/sharding/Shard.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var path = require("path");
    var process3 = require("process");
    var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = require("timers");
    var { setTimeout: sleep } = require("timers/promises");
    var { DiscordjsError: DiscordjsError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var ShardEvents = require_ShardEvents();
    var { makeError, makePlainError } = require_Util();
    var childProcess = null;
    var Worker = null;
    var Shard = class extends EventEmitter {
      constructor(manager, id) {
        super();
        if (manager.mode === "process")
          childProcess = require("child_process");
        else if (manager.mode === "worker")
          Worker = require("worker_threads").Worker;
        this.manager = manager;
        this.id = id;
        this.args = manager.shardArgs ?? [];
        this.execArgv = manager.execArgv;
        this.env = Object.assign({}, process3.env, {
          SHARDING_MANAGER: true,
          SHARDS: this.id,
          SHARD_COUNT: this.manager.totalShards,
          DISCORD_TOKEN: this.manager.token
        });
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals = /* @__PURE__ */ new Map();
        this._fetches = /* @__PURE__ */ new Map();
        this._exitListener = null;
      }
      spawn(timeout = 3e4) {
        if (this.process)
          throw new DiscordjsError2(ErrorCodes2.ShardingProcessExists, this.id);
        if (this.worker)
          throw new DiscordjsError2(ErrorCodes2.ShardingWorkerExists, this.id);
        this._exitListener = this._handleExit.bind(this, void 0, timeout);
        if (this.manager.mode === "process") {
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
        } else if (this.manager.mode === "worker") {
          this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
        }
        this._evals.clear();
        this._fetches.clear();
        const child = this.process ?? this.worker;
        this.emit(ShardEvents.Spawn, child);
        if (timeout === -1 || timeout === Infinity)
          return Promise.resolve(child);
        return new Promise((resolve, reject) => {
          const cleanup = () => {
            clearTimeout2(spawnTimeoutTimer);
            this.off("ready", onReady);
            this.off("disconnect", onDisconnect);
            this.off("death", onDeath);
          };
          const onReady = () => {
            cleanup();
            resolve(child);
          };
          const onDisconnect = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyDisconnected, this.id));
          };
          const onDeath = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyDied, this.id));
          };
          const onTimeout = () => {
            cleanup();
            reject(new DiscordjsError2(ErrorCodes2.ShardingReadyTimeout, this.id));
          };
          const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
          this.once("ready", onReady);
          this.once("disconnect", onDisconnect);
          this.once("death", onDeath);
        });
      }
      kill() {
        if (this.process) {
          this.process.removeListener("exit", this._exitListener);
          this.process.kill();
        } else {
          this.worker.removeListener("exit", this._exitListener);
          this.worker.terminate();
        }
        this._handleExit(false);
      }
      async respawn({ delay = 500, timeout = 3e4 } = {}) {
        this.kill();
        if (delay > 0)
          await sleep(delay);
        return this.spawn(timeout);
      }
      send(message) {
        return new Promise((resolve, reject) => {
          if (this.process) {
            this.process.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve(this);
            });
          } else {
            this.worker.postMessage(message);
            resolve(this);
          }
        });
      }
      fetchClientValue(prop) {
        if (!this.process && !this.worker) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoChildExists, this.id));
        }
        if (this._fetches.has(prop))
          return this._fetches.get(prop);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if ((message == null ? void 0 : message._fetchProp) !== prop)
              return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _fetchProp: prop }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._fetches.delete(prop);
            reject(err);
          });
        });
        this._fetches.set(prop, promise);
        return promise;
      }
      eval(script2, context) {
        const _eval = typeof script2 === "function" ? `(${script2})(this, ${JSON.stringify(context)})` : script2;
        if (!this.process && !this.worker) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoChildExists, this.id));
        }
        if (this._evals.has(_eval))
          return this._evals.get(_eval);
        const promise = new Promise((resolve, reject) => {
          const child = this.process ?? this.worker;
          const listener = (message) => {
            if ((message == null ? void 0 : message._eval) !== _eval)
              return;
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            if (!message._error)
              resolve(message._result);
            else
              reject(makeError(message._error));
          };
          this.incrementMaxListeners(child);
          child.on("message", listener);
          this.send({ _eval }).catch((err) => {
            child.removeListener("message", listener);
            this.decrementMaxListeners(child);
            this._evals.delete(_eval);
            reject(err);
          });
        });
        this._evals.set(_eval, promise);
        return promise;
      }
      _handleMessage(message) {
        if (message) {
          if (message._ready) {
            this.ready = true;
            this.emit(ShardEvents.Ready);
            return;
          }
          if (message._disconnect) {
            this.ready = false;
            this.emit(ShardEvents.Disconnect);
            return;
          }
          if (message._reconnecting) {
            this.ready = false;
            this.emit(ShardEvents.Reconnecting);
            return;
          }
          if (message._sFetchProp) {
            const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
            this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: makePlainError(err) })
            );
            return;
          }
          if (message._sEval) {
            const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
            this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then(
              (results) => this.send({ ...resp, _result: results }),
              (err) => this.send({ ...resp, _error: makePlainError(err) })
            );
            return;
          }
          if (message._sRespawnAll) {
            const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
            this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
            });
            return;
          }
        }
        this.emit(ShardEvents.Message, message);
      }
      _handleExit(respawn = this.manager.respawn, timeout) {
        this.emit(ShardEvents.Death, this.process ?? this.worker);
        this.ready = false;
        this.process = null;
        this.worker = null;
        this._evals.clear();
        this._fetches.clear();
        if (respawn)
          this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
      }
      incrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners + 1);
        }
      }
      decrementMaxListeners(emitter) {
        const maxListeners = emitter.getMaxListeners();
        if (maxListeners !== 0) {
          emitter.setMaxListeners(maxListeners - 1);
        }
      }
    };
    module2.exports = Shard;
  }
});

// ../../node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS({
  "../../node_modules/discord.js/src/sharding/ShardingManager.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var fs2 = require("fs");
    var path = require("path");
    var process3 = require("process");
    var { setTimeout: sleep } = require("timers/promises");
    var { Collection: Collection2 } = require_dist();
    var Shard = require_Shard();
    var { DiscordjsError: DiscordjsError2, DiscordjsTypeError: DiscordjsTypeError2, DiscordjsRangeError: DiscordjsRangeError2, ErrorCodes: ErrorCodes2 } = require_errors2();
    var { mergeDefault, fetchRecommendedShardCount } = require_Util();
    var ShardingManager = class extends EventEmitter {
      constructor(file, options = {}) {
        var _a;
        super();
        options = mergeDefault(
          {
            totalShards: "auto",
            mode: "process",
            respawn: true,
            shardArgs: [],
            execArgv: [],
            token: process3.env.DISCORD_TOKEN
          },
          options
        );
        this.file = file;
        if (!file)
          throw new DiscordjsError2(ErrorCodes2.ClientInvalidOption, "File", "specified.");
        if (!path.isAbsolute(file))
          this.file = path.resolve(process3.cwd(), file);
        const stats = fs2.statSync(this.file);
        if (!stats.isFile())
          throw new DiscordjsError2(ErrorCodes2.ClientInvalidOption, "File", "a file");
        this.shardList = options.shardList ?? "auto";
        if (this.shardList !== "auto") {
          if (!Array.isArray(this.shardList)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "shardList", "an array.");
          }
          this.shardList = [...new Set(this.shardList)];
          if (this.shardList.length < 1) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "shardList", "at least 1 id.");
          }
          if (this.shardList.some(
            (shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0
          )) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "shardList", "an array of positive integers.");
          }
        }
        this.totalShards = options.totalShards || "auto";
        if (this.totalShards !== "auto") {
          if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "a number.");
          }
          if (this.totalShards < 1) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "at least 1.");
          }
          if (!Number.isInteger(this.totalShards)) {
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "an integer.");
          }
        }
        this.mode = options.mode;
        if (this.mode !== "process" && this.mode !== "worker") {
          throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
        }
        this.respawn = options.respawn;
        this.shardArgs = options.shardArgs;
        this.execArgv = options.execArgv;
        this.token = ((_a = options.token) == null ? void 0 : _a.replace(/^Bot\s*/i, "")) ?? null;
        this.shards = new Collection2();
        process3.env.SHARDING_MANAGER = true;
        process3.env.SHARDING_MANAGER_MODE = this.mode;
        process3.env.DISCORD_TOKEN = this.token;
      }
      createShard(id = this.shards.size) {
        const shard = new Shard(this, id);
        this.shards.set(id, shard);
        this.emit("shardCreate", shard);
        return shard;
      }
      async spawn({ amount = this.totalShards, delay = 5500, timeout = 3e4 } = {}) {
        if (amount === "auto") {
          amount = await fetchRecommendedShardCount(this.token);
        } else {
          if (typeof amount !== "number" || isNaN(amount)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "a number.");
          }
          if (amount < 1)
            throw new DiscordjsRangeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "at least 1.");
          if (!Number.isInteger(amount)) {
            throw new DiscordjsTypeError2(ErrorCodes2.ClientInvalidOption, "Amount of shards", "an integer.");
          }
        }
        if (this.shards.size >= amount)
          throw new DiscordjsError2(ErrorCodes2.ShardingAlreadySpawned, this.shards.size);
        if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
          this.shardList = [...Array(amount).keys()];
        }
        if (this.totalShards === "auto" || this.totalShards !== amount) {
          this.totalShards = amount;
        }
        if (this.shardList.some((shardId) => shardId >= amount)) {
          throw new DiscordjsRangeError2(
            ErrorCodes2.ClientInvalidOption,
            "Amount of shards",
            "bigger than the highest shardId in the shardList option."
          );
        }
        for (const shardId of this.shardList) {
          const promises = [];
          const shard = this.createShard(shardId);
          promises.push(shard.spawn(timeout));
          if (delay > 0 && this.shards.size !== this.shardList.length)
            promises.push(sleep(delay));
          await Promise.all(promises);
        }
        return this.shards;
      }
      broadcast(message) {
        const promises = [];
        for (const shard of this.shards.values())
          promises.push(shard.send(message));
        return Promise.all(promises);
      }
      broadcastEval(script2, options = {}) {
        if (typeof script2 !== "function") {
          return Promise.reject(new DiscordjsTypeError2(ErrorCodes2.ShardingInvalidEvalBroadcast));
        }
        return this._performOnShards("eval", [`(${script2})(this, ${JSON.stringify(options.context)})`], options.shard);
      }
      fetchClientValues(prop, shard) {
        return this._performOnShards("fetchClientValue", [prop], shard);
      }
      _performOnShards(method, args, shard) {
        if (this.shards.size === 0)
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingNoShards));
        if (typeof shard === "number") {
          if (this.shards.has(shard))
            return this.shards.get(shard)[method](...args);
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingShardNotFound, shard));
        }
        if (this.shards.size !== this.shardList.length) {
          return Promise.reject(new DiscordjsError2(ErrorCodes2.ShardingInProcess));
        }
        const promises = [];
        for (const sh of this.shards.values())
          promises.push(sh[method](...args));
        return Promise.all(promises);
      }
      async respawnAll({ shardDelay = 5e3, respawnDelay = 500, timeout = 3e4 } = {}) {
        let s = 0;
        for (const shard of this.shards.values()) {
          const promises = [shard.respawn({ delay: respawnDelay, timeout })];
          if (++s < this.shards.size && shardDelay > 0)
            promises.push(sleep(shardDelay));
          await Promise.all(promises);
        }
        return this.shards;
      }
    };
    module2.exports = ShardingManager;
  }
});

// ../../node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS({
  "../../node_modules/discord.js/src/util/Formatters.js"(exports2, module2) {
    "use strict";
    var { deprecate } = require("util");
    var {
      blockQuote,
      bold,
      channelMention,
      codeBlock,
      formatEmoji,
      hideLinkEmbed,
      hyperlink,
      inlineCode,
      italic,
      quote,
      roleMention,
      spoiler,
      strikethrough,
      time,
      TimestampStyles,
      underscore,
      userMention
    } = require_dist7();
    var Formatters = class extends null {
    };
    __publicField(Formatters, "blockQuote", deprecate(
      blockQuote,
      "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "bold", deprecate(
      bold,
      "Formatters.bold() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "channelMention", deprecate(
      channelMention,
      "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "codeBlock", deprecate(
      codeBlock,
      "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "formatEmoji", deprecate(
      formatEmoji,
      "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "hideLinkEmbed", deprecate(
      hideLinkEmbed,
      "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "hyperlink", deprecate(
      hyperlink,
      "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "inlineCode", deprecate(
      inlineCode,
      "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "italic", deprecate(
      italic,
      "Formatters.italic() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "quote", deprecate(
      quote,
      "Formatters.quote() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "roleMention", deprecate(
      roleMention,
      "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "spoiler", deprecate(
      spoiler,
      "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "strikethrough", deprecate(
      strikethrough,
      "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "time", deprecate(
      time,
      "Formatters.time() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "TimestampStyles", TimestampStyles);
    __publicField(Formatters, "underscore", deprecate(
      underscore,
      "Formatters.underscore() is deprecated. Import this method directly from discord.js instead."
    ));
    __publicField(Formatters, "userMention", deprecate(
      userMention,
      "Formatters.userMention() is deprecated. Import this method directly from discord.js instead."
    ));
    module2.exports = Formatters;
  }
});

// ../../node_modules/discord.js/package.json
var require_package = __commonJS({
  "../../node_modules/discord.js/package.json"(exports2, module2) {
    module2.exports = {
      name: "discord.js",
      version: "14.6.0",
      description: "A powerful library for interacting with the Discord API",
      scripts: {
        test: "yarn docs:test && yarn test:typescript",
        "test:typescript": "tsc --noEmit && tsd",
        lint: "prettier --check . && eslint src && tslint typings/index.d.ts",
        format: "prettier --write . && eslint src --fix",
        fmt: "yarn format",
        docs: "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../ -o ./docs/docs.json",
        "docs:test": "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../",
        prepack: "yarn lint && yarn test",
        changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
        release: "cliff-jumper"
      },
      main: "./src/index.js",
      types: "./typings/index.d.ts",
      directories: {
        lib: "src",
        test: "test"
      },
      files: [
        "src",
        "typings"
      ],
      contributors: [
        "Crawl <icrawltogo@gmail.com>",
        "Amish Shah <amishshah.2k@gmail.com>",
        "Vlad Frangu <kingdgrizzle@gmail.com>",
        "SpaceEEC <spaceeec@yahoo.com>",
        "Aura Rom\xE1n <kyradiscord@gmail.com>"
      ],
      license: "Apache-2.0",
      keywords: [
        "discord",
        "api",
        "bot",
        "client",
        "node",
        "discordapp"
      ],
      repository: {
        type: "git",
        url: "https://github.com/discordjs/discord.js.git"
      },
      bugs: {
        url: "https://github.com/discordjs/discord.js/issues"
      },
      homepage: "https://discord.js.org",
      dependencies: {
        "@discordjs/builders": "^1.3.0",
        "@discordjs/collection": "^1.2.0",
        "@discordjs/rest": "^1.3.0",
        "@discordjs/util": "^0.1.0",
        "@sapphire/snowflake": "^3.2.2",
        "@types/ws": "^8.5.3",
        "discord-api-types": "^0.37.12",
        "fast-deep-equal": "^3.1.3",
        "lodash.snakecase": "^4.1.1",
        tslib: "^2.4.0",
        undici: "^5.11.0",
        ws: "^8.9.0"
      },
      devDependencies: {
        "@discordjs/docgen": "^0.12.1",
        "@favware/cliff-jumper": "^1.8.8",
        "@types/node": "^16.11.64",
        dtslint: "^4.2.1",
        eslint: "^8.25.0",
        jest: "^29.1.2",
        prettier: "^2.7.1",
        tsd: "^0.24.1",
        tslint: "^6.1.3",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=16.9.0"
      }
    };
  }
});

// ../../node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/EmbedBuilder.js"(exports2, module2) {
    "use strict";
    var { EmbedBuilder: BuildersEmbed, isJSONEncodable } = require_dist7();
    var { toSnakeCase } = require_Transformers();
    var { resolveColor } = require_Util();
    var EmbedBuilder = class extends BuildersEmbed {
      constructor(data) {
        super(toSnakeCase(data));
      }
      setColor(color) {
        return super.setColor(color && resolveColor(color));
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = EmbedBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/AttachmentBuilder.js"(exports2, module2) {
    "use strict";
    var { basename, flatten } = require_Util();
    var AttachmentBuilder = class {
      constructor(attachment, data = {}) {
        this.attachment = attachment;
        this.name = data.name;
        this.description = data.description;
      }
      setDescription(description) {
        this.description = description;
        return this;
      }
      setFile(attachment) {
        this.attachment = attachment;
        return this;
      }
      setName(name) {
        this.name = name;
        return this;
      }
      setSpoiler(spoiler = true) {
        if (spoiler === this.spoiler)
          return this;
        if (!spoiler) {
          while (this.spoiler) {
            this.name = this.name.slice("SPOILER_".length);
          }
          return this;
        }
        this.name = `SPOILER_${this.name}`;
        return this;
      }
      get spoiler() {
        return basename(this.name).startsWith("SPOILER_");
      }
      toJSON() {
        return flatten(this);
      }
      static from(other) {
        return new AttachmentBuilder(other.attachment, {
          name: other.name,
          description: other.description
        });
      }
    };
    module2.exports = AttachmentBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/ModalBuilder.js"(exports2, module2) {
    "use strict";
    var { ModalBuilder: BuildersModal, ComponentBuilder, isJSONEncodable } = require_dist7();
    var { toSnakeCase } = require_Transformers();
    var ModalBuilder = class extends BuildersModal {
      constructor({ components, ...data } = {}) {
        super({
          ...toSnakeCase(data),
          components: components == null ? void 0 : components.map((c) => c instanceof ComponentBuilder ? c : toSnakeCase(c))
        });
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = ModalBuilder;
  }
});

// ../../node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS({
  "../../node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js"(exports2, module2) {
    "use strict";
    var { SelectMenuOptionBuilder: BuildersSelectMenuOption, isJSONEncodable } = require_dist7();
    var { toSnakeCase } = require_Transformers();
    var { resolvePartialEmoji } = require_Util();
    var SelectMenuOptionBuilder = class extends BuildersSelectMenuOption {
      constructor({ emoji, ...data } = {}) {
        super(
          toSnakeCase({
            ...data,
            emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
          })
        );
      }
      setEmoji(emoji) {
        if (typeof emoji === "string") {
          return super.setEmoji(resolvePartialEmoji(emoji));
        }
        return super.setEmoji(emoji);
      }
      static from(other) {
        if (isJSONEncodable(other)) {
          return new this(other.toJSON());
        }
        return new this(other);
      }
    };
    module2.exports = SelectMenuOptionBuilder;
  }
});

// ../../node_modules/discord.js/src/index.js
var require_src = __commonJS({
  "../../node_modules/discord.js/src/index.js"(exports2) {
    "use strict";
    var { __exportStar } = require_tslib();
    exports2.BaseClient = require_BaseClient();
    exports2.Client = require_Client();
    exports2.Shard = require_Shard();
    exports2.ShardClientUtil = require_ShardClientUtil();
    exports2.ShardingManager = require_ShardingManager();
    exports2.WebhookClient = require_WebhookClient();
    exports2.DiscordjsError = require_DJSError().DiscordjsError;
    exports2.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
    exports2.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
    exports2.DiscordjsErrorCodes = require_ErrorCodes();
    exports2.ActivityFlagsBitField = require_ActivityFlagsBitField();
    exports2.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
    exports2.BaseManager = require_BaseManager();
    exports2.BitField = require_BitField();
    exports2.ChannelFlagsBitField = require_ChannelFlagsBitField();
    exports2.Collection = require_dist().Collection;
    exports2.Constants = require_Constants();
    exports2.Colors = require_Colors();
    exports2.DataResolver = require_DataResolver();
    exports2.Events = require_Events();
    exports2.Formatters = require_Formatters();
    exports2.IntentsBitField = require_IntentsBitField();
    exports2.LimitedCollection = require_LimitedCollection();
    exports2.MessageFlagsBitField = require_MessageFlagsBitField();
    exports2.Options = require_Options();
    exports2.Partials = require_Partials();
    exports2.PermissionsBitField = require_PermissionsBitField();
    exports2.ShardEvents = require_ShardEvents();
    exports2.Status = require_Status();
    exports2.SnowflakeUtil = require_dist3().DiscordSnowflake;
    exports2.Sweepers = require_Sweepers();
    exports2.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
    exports2.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
    exports2.UserFlagsBitField = require_UserFlagsBitField();
    __exportStar(require_Util(), exports2);
    exports2.WebSocketShardEvents = require_WebSocketShardEvents();
    exports2.version = require_package().version;
    exports2.ApplicationCommandManager = require_ApplicationCommandManager();
    exports2.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
    exports2.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
    exports2.CachedManager = require_CachedManager();
    exports2.ChannelManager = require_ChannelManager();
    exports2.ClientVoiceManager = require_ClientVoiceManager();
    exports2.DataManager = require_DataManager();
    exports2.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
    exports2.GuildBanManager = require_GuildBanManager();
    exports2.GuildChannelManager = require_GuildChannelManager();
    exports2.GuildEmojiManager = require_GuildEmojiManager();
    exports2.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
    exports2.GuildForumThreadManager = require_GuildForumThreadManager();
    exports2.GuildInviteManager = require_GuildInviteManager();
    exports2.GuildManager = require_GuildManager();
    exports2.GuildMemberManager = require_GuildMemberManager();
    exports2.GuildMemberRoleManager = require_GuildMemberRoleManager();
    exports2.GuildScheduledEventManager = require_GuildScheduledEventManager();
    exports2.GuildStickerManager = require_GuildStickerManager();
    exports2.GuildTextThreadManager = require_GuildTextThreadManager();
    exports2.MessageManager = require_MessageManager();
    exports2.PermissionOverwriteManager = require_PermissionOverwriteManager();
    exports2.PresenceManager = require_PresenceManager();
    exports2.ReactionManager = require_ReactionManager();
    exports2.ReactionUserManager = require_ReactionUserManager();
    exports2.RoleManager = require_RoleManager();
    exports2.StageInstanceManager = require_StageInstanceManager();
    exports2.ThreadManager = require_ThreadManager();
    exports2.ThreadMemberManager = require_ThreadMemberManager();
    exports2.UserManager = require_UserManager();
    exports2.VoiceStateManager = require_VoiceStateManager();
    exports2.WebSocketManager = require_WebSocketManager();
    exports2.WebSocketShard = require_WebSocketShard();
    exports2.ActionRow = require_ActionRow();
    exports2.ActionRowBuilder = require_ActionRowBuilder();
    exports2.Activity = require_Presence().Activity;
    exports2.AnonymousGuild = require_AnonymousGuild();
    exports2.Application = require_Application();
    exports2.ApplicationCommand = require_ApplicationCommand();
    exports2.AutocompleteInteraction = require_AutocompleteInteraction();
    exports2.Base = require_Base();
    exports2.BaseGuild = require_BaseGuild();
    exports2.BaseGuildEmoji = require_BaseGuildEmoji();
    exports2.BaseGuildTextChannel = require_BaseGuildTextChannel();
    exports2.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
    exports2.ButtonBuilder = require_ButtonBuilder();
    exports2.ButtonComponent = require_ButtonComponent();
    exports2.ButtonInteraction = require_ButtonInteraction();
    exports2.CategoryChannel = require_CategoryChannel();
    exports2.BaseChannel = require_BaseChannel().BaseChannel;
    exports2.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
    exports2.ClientApplication = require_ClientApplication();
    exports2.ClientPresence = require_ClientPresence();
    exports2.ClientUser = require_ClientUser();
    exports2.CommandInteraction = require_CommandInteraction();
    exports2.Collector = require_Collector();
    exports2.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
    exports2.Component = require_Component();
    exports2.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
    exports2.DMChannel = require_DMChannel();
    exports2.Embed = require_Embed();
    exports2.EmbedBuilder = require_EmbedBuilder();
    exports2.Emoji = require_Emoji().Emoji;
    exports2.ForumChannel = require_ForumChannel();
    exports2.Guild = require_Guild().Guild;
    exports2.GuildAuditLogs = require_GuildAuditLogs();
    exports2.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
    exports2.GuildBan = require_GuildBan();
    exports2.GuildChannel = require_GuildChannel();
    exports2.GuildEmoji = require_GuildEmoji();
    exports2.GuildMember = require_GuildMember().GuildMember;
    exports2.GuildPreview = require_GuildPreview();
    exports2.GuildPreviewEmoji = require_GuildPreviewEmoji();
    exports2.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
    exports2.GuildTemplate = require_GuildTemplate();
    exports2.Integration = require_Integration();
    exports2.IntegrationApplication = require_IntegrationApplication();
    exports2.BaseInteraction = require_BaseInteraction();
    exports2.InteractionCollector = require_InteractionCollector();
    exports2.InteractionResponse = require_InteractionResponse();
    exports2.InteractionWebhook = require_InteractionWebhook();
    exports2.Invite = require_Invite();
    exports2.InviteStageInstance = require_InviteStageInstance();
    exports2.InviteGuild = require_InviteGuild();
    exports2.Message = require_Message().Message;
    exports2.Attachment = require_Attachment();
    exports2.AttachmentBuilder = require_AttachmentBuilder();
    exports2.ModalBuilder = require_ModalBuilder();
    exports2.MessageCollector = require_MessageCollector();
    exports2.MessageComponentInteraction = require_MessageComponentInteraction();
    exports2.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
    exports2.MessageMentions = require_MessageMentions();
    exports2.MessagePayload = require_MessagePayload();
    exports2.MessageReaction = require_MessageReaction();
    exports2.ModalSubmitInteraction = require_ModalSubmitInteraction();
    exports2.ModalSubmitFields = require_ModalSubmitFields();
    exports2.NewsChannel = require_NewsChannel();
    exports2.OAuth2Guild = require_OAuth2Guild();
    exports2.PartialGroupDMChannel = require_PartialGroupDMChannel();
    exports2.PermissionOverwrites = require_PermissionOverwrites();
    exports2.Presence = require_Presence().Presence;
    exports2.ReactionCollector = require_ReactionCollector();
    exports2.ReactionEmoji = require_ReactionEmoji();
    exports2.RichPresenceAssets = require_Presence().RichPresenceAssets;
    exports2.Role = require_Role().Role;
    exports2.SelectMenuBuilder = require_SelectMenuBuilder();
    exports2.SelectMenuComponent = require_SelectMenuComponent();
    exports2.SelectMenuInteraction = require_SelectMenuInteraction();
    exports2.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
    exports2.StageChannel = require_StageChannel();
    exports2.StageInstance = require_StageInstance().StageInstance;
    exports2.Sticker = require_Sticker().Sticker;
    exports2.StickerPack = require_StickerPack();
    exports2.Team = require_Team();
    exports2.TeamMember = require_TeamMember();
    exports2.TextChannel = require_TextChannel();
    exports2.TextInputBuilder = require_TextInputBuilder();
    exports2.TextInputComponent = require_TextInputComponent();
    exports2.ThreadChannel = require_ThreadChannel();
    exports2.ThreadMember = require_ThreadMember();
    exports2.Typing = require_Typing();
    exports2.User = require_User();
    exports2.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
    exports2.VoiceChannel = require_VoiceChannel();
    exports2.VoiceRegion = require_VoiceRegion();
    exports2.VoiceState = require_VoiceState();
    exports2.Webhook = require_Webhook();
    exports2.Widget = require_Widget();
    exports2.WidgetMember = require_WidgetMember();
    exports2.WelcomeChannel = require_WelcomeChannel();
    exports2.WelcomeScreen = require_WelcomeScreen();
    exports2.WebSocket = require_WebSocket();
    __exportStar(require_v106(), exports2);
    __exportStar(require_dist7(), exports2);
    __exportStar(require_dist5(), exports2);
    __exportStar(require_dist2(), exports2);
  }
});

// ../../node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "../../node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// ../../node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "../../node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "../../node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate2(uuid2) {
      return typeof uuid2 === "string" && _regex.default.test(uuid2);
    }
    var _default = validate2;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS({
  "../../node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }
    function stringify2(arr, offset = 0) {
      const uuid2 = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid2;
    }
    var _default = stringify2;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "../../node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v12(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b);
    }
    var _default = v12;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/parse.js
var require_parse = __commonJS({
  "../../node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid2.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid2.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid2.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid2.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid2.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse2;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "../../node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.URL = exports2.DNS = void 0;
    exports2.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes2(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function v35(name, version2, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes2(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version2;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// ../../node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "../../node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "../../node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v32 = (0, _v.default)("v3", 48, _md.default);
    var _default = v32;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/native.js
var require_native = __commonJS({
  "../../node_modules/uuid/dist/native.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _default = {
      randomUUID: _crypto.default.randomUUID
    };
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "../../node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v42(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    var _default = v42;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "../../node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "../../node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v52 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v52;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "../../node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "../../node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version2(uuid2) {
      if (!(0, _validate.default)(uuid2)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid2.slice(14, 15), 16);
    }
    var _default = version2;
    exports2.default = _default;
  }
});

// ../../node_modules/uuid/dist/index.js
var require_dist8 = __commonJS({
  "../../node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  bot: () => bot,
  command: () => command,
  event: () => event
});
module.exports = __toCommonJS(src_exports);
var Discord5 = __toESM(require_src());

// ../../node_modules/chalk/source/vendor/ansi-styles/index.js
var ANSI_BACKGROUND_OFFSET = 10;
var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
var styles = {
  modifier: {
    reset: [0, 0],
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    blackBright: [90, 39],
    gray: [90, 39],
    grey: [90, 39],
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    bgGrey: [100, 49],
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
var modifierNames = Object.keys(styles.modifier);
var foregroundColorNames = Object.keys(styles.color);
var backgroundColorNames = Object.keys(styles.bgColor);
var colorNames = [...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ansiStyles = assembleStyles();
var ansi_styles_default = ansiStyles;

// ../../node_modules/chalk/source/vendor/supports-color/index.js
var import_node_process = __toESM(require("process"), 1);
var import_node_os = __toESM(require("os"), 1);
var import_node_tty = __toESM(require("tty"), 1);
function hasFlag(flag, argv = import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
var { env } = import_node_process.default;
var flagForceColor;
if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
  flagForceColor = 0;
} else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
  flagForceColor = 1;
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version2 = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app":
        return version2 >= 3 ? 3 : 2;
      case "Apple_Terminal":
        return 2;
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var supportsColor = {
  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
};
var supports_color_default = supportsColor;

// ../../node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index = string.indexOf(substring);
  if (index === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index) + substring + replacer;
    endIndex = index + substringLength;
    index = string.indexOf(substring, endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index + 1;
    index = string.indexOf("\n", endIndex);
  } while (index !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}

// ../../node_modules/chalk/source/index.js
var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
var GENERATOR = Symbol("GENERATOR");
var STYLER = Symbol("STYLER");
var IS_EMPTY = Symbol("IS_EMPTY");
var levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
];
var styles2 = /* @__PURE__ */ Object.create(null);
var applyOptions = (object, options = {}) => {
  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error("The `level` option should be an integer from 0 to 3");
  }
  const colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === void 0 ? colorLevel : options.level;
};
var chalkFactory = (options) => {
  const chalk2 = (...strings) => strings.join(" ");
  applyOptions(chalk2, options);
  Object.setPrototypeOf(chalk2, createChalk.prototype);
  return chalk2;
};
function createChalk(options) {
  return chalkFactory(options);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [styleName, style] of Object.entries(ansi_styles_default)) {
  styles2[styleName] = {
    get() {
      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, { value: builder });
      return builder;
    }
  };
}
styles2.visible = {
  get() {
    const builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, "visible", { value: builder });
    return builder;
  }
};
var getModelAnsi = (model, level, type, ...arguments_) => {
  if (model === "rgb") {
    if (level === "ansi16m") {
      return ansi_styles_default[type].ansi16m(...arguments_);
    }
    if (level === "ansi256") {
      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
    }
    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
  }
  if (model === "hex") {
    return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
  }
  return ansi_styles_default[type][model](...arguments_);
};
var usedModels = ["rgb", "hex", "ansi256"];
for (const model of usedModels) {
  styles2[model] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
  styles2[bgModel] = {
    get() {
      const { level } = this;
      return function(...arguments_) {
        const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
}
var proto = Object.defineProperties(() => {
}, {
  ...styles2,
  level: {
    enumerable: true,
    get() {
      return this[GENERATOR].level;
    },
    set(level) {
      this[GENERATOR].level = level;
    }
  }
});
var createStyler = (open2, close2, parent) => {
  let openAll;
  let closeAll;
  if (parent === void 0) {
    openAll = open2;
    closeAll = close2;
  } else {
    openAll = parent.openAll + open2;
    closeAll = close2 + parent.closeAll;
  }
  return {
    open: open2,
    close: close2,
    openAll,
    closeAll,
    parent
  };
};
var createBuilder = (self2, _styler, _isEmpty) => {
  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self2;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};
var applyStyle = (self2, string) => {
  if (self2.level <= 0 || !string) {
    return self2[IS_EMPTY] ? "" : string;
  }
  let styler = self2[STYLER];
  if (styler === void 0) {
    return string;
  }
  const { openAll, closeAll } = styler;
  if (string.includes("\x1B")) {
    while (styler !== void 0) {
      string = stringReplaceAll(string, styler.close, styler.open);
      styler = styler.parent;
    }
  }
  const lfIndex = string.indexOf("\n");
  if (lfIndex !== -1) {
    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
  }
  return openAll + string + closeAll;
};
Object.defineProperties(createChalk.prototype, styles2);
var chalk = createChalk();
var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
var source_default = chalk;

// src/utils/index.ts
var Discord = __toESM(require_src());
var permissions = class {
  static translate(permission) {
    return this.names[permission];
  }
  static getIdentifiers(permission) {
    const permissions2 = new Discord.PermissionsBitField(permission);
    if (permissions2.has(Discord.PermissionFlagsBits.Administrator))
      return ["Administrator"];
    return permissions2.toArray();
  }
};
__publicField(permissions, "names", {
  CreateInstantInvite: "Create Instant Invite",
  KickMembers: "Kick Members",
  BanMembers: "Ban Members",
  Administrator: "Adiminstrator",
  ManageChannels: "Manage Channels",
  ManageGuild: "Manage Server",
  AddReactions: "Add Reactions",
  ViewAuditLog: "View Audit Log",
  PrioritySpeaker: "Priority Speaker",
  Stream: "Stream In Voice Chat",
  ViewChannel: "View Channel",
  SendMessages: "Send Messages",
  SendTTSMessages: "Send TTS Messages",
  ManageMessages: "Manage Messages",
  EmbedLinks: "Embed Links",
  AttachFiles: "Attach Files",
  ReadMessageHistory: "Read Message History",
  MentionEveryone: "Mention",
  UseExternalEmojis: "Use External Emojis",
  ViewGuildInsights: "View Server Insights",
  Connect: "Connect To Voice Chat",
  Speak: "Speak In Voice Chat",
  MuteMembers: "Mute Members",
  DeafenMembers: "Deafen Members",
  MoveMembers: "Move Members",
  UseVAD: "Use Voice-Activity-Detection",
  ChangeNickname: "Change Nicknames",
  ManageNicknames: "Manage Nicknames",
  ManageRoles: "Manage Roles",
  ManageWebhooks: "Manage Webhooks",
  ManageEmojisAndStickers: "Manage Emojis & Stickers",
  UseApplicationCommands: "Use Application Commands",
  RequestToSpeak: "Speak In Stage Channels",
  ManageEvents: "Manage Events",
  ManageThreads: "Manage Threads",
  CreatePublicThreads: "Create Public Threads",
  CreatePrivateThreads: "Create Private Threads",
  UseExternalStickers: "Use External Stickers",
  SendMessagesInThreads: "Send Messages In Threads",
  UseEmbeddedActivities: "Use Embedded ACtivities",
  ModerateMembers: "Moderate Members"
});
var utilities = class {
};
__publicField(utilities, "permissions", permissions);
__publicField(utilities, "events", Discord.Events);

// src/managers/events/event.ts
var event = class {
  constructor(instance, name) {
    this.instance = instance;
    this.name = name;
  }
};

// src/presets/events/ready.ts
var readyEvent = class extends event {
  constructor(instance) {
    super(instance, utilities.events.ClientReady);
  }
  first = true;
  async run() {
    var _a, _b;
    console.log(`Logged in as ${(_b = (_a = this.instance) == null ? void 0 : _a.client.user) == null ? void 0 : _b.tag}`);
    this.instance.customStatusLoop();
    this.instance.ready = true;
    this.first = false;
  }
};

// src/presets/events/interactionCreate.ts
var interactionEvent = class extends event {
  constructor(instance) {
    super(instance, "interactionCreate");
    this.instance = instance;
  }
  async run(interaction) {
    if (!this.instance.ready)
      return void console.log(`Ignoring interaction event as client isn't ready yet`);
    if (interaction.isChatInputCommand()) {
      if (!interaction.inGuild)
        return;
      await this.instance.commandManager.run(interaction);
    }
  }
};

// src/managers/events/index.ts
var eventManager = class {
  constructor(instance) {
    this.instance = instance;
    if (typeof bot.instance.config.presets.events === "boolean" && bot.instance.config.presets.events)
      this.registerEvents();
  }
  events = {};
  registerEvents() {
    this._registerEvent(new readyEvent(this.instance));
    this._registerEvent(new interactionEvent(this.instance));
  }
  _registerEvent(event2) {
    this.events[event2.name] = event2;
    this.instance.client.on(event2.name, event2.run.bind(event2));
  }
  registerEvent(event2) {
    if (typeof bot.instance.config.presets.events === "boolean" && bot.instance.config.presets.events) {
      console.warn(
        `${source_default.black.bgYellow(" WARNING ")} ${source_default.red(`You opted-in for preset events, to add events opt-out of the event preset`)}`
      );
      return;
    }
    if (event2.name !== "interactionCreate" && !this.getEvent("interactionCreate") && typeof bot.instance.config.presets.commands === "boolean" && bot.instance.config.presets.commands)
      console.warn(
        `${source_default.black.bgYellow(" WARNING ")} ${source_default.red(`The 'interactionCreate' event is missing
This is required to use preset slash commands
Please create or opt-in to preset events`)}`
      );
    this.events[event2.name] = event2;
    this.instance.client.on(event2.name, event2.run.bind(event2));
  }
  getEvent(name) {
    return this.events[name];
  }
  getEvents() {
    return Object.values(this.events);
  }
};

// src/managers/commands/index.ts
var Discord4 = __toESM(require_src());

// ../../node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist8(), 1);
var v1 = import_dist.default.v1;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var NIL = import_dist.default.NIL;
var version = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse = import_dist.default.parse;

// src/presets/commands/hello.ts
var Discord3 = __toESM(require_src());

// src/managers/commands/command.ts
var Discord2 = __toESM(require_src());
var command = class {
  constructor(instance, permissions2) {
    this.instance = instance;
    if (permissions2)
      this.permissions = new Discord2.PermissionsBitField(this.permissions).bitfield | new Discord2.PermissionsBitField(permissions2).bitfield;
  }
  vanished = false;
  interactive = false;
  permissions = [
    Discord2.PermissionFlagsBits.SendMessages,
    Discord2.PermissionFlagsBits.ViewChannel,
    Discord2.PermissionFlagsBits.EmbedLinks
  ];
  async calculatePermissions(interaction) {
    return this.permissions;
  }
  requireUserPemission(permission, member, interaction) {
    if (!member.permissions.has(permission)) {
      const missing = new Discord2.PermissionsBitField(permission);
      const identifiers = utilities.permissions.getIdentifiers(missing);
      interaction.reply(
        "> **Permissions Error!**\nYou are missing the following permissions\n" + identifiers.map(utilities.permissions.translate).map((name) => `- \`${name}\``).join("\n")
      );
    }
  }
};

// src/presets/commands/hello.ts
var helloCommand = class extends command {
  name = "hello";
  data = new Discord3.SlashCommandBuilder().setName("hello").setDescription("Hello World! Learn more about mizu.js");
  async run(interaction) {
    const embed = {
      color: 14961966,
      title: "Welcome to Mizu.js!",
      description: "Get started by editing `commands/hello.ts`"
    };
    return void await interaction.reply({
      embeds: [embed]
    });
  }
};

// src/managers/commands/index.ts
var commandManager = class {
  constructor(instance) {
    this.instance = instance;
    this.registerCommands();
  }
  interactive = {};
  running = [];
  commands = {};
  lastCommandUsage = {};
  isRunning(id) {
    return this.running.includes(id);
  }
  async run(interaction) {
    var _a;
    if (!interaction.user || interaction.user.bot || !interaction.guild || !interaction.channel || !interaction.channel.isTextBased())
      return;
    const command2 = this.getCommand(interaction.commandName);
    if (!command2)
      return;
    const channel = interaction.channel;
    const requiredPermissions = new Discord4.PermissionsBitField(
      await command2.calculatePermissions(interaction)
    );
    const channelPermissions = !channel.isDMBased() ? channel.permissionsFor(String((_a = this.instance.client.user) == null ? void 0 : _a.id)) || new Discord4.PermissionsBitField() : null;
    const missing = channelPermissions ? requiredPermissions.bitfield & ~channelPermissions.bitfield : null;
    if (missing) {
      if (channelPermissions == null ? void 0 : channelPermissions.has(Discord4.PermissionFlagsBits.SendMessages)) {
        return void await interaction.reply(
          "> **Permissions Error!**\nThis bot is missing the required permissions to run this command."
        );
      } else {
        return void await interaction.user.send(
          "> **Permissions Error!**\nGrant this bot `Send Messages` to execute commands."
        );
      }
    }
    const id = v4();
    const unhookInteraction = () => {
      const index = this.running.indexOf(id);
      if (index > -1) {
        this.running.splice(index, 1);
        this.interactive[interaction.user.id] = void 0;
      }
    };
    try {
      const interactive = this.interactive[interaction.user.id];
      if (interactive) {
        try {
          await interactive();
        } catch (error) {
        }
        this.interactive[interaction.user.id] = void 0;
        return;
      }
      if (command2.interactive) {
        this.running.push(id);
        this.interactive[interaction.user.id] = async () => {
          const index = this.running.indexOf(id);
          if (index > -1)
            this.running.splice(index, 1);
          await channel.send(`> ${command2.interactive}`);
        };
      }
      await command2.run(interaction, id, unhookInteraction);
    } catch (error) {
      await interaction.reply(
        `> **Command Error!**
${JSON.stringify(error)}`
      );
      console.error(`Catched error while command execution!`, error);
    } finally {
      unhookInteraction();
    }
  }
  registerCommands() {
    if (typeof this.instance.config.presets.commands === "boolean" && this.instance.config.presets.commands) {
      this.registerCommand(new helloCommand(this.instance));
    }
    this.loadCommands();
  }
  registerCommand(command2) {
    this.commands[command2.data.toJSON().name.toLowerCase()] = command2;
  }
  getCommand(name) {
    let command2 = this.commands[name.toLowerCase()];
    return command2;
  }
  getCommands() {
    return Object.values(this.commands);
  }
  loadCommands() {
    const rest = new Discord4.REST().setToken(this.instance.config.token);
    const _commands = this.getCommands();
    var commands = [];
    _commands.forEach((command2) => {
      commands.push(command2.data.toJSON());
    });
    (async () => {
      try {
        console.log(
          `Refreshing ${commands.length} application (slash) commands.`
        );
        const data = await rest.put(
          Discord4.Routes.applicationCommands(
            this.instance.config.application.id
          ),
          { body: commands }
        );
        console.log(
          `Successfully reloaded ${data.length} application (slash) commands.`
        );
      } catch (error) {
        console.error(error);
      }
    })();
  }
};

// src/index.ts
var _bot = class {
  appId;
  directory = __dirname;
  client;
  eventManager;
  commandManager;
  ready = false;
  config;
  constructor(configuration) {
    var _a;
    if (typeof configuration.presets.events === "undefined")
      configuration.presets.events = true;
    this.config = configuration;
    _bot.instance = this;
    this.client = new Discord5.Client(configuration.options);
    this.appId = (_a = this.client.application) == null ? void 0 : _a.id;
    this.eventManager = new eventManager(this);
    this.commandManager = new commandManager(this);
    this.init();
  }
  async init() {
    console.log("Logging in to Discord...");
    await this.client.login(this.config.token);
  }
  async customStatusLoop() {
    var _a;
    (_a = this.client.user) == null ? void 0 : _a.setPresence({
      status: "dnd"
    });
    setTimeout(this.customStatusLoop.bind(this), 1e3 * 60 * 15);
  }
};
var bot = _bot;
__publicField(bot, "instance");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bot,
  command,
  event
});
/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
